{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"quantpylib","text":"DISCLAIMER  None of the information contained here or on hangukquant.substack.com or its affiliated platforms constitutes an offer (or solicitation of an offer) to buy or sell any currency, product or financial instrument, to make any investment, or to participate in any particular trading strategy, or a recommendation for any security or any third party. Trading involves real risks of loss and is solely your responsibility. Past performance is not indicative of future performance; material enclosed herein is for educational purposes only. There is absolutely no warranty or guarantee implied with this product. Use at your own risk. Trading is a risky operation.  COPYRIGHT  Sharing and distribution of any material taken herein is not allowed without express and written approval by HangukQuant, and is only intended for private usage. The code is meant for subscribers of hangukquant.substack.com and any member expressly allowed by HangukQuant.  <p>Welcome to the <code>quantpylib</code> repository! This repository is a Python package for quantitative trading and research, with in-house tools for powerful, fast, flexible and batteries-included quantitative backtesting, data retrieval and all things quant trading. The library is not specific to any strategy or trading instrument. Members are encouraged to participate in the contribution of the code.</p> <p>The code requires a 3.8+ version of Python to run.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Installation</li> <li>User Documentation and Examples,</li> <li>Running Tests</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>To install this library, users need to obtain access to the private Github repo by leaving your Github id on our post or directly requesting to be shortlisted (for unpaid readers) to HangukQuant by email (hangukquant@gmail.com).</p> <p>You can use <code>quantpylib</code> in your local Python environment after cloning our repository and running bash script: <pre><code>chmod +x install.sh\n./install.sh\n</code></pre> in the working directory with the <code>setup.py</code> Python script.</p>"},{"location":"#user-documentation-and-examples","title":"User Documentation and Examples","text":"<p>You can jump into our examples here, or go through official documentation hosted here.</p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>Our test suites can be run using the <code>pytest</code> framework. To run all tests, run  <pre><code>python3 -m pip install pytest\npython3 -m pytest quantpylib/tests \n</code></pre> For more verbose test information, run <pre><code>python3 -m pytest quantpylib/tests -vs \n</code></pre> You can choose specific modules or scripts to test by specifying the path to the test suite <pre><code>python3 -m pytest quantpylib/tests/simulator\npython3 -m pytest quantpylib/tests/simulator/test_operators.py\n</code></pre> Contributors who modify the codebase should run all tests and verify the tests pass before submitting a Pull Request.</p>"},{"location":"datapoller/base/","title":"quantpylib.datapoller.base","text":""},{"location":"datapoller/base/#quantpylib.datapoller.base.BasePoller","title":"<code>BasePoller</code>","text":"<p>A base class for creating pollers to interact with various data sources.</p> <p>Attributes:</p> Name Type Description <code>pollers</code> <code>dict</code> <p>A dictionary of pollers for different data sources.</p> <code>default_src</code> <code>str</code> <p>The default data source to be used.</p>"},{"location":"datapoller/base/#quantpylib.datapoller.base.BasePoller.__init__","title":"<code>__init__(pollers, default_src='')</code>","text":"<p>Initialize the BasePoller with pollers and default data source.</p> <p>Parameters:</p> Name Type Description Default <code>pollers</code> <code>dict</code> <p>A dictionary of pollers for different data sources.</p> required <code>default_src</code> <code>str</code> <p>The default data source to be used.</p> <code>''</code>"},{"location":"datapoller/crypto/","title":"quantpylib.datapoller.crypto","text":""},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto","title":"<code>Crypto</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_funding_rates","title":"<code>get_funding_rates(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve funding rate data for cryptocurrencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.crypto.get_funding_rates(ticker=\"ETH\",start=start,end=end,src=\"hyperliquid\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, **kwargs)</code>","text":"<p>Retrieve fundamentals data for a specific cryptocurrency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Fundamentals data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f=datapoller.crypto.get_ticker_fundamentals(ticker=\"ETH-USD\",src=\"eodhd\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for a specific cryptocurrency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Metadata for the specified cryptocurrency from the selected data source.</p>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for cryptocurrencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.crypto.get_trade_bars(ticker=\"BTCUSDT\",start=start,end=end,granularity=\"d\",src=\"binance\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L1 OB data for a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.crypto.l1_book_subscribe(ticker=\"BTC-USD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 OB data for a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.crypto.l2_book_subscribe(ticker=\"BTC-USD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/currencies/","title":"quantpylib.datapoller.currencies","text":""},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies","title":"<code>Currencies</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for a specific currency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Metadata for the specified currency from the selected data source.</p>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for currencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"d\",src=\"oanda\")\n&gt;&gt;&gt; df=datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",granularity=\"h\",granularity_multiplier=4,start=start,end=end,src=\"oanda\")\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Streaming market data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.currencies.l1_book_subscribe(ticker=\"EURUSD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Streaming market data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.currencies.l2_book_subscribe(ticker=\"EURUSD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/datapoller/","title":"quantpylib.datapoller","text":"<p><code>quantpylib.datapoller</code> is a quant module used for multi-asset, multi-source/vendor/exchange financial data retrieval. </p> <p>The datapollers are categorized into their data-classes, with current support for: </p> <pre><code>- crypto\n- currencies \n- equities\n- exchange\n- metadata\n</code></pre> <p>The datasources supported are:</p> <pre><code>- binance\n- eodhd\n- oanda\n- hyperliquid\n- yfinance\n</code></pre> <p>In general, a trader may have requirements for different asset-class/categories of financial data, subscriptions to  multiple data sources, with each data source supporting a subset of the asset-class universe. Each data source  has its own endpoints, parameters, rate-restrictions and authentication flow - the datapoller abstracts these concerns  to provide a seamless interface for data retrieval while attempting to maximize throughput. </p> <p>Each datapoller is derived from the base <code>quantpylib.datapoller.base.BasePoller</code> class and implements a set of methods, and routs the requests to the specified data source and endpoints. The supported data sources are written as wrappers  on the <code>quantpylib.wrappers</code> module, and their supported endpoints share the same function name as in the datapollers.  The different datapollers are accessible via the master data polling class, given in <code>quantpylib.datapoller.master.Datapoller</code> object instance. For instance, if we would like to get trade bars using the <code>quantpylib.datapoller.currencies.Currencies.get_trade_bars</code>, we can do so by creating a <code>obj = DataPoller(...)</code> instance, and calling <code>obj.currencies.get_trade_bars(...,src=\"oanda\")</code>. The function call is only valid if it is supported by both the datapoller and the datasource, which we can check by their matching  function signatures. In general each datasource has its own parameters to the vendor-specific endpoint, as well as different specifications (such as start time of OHLCV historical request in YYYY-MM-DD vs unix-timestamp), so the library provides a unified standard that convert between these specifications. In addition, the datapoller take in flexible arguments  to support the different configurations for each external API - it would be alot easier to understand through the given examples.</p> <p>Note that each of the datasource wrappers are also designed to be available for use as standalone Python-SDKs. Supported datapollers and datasources are added and updated frequently.</p> <p>To understand the valid function signatures of each datapoller, we need to understand the function\u2019s decorator-type,  which is indicated <code>@poller</code> or <code>@ts_poller</code> in the documentation, and is defined in <code>quantpylib.datapoller.utils</code> module for polling or time-series polling respectively.  The default arguments are supplied through these decorators, which also provide parameter-standardization and parameter-guessing  for vendor/source-unique specifications. Source-specific arguments are documented in its corresponding data-wrapper.</p> <p>We now walkthrough how to construct a valid datapolling request and construct valid parameters to our datapollers for the various datasources. Note that the various endpoints and their matching  function name-signatures can be easily looked up in the search-bar (top right): </p> <p>We need more data sources, more data pollers and more data endpoints to support. If there is a particular functionality  you would like documented or implemented, please feel free to reach out to me @ hangukquant@gmail.com or submit a Github issue. Cheers.</p>"},{"location":"datapoller/datapoller/#walkthrough","title":"Walkthrough","text":"<p>Supposed we are interested in getting some OHLC(V) data for equities. From our <code>quantpylib.wrappers</code> library, we see that the datasources supported with equities data is <code>eodhd</code> and <code>yfinance</code>. Suppose we have no API access to <code>eodhd</code>, so we will make a request through  the <code>yfinance</code> library. To see what endpoints are available  in the <code>equities</code> datapoller, we can just look at the documentation page - the sidebar has a summary, which we see has a <code>get_trade_bars</code> method. The arguments are not specified, but it is tagged <code>@ts_poller</code>, which means the arguments to supply are  given by decorators, documented here. The augmented arguments are <code>ticker</code>, <code>start</code>, <code>end</code>, <code>periods</code> <code>granularity</code>, <code>granularity_multiplier</code> and <code>src</code>. We shall provide <code>ticker</code>, <code>start</code>, <code>periods</code> and <code>src</code> to make our request, and let the rest settle to default arguments.</p> <p>A dictionary containing configuration keys for different data sources we  have access to is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code>, where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the <code>src</code> parameter in the datapoller methods.</p> <p>We already have the keys in our <code>.env</code> file in the current working directory, and we will make the following imports: <pre><code>import os\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\nfrom quantpylib.datapoller.master import DataPoller\n\nconfig_keys = {\n    \"yfinance\": {\"alias\":\"yfinance\"},\n    \"eodhd\": {\"eod_key\":os.getenv(\"EOD_KEY\")},\n    \"binance\": {},\n    \"oanda\": {\n        \"alias\":\"oanda\",\n        \"account_id\":os.getenv(\"OANDA_ACC\"),\n        \"secret\": os.getenv(\"OANDA_KEY\"),\n        \"env\":\"practice\",\n    },\n    \"hyperliquid\": {\"alias\":\"hyp\",\"key\":os.getenv(\"HYP_PUBLIC\"),\"secret\":os.getenv(\"HYP_KEY\")},\n}\n\n\nasync def main():\n    start,end=datetime(2023,9,30),datetime.now()\n    datapoller = DataPoller(config_keys=config_keys)\n    print(datapoller.src_pollers)\n\n    await datapoller.init_clients()\n\n    #...code goes between here...\n\n    await datapoller.cleanup_clients()\n    print(\"cleanup\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> We only need secret keys for private endpoints, and only <code>eodhd</code>, <code>oanda</code> keys are required for the demonstration here. The rest allow retrieval of data through their public endpoints. We can of course omit it all together, if we are not interested in having access to its data archives.  We just instantiated a master datapoller with our keys. We used the alias <code>hyp</code> for <code>hyperliquid</code> in our datapoller initiation. We may access the equities <code>get_trade_bars</code> method and specify <code>src=\"yfinance\"</code> alias, like this: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    periods=365,\n    src=\"yfinance\"\n)\nprint(df)\n</code></pre> This gives us a year-worth of data for the year 2000~2001: <pre><code>                               open      high       low     close     volume\ndatetime                                                                    \n2000-01-03 00:00:00-05:00  0.792742  0.850379  0.768648  0.846127  535796800\n2000-01-04 00:00:00-05:00  0.818254  0.836206  0.764869  0.774790  512377600\n2000-01-05 00:00:00-05:00  0.784238  0.835733  0.778569  0.786128  778321600\n2000-01-06 00:00:00-05:00  0.802191  0.808805  0.718098  0.718098  767972800\n2000-01-07 00:00:00-05:00  0.729436  0.763452  0.721878  0.752113  460734400\n...                             ...       ...       ...       ...        ...\n2000-12-22 00:00:00-05:00  0.213539  0.226768  0.213539  0.226768  318052000\n2000-12-26 00:00:00-05:00  0.224878  0.226768  0.215429  0.222044  216815200\n2000-12-27 00:00:00-05:00  0.216846  0.223933  0.214484  0.223933  325466400\n2000-12-28 00:00:00-05:00  0.217319  0.225823  0.216374  0.223933  305177600\n2000-12-29 00:00:00-05:00  0.222044  0.226768  0.219209  0.224878  630336000\n</code></pre> Now if we were to specify <code>end=datetime(2000,1,1)</code> instead of <code>start=datetime(2000,1,1)</code>, then  we will have data from 1999~2000. Or we can just specify  the <code>start</code>,<code>end</code> directly, which means we can exclude the  <code>periods</code> parameter, like this: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"yfinance\"\n)\nprint(df)\n</code></pre> to get  <pre><code>                                open       high        low      close     volume\ndatetime                                                                        \n2000-01-03 00:00:00-05:00   0.792742   0.850379   0.768648   0.846127  535796800\n2000-01-04 00:00:00-05:00   0.818254   0.836206   0.764869   0.774790  512377600\n2000-01-05 00:00:00-05:00   0.784238   0.835734   0.778569   0.786128  778321600\n2000-01-06 00:00:00-05:00   0.802191   0.808805   0.718097   0.718097  767972800\n2000-01-07 00:00:00-05:00   0.729436   0.763452   0.721878   0.752113  460734400\n...                              ...        ...        ...        ...        ...\n2019-12-24 00:00:00-05:00  69.250147  69.298799  68.819601  69.147980   48478800\n2019-12-26 00:00:00-05:00  69.281768  70.536927  69.252580  70.519897   93121200\n2019-12-27 00:00:00-05:00  70.814237  71.507495  70.084495  70.493149  146266000\n2019-12-30 00:00:00-05:00  70.410455  71.196148  69.379088  70.911545  144114400\n2019-12-31 00:00:00-05:00  70.524783  71.436962  70.425051  71.429665  100805600\n</code></pre> Under the hood, we are mapping the parameters to  the <code>quantpylib.wrappers.yfinance.YFinance.get_trade_bars</code> method. You may use this as a standalone SDK, but the parameters are alot more rigid. With the master datapoller, we can provide any 2 of the 3 of <code>start</code>, <code>end</code>, and <code>periods</code>. But <code>yfinance</code> does not support too many endpoints, and is also  not stable, albeit free. Suppose we have an API key for  <code>eodhd</code>, we don't need to change much code: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\nprint(df)\n</code></pre> <pre><code>                open      high       low     close  adjusted_close     volume\ndatetime                                                                     \n2000-01-03  104.8768  112.5040  101.6848  111.9328          0.8461  535796800\n2000-01-04  108.2480  110.6224  101.1920  102.5024          0.7748  512377600\n2000-01-05  103.7456  110.5664  102.9952  104.0032          0.7862  778321600\n2000-01-06  106.1200  107.0048   94.9984   94.9984          0.7181  767972800\n2000-01-07   96.4992  101.0016   95.5024   99.5008          0.7521  460734400\n...              ...       ...       ...       ...             ...        ...\n2024-03-28  171.7500  172.2300  170.5100  171.4800        171.4800   65672700\n2024-04-01  171.1900  171.2500  169.4800  170.0300        170.0300   46240500\n2024-04-02  169.0800  169.3400  168.2300  168.8400        168.8400   49329500\n2024-04-03  168.7900  170.6800  168.5800  169.6500        169.6500   47602100\n2024-04-04  170.2900  171.9200  168.8200  168.8200        168.8200   53289969\n</code></pre> Actually we don't even need <code>src=\"eodhd\"</code>, the equities datapoller has that as its default, and the <code>@ts_poller</code> decorator is capable of guessing some parameters. This of course routs the request to <code>quantpylib.wrappers.eodhd.Eodhd.get_trade_bars</code>. Different from the <code>yfinance</code> wrapper's <code>get_trade_bars</code> endpoint, there is an additional parameter <code>exchange=\"US\"</code>, that is specific to the <code>eodhd</code> REST API. They have parameters to identify which asset with the same  ticker the client is referring to, but this nomenclature is unique to this particular vendor. This parameter is actually also  guessed by the <code>@ts_poller</code> decorator, but if we know precisely what we want, we should pass it in as arguments, as we may guess wrongly - here is an example of <code>AAPL</code> on the US and Mexican exchanges: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"US\"\n)\nprint(df)\ndf = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"MX\"\n)\nprint(df)\n</code></pre> giving <pre><code>                open      high       low     close  adjusted_close     volume\ndatetime                                                                     \n2000-01-03  104.8768  112.5040  101.6848  111.9328          0.8461  535796800\n2000-01-04  108.2480  110.6224  101.1920  102.5024          0.7748  512377600\n2000-01-05  103.7456  110.5664  102.9952  104.0032          0.7862  778321600\n2000-01-06  106.1200  107.0048   94.9984   94.9984          0.7181  767972800\n2000-01-07   96.4992  101.0016   95.5024   99.5008          0.7521  460734400\n...              ...       ...       ...       ...             ...        ...\n2024-03-28  171.7500  172.2300  170.5100  171.4800        171.4800   65672700\n2024-04-01  171.1900  171.2500  169.4800  170.0300        170.0300   46240500\n2024-04-02  169.0800  169.3400  168.2300  168.8400        168.8400   49329500\n2024-04-03  168.7900  170.6800  168.5800  169.6500        169.6500   47602100\n2024-04-04  170.2900  171.9200  168.8200  168.8200        168.8200   53289969\n\n[6102 rows x 6 columns]\n                 open       high        low      close  adjusted_close   volume\ndatetime                                                                       \n2004-12-20   704.4184   704.4184   694.5484   697.9980         11.0377   722401\n2004-12-21   702.4780   704.4996   702.4780   703.8080         11.1296  1804322\n2004-12-27   705.1688   705.1688   705.1688   705.1688         11.1511   140000\n2005-01-05   738.7380   738.7380   738.7380   738.7380         11.6819    14560\n2005-03-07   471.2496   471.2496   471.2496   471.2496         14.9041   266000\n...               ...        ...        ...        ...             ...      ...\n2024-03-27  2846.0000  2874.9900  2842.0000  2874.4299       2874.4299     1941\n2024-04-01  2873.0000  2873.0000  2819.3500  2827.2100       2827.2100    16860\n2024-04-02  2808.0000  2813.6900  2792.5000  2799.7800       2799.7800    23005\n2024-04-03  2798.0000  2829.9900  2798.0000  2810.0000       2810.0000     7258\n2024-04-04  2810.0000  2839.9900  2800.0000  2807.0300       2807.0300     3685\n</code></pre> The best is no-guessing, where you specify the source-specific parameters explicitly. For example, this would raise Exception: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\n</code></pre> but if you change the request using <code>crypto</code> poller <pre><code>df = await datapoller.crypto.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\nprint(df)\n</code></pre> we get <pre><code>                    open          high           low         close  adjusted_close       volume\ndatetime                                                                                       \n2010-07-17      0.049510      0.049510      0.049510      0.049510        0.049510            0\n2010-07-18      0.049510      0.049510      0.049510      0.049510        0.049510            0\n2010-07-19      0.085840      0.085840      0.085840      0.085840        0.085840            0\n2010-07-20      0.080800      0.080800      0.080800      0.080800        0.080800            0\n2010-07-21      0.074740      0.074740      0.074740      0.074740        0.074740            0\n...                  ...           ...           ...           ...             ...          ...\n2024-03-31  69647.779030  71377.779498  69624.868677  71333.647926    71333.647926  20050941373\n2024-04-01  71333.484717  71342.091454  68110.696020  69702.146113    69702.146113  34873527352\n2024-04-02  69705.024322  69708.381258  64586.594304  65446.974233    65446.974233  50705240709\n2024-04-03  65446.671764  66914.322564  64559.899948  65980.808650    65980.808650  34488018367\n2024-04-04  65975.696667  69291.254806  65113.796534  68508.841844    68508.841844  34439527442\n</code></pre> Although the <code>@ts_poller</code> adds a layer of complexity, it's purpose is to both be extremely flexible in the arguments the methods takes in, to generalize to arbitrary data-sources, while still providing the simplest possible unified-interface at the user-level by routing to the correct wrapper's endpoint. In fact, if we knew how they were routed, some 'wrong' calls actually work: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"CC\"\n)\n</code></pre> this works because even though we are using the <code>equities</code> datapoller, we specified the <code>CC</code> exchange which maps to the  crypto asset class in the <code>eodhd</code> vendor. Of course, we do not  recommend such workarounds. Note that additional arguments to otherwise valid requests are simply ignored - this request is valid: <pre><code>df = await datapoller.crypto.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    gibberish=\"gibberish\"\n)\n</code></pre> Let's make a request to a <code>@poller</code> method, such as  the <code>quantpylib.datapoller.equities.get_ticker_fundamentals</code>. The <code>@poller</code> only asks for the <code>src</code> parameter,  while <code>get_ticker_fundamentals</code> asks for a <code>ticker</code> parameter, so we can do <pre><code>df=datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\",src=\"eodhd\")\n</code></pre> that routs to the <code>eodhd</code> wrapper. Everything else is the same.</p>"},{"location":"datapoller/datapoller/#safe-throttling","title":"Safe-Throttling","text":"<p>As far as possible, when the specified endpoint specifies rate-limits, rapid submission of requests are sent-through  to the data-vendor as quickly as possible, while respecting the rate-limits. This is done by using our custom semaphore-like logic, defined in the <code>quantpylib.throttler.rate_semaphore</code>. This is specific to each data-vendor, and each instance of the wrapper around  our data-source has its own resource-pool. This design is to maximise throughput of user-requests, and is supported in both asynchronous and synchronous methods. All requests submitted to a specific datasource with  throttle-support will be paced, with support for multi-threading or coroutines. For instance, suppose we do <pre><code>import threading\nimport requests\ntry:\n    def raw():\n        response=requests.get(f\"https://eodhd.com/api/fundamentals/AAPL.US?api_token={os.getenv('EOD_KEY')}&amp;fmt=json\")\n        if response.status_code == 429: raise Exception(\"TooManyTooFast\")\n        else: print(response.status_code)\n    req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n    threads=[threading.Thread(target=raw,args=()) for i in range(500)]\n    # req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n    # threads=[threading.Thread(target=req,args=()) for i in range(500)]\n    for thread in threads: thread.start()\n    for thread in threads: thread.join()\nexcept Exception as err:\n    print(err)\n</code></pre> The raw, multi-threaded request will eventually get rejected by the server with a <code>429 TooManyRequests</code> code, while if we try: <pre><code># req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n# threads=[threading.Thread(target=raw,args=()) for i in range(500)]\nreq=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\nthreads=[threading.Thread(target=req,args=()) for i in range(500)]\n</code></pre> the application will gracefully pace the execution of multiple threads and  not crash.</p>"},{"location":"datapoller/datapoller/#examples","title":"Examples","text":"<p>A number of examples are given. This would be the setup: <pre><code>import os\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\nfrom quantpylib.datapoller.master import DataPoller\n\nconfig_keys = {\n    \"yfinance\": {\"alias\":\"yfinance\"},\n    \"eodhd\": {\"eod_key\":os.getenv(\"EOD_KEY\")},\n    \"binance\": {},\n    \"oanda\": {\n        \"alias\":\"oanda\",\n        \"account_id\":os.getenv(\"OANDA_ACC\"),\n        \"secret\": os.getenv(\"OANDA_KEY\"),\n        \"env\":\"practice\",\n    },\n    \"hyperliquid\": {\"alias\":\"hyp\",\"key\":os.getenv(\"HYP_PUBLIC\"),\"secret\":os.getenv(\"HYP_KEY\")},\n}\n\nasync def main():\n    start,end=datetime(2023,9,30),datetime.now()\n    datapoller = DataPoller(config_keys=config_keys)\n    print(datapoller.src_pollers)\n\n    await datapoller.init_clients()\n\n    #...code goes between here...\n\n    await datapoller.cleanup_clients()\n    print(\"cleanup\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-ohlcv","title":"Get OHLCV","text":"<p>Let's get OHLCV for crypto, currencies and equities. We get <code>AAPL</code>, <code>EUR_USD</code>, <code>BTCUSDT</code> OHLCV data from  the <code>equities</code>, <code>currencies</code> and <code>crypto</code> datapoller  using source <code>eodhd</code>, <code>oanda</code> and <code>binance</code> respectively. The same contract may trade under different tickers, as we see in <code>hyperliquid</code> -  we need to match to the correct symbol. <pre><code>df1=await datapoller.equities.get_trade_bars(ticker=\"AAPL\",periods=500,end=end,granularity=\"d\",src=\"eodhd\")\ndf2=await datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"h\",src=\"oanda\")\ndf3=await datapoller.crypto.get_trade_bars(ticker=\"BTCUSDT\",start=start,end=end,granularity=\"d\",src=\"binance\")\ndf4=await datapoller.crypto.get_trade_bars(ticker=\"BTC\",start=start,end=end,granularity=\"d\",src=\"hyp\")\nprint(df1,df2,df3,df4)\n</code></pre> We can go for other data-granularities and multipliers: <pre><code>df=await datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"h\",granularity_multiplier=4,src=\"oanda\")\nprint(df)\n</code></pre> and we get 4-hour candles: <pre><code>                              open     high      low    close  volume\ndatetime                                                             \n2020-01-01 22:00:00+00:00  1.12124  1.12246  1.12124  1.12209     673\n2020-01-02 02:00:00+00:00  1.12206  1.12247  1.12010  1.12044     700\n2020-01-02 06:00:00+00:00  1.12044  1.12140  1.12013  1.12032    2392\n2020-01-02 10:00:00+00:00  1.12034  1.12039  1.11830  1.11966    2610\n2020-01-02 14:00:00+00:00  1.11962  1.12030  1.11636  1.11700    4887\n...                            ...      ...      ...      ...     ...\n2024-04-04 17:00:00+00:00  1.08587  1.08620  1.08319  1.08374   13217\n2024-04-04 21:00:00+00:00  1.08401  1.08441  1.08350  1.08416    9891\n2024-04-05 01:00:00+00:00  1.08416  1.08431  1.08234  1.08264    7608\n2024-04-05 05:00:00+00:00  1.08263  1.08464  1.08226  1.08376    9345\n2024-04-05 09:00:00+00:00  1.08374  `1.08422  1.08350  1.08393    1436\n</code></pre> The datapoller routs to the <code>oanda</code> wrapper, and because Oanda places a limit of candles per request, given your polling-period and granularity desired, there may be multiple requests to  the Oanda REST API server to stitch together the non-overlapping periods. This is the advantage of our <code>datapoller</code> and <code>wrapper</code> interface - the user does not have to concern themselves with the source-specific limitations.</p>"},{"location":"datapoller/datapoller/#get-tick-historical","title":"Get Tick Historical","text":"<p>Some endpoints support historical data. <code>eodhd</code> has support for  tick data on the US-listed common-stocks. <pre><code>ticks=datapoller.equities.get_trade_ticks(ticker=\"META\",start=datetime(2023,4,3,0,0,0), end=datetime(2023,4,3,12,0,0))\nprint(ticks)\n</code></pre> We get: <pre><code>     ex mkt   price      seq  shares    sl sub_mkt             ts\n0     Q   K  211.00    77001       5  @ TI          1680508800013\n1     Q   K  211.42    77002       1  @ TI          1680508800013\n2     Q   K  210.99    77124      10  @ TI          1680508800017\n3     Q   K  211.42    77125       7  @ TI          1680508800017\n4     Q   K  211.42    77127      30  @ TI          1680508800017\n...  ..  ..     ...      ...     ...   ...     ...            ...\n2071  Q   Q  210.00  3635409      59  @FTI          1680523180411\n2072  Q   Q  210.00  3635410      41  @FTI          1680523180411\n2073  Q   K  210.00  3636017     800  @FT           1680523181713\n2074  Q   Q  210.00  3636650      20  @FTI          1680523184200\n2075  Q   K  210.00  3637810      27  @FTI          1680523185877\n\n[2076 rows x 8 columns]\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-fundamentals","title":"Get Fundamentals","text":"<p>Some assets and datasources support fundamental data. We could  get fundamental data for Goldman Sachs and Ethereum like this: <pre><code>f1=datapoller.equities.get_ticker_fundamentals(ticker=\"GS\",src=\"eodhd\")\nf2=datapoller.crypto.get_ticker_fundamentals(ticker=\"ETH-USD\",src=\"eodhd\")\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-exchange-universe","title":"Get Exchange Universe","text":"<p>We might also be interested in getting the listed set of tickers for  a data vendor or exchange. In the case of <code>eodhd</code>, a data vendor,  they support multiple exchanges. We can type in the search-bar (top right)  for the endpoint <code>get_tickers_in_exchange</code>, and we see <code>binance</code>, <code>eodhd</code> and <code>oanda</code> support this endpoint through the <code>exchange</code> datapoller. We can see that the <code>eodhd</code> endpoint takes in an <code>exchange</code> parameter, so we can ask for their US-listed stocks as follows: <pre><code>tickers = datapoller.exchange.get_tickers_in_exchange(exchange=\"US\",src=\"eodhd\")\n</code></pre> On the other hand Binance is already an exchange, so looking at their endpoint, we see that no additional argument is required, so we can do the route by (same for <code>oanda</code>)  <pre><code>tickers = datapoller.exchange.get_tickers_in_exchange(src=\"binance\")\ntickers = datapoller.exchange.get_tickers_in_exchange(src=\"oanda\")\n</code></pre> Note that the return type from these endpoints are mostly not-standardized, and no have fixed schema, except for the <code>get_trade_bars</code> and common methods. This is a point for improvement that we are hoping contributors can come in, as we need the manpower!</p>"},{"location":"datapoller/datapoller/#queries","title":"Queries","text":"<p>Some data vendors provide a functionality to input some string or alternatively formatted specification into their search engine. This is provided in the <code>quantpylib.datapoller.metadata.query_engine</code> method: <pre><code>query = datapoller.metadata.query_engine(query=\"AAPL\")\nprint(query)\n</code></pre> gives us <pre><code>      Code Exchange                                               Name          Type  ... Currency          ISIN previousClose  previousCloseDate\n0     AAPL       US                                          Apple Inc  Common Stock  ...      USD  US0378331005      168.8200         2024-04-04\n1     AAPL       BA                                      Apple Inc DRC  Common Stock  ...      ARS  US0378331005     8925.5000         2024-04-04\n2     AAPL       MX                                          Apple Inc  Common Stock  ...      MXN  US0378331005     2807.0300         2024-04-04\n3     AAPL      NEO                                      Apple Inc CDR  Common Stock  ...      CAD  CA03785Y1007       25.0400         2024-04-04\n4     AAPL       SN                                          Apple Inc  Common Stock  ...      USD  US0378331005      170.5200         2024-04-04\n5   AAPL34       SA                                          Apple Inc  Common Stock  ...      BRL  BRAAPLBDR004       42.8200         2024-04-04\n6     AAPU       US  Direxion Shares ETF Trust - Direxion Daily AAP...           ETF  ...      USD  US25461A8743       21.9100         2024-04-04\n7     AAPD       US  Direxion Shares ETF Trust - Direxion Daily AAP...           ETF  ...      USD  US25461A3041       23.0400         2024-04-04\n8     APLY       US           YieldMax AAPL Option Income Strategy ETF           ETF  ...      USD  US88634T8577       16.5600         2024-04-04\n9     3SAP       PA                                   Granite -3x AAPL           ETF  ...      EUR  XS2193970030       26.9500         2024-04-04\n10    APLY      NEO              APPLE (AAPL) Yield Shares Purpose ETF           ETF  ...      CAD          None       22.7000         2024-04-04\n11    3LAP       PA                                   Granite +3x AAPL           ETF  ...      EUR  XS2193969883       18.4260         2024-04-04\n12    SALE      LSE  Leverage Shares 3x Short Apple (AAPL) ETP Secu...           ETF  ...      EUR  XS2472334742        2.9949         2024-04-04\n13    3SAA    XETRA               Leverage Shares -3x Short Apple AAPL           ETF  ...      EUR  XS2472334742        2.9892         2024-04-04\n14    AAPY       US       Kurv Yield Premium Strategy Apple (AAPL) ETF           ETF  ...      USD          None       23.3839         2024-04-04\n</code></pre></p>"},{"location":"datapoller/datapoller/#streaming-data","title":"Streaming Data","text":"<p>Datapoller allows for market data streaming using socket connections when made available by the endpoints of the data source. We can see that both <code>eodhd</code> and <code>oanda</code> support  subscription to L1-Book/BBO data, as does the <code>equities</code>,<code>currencies</code> data class. We can make request: <pre><code>async def handler(msg):\n    print(msg)\n\nawait datapoller.currencies.l1_book_subscribe(ticker=\"EURUSD\",handler=handler,src=\"eodhd\")\nawait datapoller.currencies.l1_book_subscribe(ticker=\"EUR_USD\",handler=handler,src=\"oanda\")\nawait datapoller.equities.l1_book_subscribe(ticker=\"AAPL\",handler=handler,src=\"eodhd\")\n</code></pre> Some data sources such as <code>binance</code> and <code>hyperliquid</code> allow for L2-Book data subscriptions. We let it stream for 20 seconds. <pre><code>await datapoller.crypto.l2_book_subscribe(ticker=\"BTCUSDT\",handler=handler,src=\"binance\")\nawait datapoller.crypto.l2_book_subscribe(ticker=\"BTC\",handler=handler,src=\"hyp\")\nawait asyncio.sleep(20)\n</code></pre> As the messages come through the subscription channels, our handler prints them out to console: <pre><code>...\n{'ts': 1716111203621, 'b': [[67035.0, 2.44344], [67034.0, 0.1216], ...], 'a': [[67036.0, 0.00303], ...]}\n...\n</code></pre> Of course, you can stream the same assets from different data sources, different assets from the same data source, and so on simultaneously...</p> <p>Once we are done, we can close the streams: <pre><code>await asyncio.gather(\n    *[\n        datapoller.currencies.l1_book_unsubscribe(ticker=\"EURUSD\",src=\"eodhd\"),\n        datapoller.currencies.l1_book_unsubscribe(ticker=\"EUR_USD\",src=\"oanda\"),\n        datapoller.equities.l1_book_unsubscribe(ticker=\"AAPL\",src=\"eodhd\"),\n        datapoller.crypto.l2_book_unsubscribe(ticker=\"BTCUSDT\",src=\"binance\")\n    ]\n)\nprint(\"closed all but one stream\")\n</code></pre></p>"},{"location":"datapoller/equities/","title":"quantpylib.datapoller.equities","text":""},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities","title":"<code>Equities</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_dividends","title":"<code>get_ticker_dividends(ticker, **kwargs)</code>","text":"<p>Retrieve ticker dividends. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_earnings_history","title":"<code>get_ticker_earnings_history(ticker, **kwargs)</code>","text":"<p>Retrieve ticker earnings history. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_earnings_trend","title":"<code>get_ticker_earnings_trend(ticker, **kwargs)</code>","text":"<p>Retrieve ticker earnings trend. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_financials","title":"<code>get_ticker_financials(ticker, **kwargs)</code>","text":"<p>Retrieve ticker financials. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, **kwargs)</code>","text":"<p>Retrieve ticker fundamentals. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f1=datapoller.equities.get_ticker_fundamentals(ticker=\"GS\",src=\"eodhd\")\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_historical_mcap","title":"<code>get_ticker_historical_mcap(ticker, **kwargs)</code>","text":"<p>Retrieve ticker historical market cap. @ts_poller(assert_span=False, automap_span=False)</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_insider_txn","title":"<code>get_ticker_insider_txn(ticker, **kwargs)</code>","text":"<p>Retrieve ticker insider transactions. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve ticker metadata. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_shares_stats","title":"<code>get_ticker_shares_stats(ticker, **kwargs)</code>","text":"<p>Retrieve ticker shares statistics. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_splits","title":"<code>get_ticker_splits(ticker, **kwargs)</code>","text":"<p>Retrieve ticker splits. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_stat_snapshot","title":"<code>get_ticker_stat_snapshot(ticker, **kwargs)</code>","text":"<p>Retrieve ticker statistical snapshot. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLC(V) trade bars data. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = datapoller.equities.get_trade_bars(ticker=\"AAPL\",start=datetime(2020,1,1),periods=365,src=\"yfinance\")\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_trade_ticks","title":"<code>get_trade_ticks(start, end, **kwargs)</code>","text":"<p>Retrieve ticker ticks data. @ts_poller(automap_span=False)</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start datetime.</p> required <code>end</code> <code>datetime</code> <p>End datetime.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ticks=datapoller.equities.get_trade_ticks(ticker=\"META\",start=datetime(2023,4,3,0,0,0), end=datetime(2023,4,3,12,0,0))\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 order book data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 order book data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/exchange/","title":"quantpylib.datapoller.exchange","text":""},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange","title":"<code>Exchange</code>","text":"<p>               Bases: <code>BasePoller</code></p> <p>A class for interacting with exchange-related data sources.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.check_exchange_open","title":"<code>check_exchange_open(**kwargs)</code>","text":"<p>Check if the exchange is open for trading. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The exchange trading status from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_delisted_tickers_in_exchange","title":"<code>get_delisted_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the collection of delisted tickers in a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of delisted tickers in the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_holidays","title":"<code>get_exchange_holidays(**kwargs)</code>","text":"<p>Retrieve the exchange holidays for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The exchange holidays for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_hours","title":"<code>get_exchange_hours(**kwargs)</code>","text":"<p>Retrieve the trading hours for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The trading hours for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_server_timestamp","title":"<code>get_exchange_server_timestamp(**kwargs)</code>","text":"<p>Retrieve the server timestamp for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The server timestamp for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_tz","title":"<code>get_exchange_tz(**kwargs)</code>","text":"<p>Retrieve the time zone for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The time zone for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_supported_exchanges","title":"<code>get_supported_exchanges(**kwargs)</code>","text":"<p>Retrieve the collection of supported exchanges. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of supported exchanges from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the collection of tickers in a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of tickers in the specified exchange from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tickers = datapoller.exchange.get_tickers_in_exchange(exchange=\"US\",src=\"eodhd\")\n&gt;&gt;&gt; tickers = datapoller.exchange.get_tickers_in_exchange(src=\"binance\")\n</code></pre>"},{"location":"datapoller/master/","title":"quantpylib.datapoller.master","text":""},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller","title":"<code>DataPoller</code>","text":""},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.__init__","title":"<code>__init__(config_keys={'yfinance': {'alias': 'yfinance'}, 'eodhd': {'alias': 'eodhd', 'eod_key': os.getenv('EOD_KEY')}, 'binance': {'alias': 'binance', 'key': None, 'secret': None}, 'hyperliquid': {'alias': 'hyperliquid', 'key': None, 'secret': None}, 'bybit': {'key': None, 'secret': None}, 'oanda': {'alias': 'oanda', 'account_id': os.getenv('OANDA_ACC'), 'secret': os.getenv('OANDA_KEY'), 'env': 'practice'}})</code>","text":"<p>Initialize the DataPoller class with the provided configuration keys. The configuration keys are passed in as dictionaries with the appropriate key-value pair. An example of the valid key-value format is shown as default arguments. You can create a <code>.env</code>file and place your keys there, or set it as environment variables. All the datapollers are available through this master poller,  by accessing the attribute values <code>datapoller.equities</code>, <code>datapoller.crypto</code> and so on.</p> <p>Parameters:</p> Name Type Description Default <code>config_keys</code> <code>dict</code> <p>A dictionary containing configuration keys for different data sources.  The key-pair dictionary is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code> where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the  <code>src</code> parameter to the datapoller methods. API keys are required for private endpoints only. For instance, we pass in <code>{ \"binance\": { \"api_key\" : MY_KEY , \"api_secret\" : SECRET } }</code> matching to the constructor in <code>quantpylib.wrappers.Binance</code> that looks like :</p> <code>{'yfinance': {'alias': 'yfinance'}, 'eodhd': {'alias': 'eodhd', 'eod_key': getenv('EOD_KEY')}, 'binance': {'alias': 'binance', 'key': None, 'secret': None}, 'hyperliquid': {'alias': 'hyperliquid', 'key': None, 'secret': None}, 'bybit': {'key': None, 'secret': None}, 'oanda': {'alias': 'oanda', 'account_id': getenv('OANDA_ACC'), 'secret': getenv('OANDA_KEY'), 'env': 'practice'}}</code> <p>Attributes:</p> Name Type Description <code>equities</code> <code>Equities</code> <p>An instance of Equities that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>metadata</code> <code>Metadata</code> <p>An instance of Metadata that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>crypto</code> <code>Crypto</code> <p>An instance of Crypto that uses the specified data pollers and defaults to 'binance' as the source.</p> <code>currencies</code> <code>Currencies</code> <p>An instance of Currencies that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>exchange</code> <code>Exchange</code> <p>An instance of Exchange that uses the specified data pollers and defaults to 'eodhd' as the source.</p>"},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.__init__--def-initselfapi_keynoneapi_secretnonekwargs","title":"def init(self,api_key=None,api_secret=None,**kwargs):","text":""},{"location":"datapoller/metadata/","title":"quantpylib.datapoller.metadata","text":""},{"location":"datapoller/metadata/#quantpylib.datapoller.metadata.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/metadata/#quantpylib.datapoller.metadata.Metadata.query_engine","title":"<code>query_engine(query, **kwargs)</code>","text":"<p>Execute a query using a specific data poller.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to be executed.</p> required <code>**kwargs</code> <p>Additional keyword arguments for executing the query.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the query execution using the specified data poller.</p>"},{"location":"datapoller/utils/","title":"quantpylib.datapoller.utils","text":""},{"location":"datapoller/utils/#quantpylib.datapoller.utils.poller","title":"<code>poller(_func=None, *, tag=None)</code>","text":"<p>Decorator for instance level methods of <code>quantpylib.datapoller.base.BasePoller</code> objects.  Let the object be given the variable name <code>poller_obj</code>, then decorated instance level methods  have augmented default arguments <code>**kwargs</code> with following key-pairs:</p> <p>Specs:</p> <pre><code>src (string): Data source we want to poll for. Defaults to `poller_obj.default_src`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>The decorated instance level method.</p>"},{"location":"datapoller/utils/#quantpylib.datapoller.utils.ts_poller","title":"<code>ts_poller(_func=None, *, tag=None, assert_span=True, automap_span=True)</code>","text":"<p>Decorator for instance level methods of <code>quantpylib.datapoller.base.BasePoller</code> objects.  Let the object be given the variable name <code>poller_obj</code>, then decorated instance level methods  have augmented default arguments <code>**kwargs</code> with following key-pairs:</p> <p>Specs:</p> <pre><code>ticker (str): The identifier for the time-series of interest. Defaults to None.\nstart (datetime.datetime): The start time of the time-series being polled. Defaults to None.\nend (datetime.datetime): The end time of the time-series being polled. Defaults to None.\nperiods (int): Number of periods of granularity_multiplier * granularity of time-series being polled. Defaults to None. \ngranularity (str): Granularity of data being polled. Valid values are ['s','m','h','d','w','M','y']. Defaults to 'd'.\ngranularity_multiplier (int): Multiplier for the granularity. For instance, 4 for multiplier and 'h' for granularity implies '4h' candles/periods. Defaults to 1.\nsrc (string): Data source we want to poll for. Defaults to `poller_obj.default_src`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>method</code> <p>The decorated instance level method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <code>assert_span</code> <code>bool</code> <p>Whether to assert the validity of time span arguments. If <code>True</code>, exactly two of <code>start</code>, <code>end</code>, and <code>periods</code> must be specified. Defaults to <code>True</code>.</p> <code>True</code> <code>automap_span</code> <code>bool</code> <p>Whether to automatically map (<code>start</code>,<code>end</code>,<code>periods</code>,<code>granularity</code>,<code>granularity_multiplier</code>) into time span arguments. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <p>The decorated instance level method.</p>"},{"location":"gateway/account/","title":"quantpylib.gateway.account","text":""},{"location":"gateway/account/#quantpylib.gateway.account.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_balance","title":"<code>account_balance(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_fill_subscribe","title":"<code>account_fill_subscribe(exc, handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/base/","title":"quantpylib.gateway.base","text":""},{"location":"gateway/base/#quantpylib.gateway.base.BaseGateway","title":"<code>BaseGateway</code>","text":"<p>A base class for creating exchange clients to interact with various markets.</p> <p>Attributes:</p> Name Type Description <code>clients</code> <code>dict</code> <p>A dictionary of exchange clients for different exchanges/brokerages.</p>"},{"location":"gateway/base/#quantpylib.gateway.base.BaseGateway.__init__","title":"<code>__init__(clients)</code>","text":"<p>Initialize the BaseGateway with exhange clients.</p> <p>Parameters:</p> Name Type Description Default <code>clients</code> <code>dict</code> <p>A dictionary of exchange clients for different exchanges/brokerages.</p> required"},{"location":"gateway/exchange/","title":"quantpylib.gateway.exchange","text":""},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange","title":"<code>Exchange</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.contract_specifications","title":"<code>contract_specifications(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing contract specifications such as price precision,</p> <p>quantity precision and minimum notional order value.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_exchange_server_timestamp","title":"<code>get_exchange_server_timestamp(exc, **kwargs)</code>","text":"<p>Retrieve the server timestamp from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The server timestamp from the exchange.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_exchange_tz","title":"<code>get_exchange_tz(exc, **kwargs)</code>","text":"<p>Get the timezone for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Timezone of the exchange.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_perps_data","title":"<code>get_perps_data(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve perpetuals data.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing symbol to perp data with the following perp data structure:</p> <ul> <li>\"baseAsset\" <code>str</code> :             The base asset symbol.</li> <li>\"fr\" <code>float</code> :                  Funding rate.</li> <li>\"frint\" <code>float</code>,                Floating point representation of the funding rate.</li> <li>\"marginAsset\" <code>str</code>,            The margin asset symbol.</li> <li>\"markPrice\" <code>float</code>,            The mark price.</li> <li>\"minQty\" <code>Decimal</code>,             The minimum quantity.</li> <li>\"min_notional\" <code>float</code>,         The minimum notional value.</li> <li>\"next_funding\" <code>int</code>,           Unix timestamp of the next funding, milliseconds.</li> <li>\"pricePrecision\" <code>Decimal</code>,     The price precision.</li> <li>\"quantityPrecision\" <code>Decimal</code>,  The quantity precision.</li> <li>\"quoteAsset\" <code>str</code>,             The quote asset symbol.</li> <li>\"stepSize\" <code>Decimal</code>,           The step size.</li> <li>\"symbol\" <code>str</code>,                 The symbol.</li> <li>\"timestamp\" <code>int</code>,              Unix timestamp of the data retrieval, milliseconds.</li> <li>\"exchange\" <code>str</code>                The exchange code , \"hyp\"</li> </ul>"},{"location":"gateway/executor/","title":"quantpylib.gateway.executor","text":""},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor","title":"<code>Executor</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.cancel_open_orders","title":"<code>cancel_open_orders(exc, **kwargs)</code>  <code>async</code>","text":"<p>Group cancel orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.cancel_order","title":"<code>cancel_order(exc, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.get_all_mids","title":"<code>get_all_mids(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_get","title":"<code>l2_book_get(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Request data for L2 Order Book snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_mirror","title":"<code>l2_book_mirror(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Keep a local mirror copy of the L2 Order Book using orderbook updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_peek","title":"<code>l2_book_peek(ticker, exc, **kwargs)</code>","text":"<p>Retrieve the local mirror copy of the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The local mirror copy of the L2 Order Book.</p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book update/increment/snapshot streams.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_subscriptions","title":"<code>l2_book_subscriptions(exc, **kwargs)</code>","text":"<p>Get the current subscriptions to the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The current L2 Order Book subscriptions.</p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book update/increment/snapshot streams.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.limit_order","title":"<code>limit_order(ticker, amount, exc, **kwargs)</code>  <code>async</code>","text":"<p>Submit limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.market_order","title":"<code>market_order(ticker, amount, exc, **kwargs)</code>  <code>async</code>","text":"<p>Submit market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.rand_cloid","title":"<code>rand_cloid(exc, **kwargs)</code>","text":"<p>Generate a random client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/gateway/","title":"quantpylib.gateway","text":"<p><code>quantpylib.gateway</code> is a quant module used for multi-exchange integration and account management.</p> <p>The clients are categorized into their gateway classes, with current support for:</p> <pre><code>- account\n- exchange\n- executor\n- orders\n- positions\n</code></pre> <p>The exchange clients supported are:</p> <pre><code>- binance\n- bybit\n- hyperliquid\n</code></pre> <p>In general, a trader may have requirements for multi-exchange account management and broker integrations. Each exchange has its own authentication flow, order schema and account management - the gateway abstracts these concerns to provide a seamless, common interface for exchange integration.</p> <p>Each gateway is derived from the base <code>quantpylib.gateway.base.BaseGateway</code> class and implements a set of methods, and routs the requests to the specified exchange client and endpoints through the argument <code>\"exc\"</code>.  The supported exchange clients are written as wrappers on the <code>quantpylib.wrappers</code> module,  and their supported endpoints share the same function name as in the gateways. The different gateways are accessible via the master gateway class, given in <code>quantpylib.gateway.master.Gateway</code> object instance. For instance, if we would like to get position data using the <code>quantpylib.gateway.positions.Positions.positions_get</code>, we can do so by creating a <code>obj = Gateway(...)</code> instance, and calling <code>obj.positions.positions_get(...,exc=\"binance\")</code>. The function call is only valid if it is supported by both the gateway type and the exchange client, which we can check by their matching  function signatures. In general each exchange has its own parameters to the vendor-specific endpoint, as well as different specifications (such as limit orders through a specified price or a price-matching rule), so the library provides a flexible variation between these specifications to support the different configurations for each external API - it would be  alot easier to understand through the given examples.</p> <p>Note that each of the exchange client wrappers are also designed to be available for use as standalone Python-SDKs. Supported gateways and exchanges are added and updated frequently.</p> <p>Note that the various endpoints and their matching  function name-signatures can be easily looked up in the search-bar (top right): </p>"},{"location":"gateway/gateway/#examples","title":"Examples","text":"<p>A dictionary containing configuration keys for different exchanges we  want access to is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code>, where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the <code>exc</code> parameter in the gateway methods.</p> <p>We already have the keys in our <code>.env</code> file in the current working directory, and we will make the following imports: <pre><code>import os \nimport logging\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\n\nimport quantpylib.standards.markets as markets\nfrom quantpylib.gateway.master import Gateway\n\nconfig_keys={\n    \"binance\": {\n        \"alias\": \"binance\",\n        \"key\": os.getenv(\"BIN_PUBLIC\"),\n        \"secret\" : os.getenv(\"BIN_KEY\"),\n    },\n    \"hyperliquid\": {\n        \"alias\" : \"hyperliquid\",\n        \"key\" : os.getenv(\"HYP_DEMO\"),\n        \"secret\" : os.getenv(\"HYP_KEY\"),\n    }\n}\n\nasync def main():\n    gateway = Gateway(config_keys=config_keys)\n    print(gateway.exc_clients)\n    await gateway.init_clients()\n\n    #...code goes between here...\n\n    await gateway.cleanup_clients()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"gateway/gateway/#account","title":"Account","text":"<p>We are interested in getting some account balances. We can simply do <pre><code>res = await gateway.account.account_balance(exc='binance')\nres = await gateway.account.account_balance(exc='hyperliquid')\nprint(res) \n</code></pre> We get some details about equity and margin information: <pre><code>{'equity_total': 1884.960586, 'margin_maintenance': 131.131965, 'margin_total': 262.26393, 'equity_withdrawable': 1622.696656, 'notional_position': 5232.9393}\n</code></pre></p> <p>We want to subscribe to updates to changes in the account's positions. This happens whenever there is an order filled. I subscribe to fill events, pass it a print-handler and let it sleep. Before the sleep times out, I made a market order on the web platform. <pre><code>async def handler(msg):\n    print(msg)\n\nawait gateway.account.account_fill_subscribe(exc='hyperliquid',handler=handler)\nawait asyncio.sleep(10)\n'''\nI just put in a market order... and on my console:\n{'channel': 'userFills', \n'data': {'user': 'demodemodemodemodemodemodemodemodemodemodemodemo', \n            'fills': [{'coin': 'PENDLE', 'px': '4.1099', 'sz': '3.0', 'side': 'A', ...}}\n'''\nawait gateway.account.account_fill_unsubscribe(exc='hyperliquid')\n</code></pre></p>"},{"location":"gateway/gateway/#exchanges","title":"Exchanges","text":"<p>We may want to get contract specifications for valid orders: <pre><code>res = await gateway.exchange.contract_specifications(exc='hyperliquid')\nres = await gateway.exchange.contract_specifications(exc='binance')\nprint(res)\n</code></pre> <pre><code>{'BTCUSDT': {'price_precision': 2, 'quote_precision': 8, 'quantity_precision': 3, 'min_notional': 100.0}}, \n'ETHUSDT': {'price_precision': 2, 'quote_pr...}\n</code></pre></p>"},{"location":"gateway/gateway/#executor","title":"Executor","text":"<p>We want to make some limit orders: <pre><code>res = await gateway.executor.limit_order(ticker='PENDLE',amount=-3,price=5.001,exc='hyperliquid')\nres = await gateway.executor.limit_order(ticker='PENDLEUSDT',amount=-3,price=5.001,exc='binance')\n</code></pre> <code>Binance</code> exchange allows limit order that does not need to specify price - instead, the price is set relative to the order book state through a price-matching rule. This is specified in the <code>price_match</code> argument to the <code>quantpylib.wrappers.Binance.limit_order</code>: <pre><code>res = await gateway.executor.limit_order(ticker='PENDLEUSDT',amount=-3,price_match=markets.PRICE_MATCH_QUEUE_20,exc='binance')\n</code></pre> Here, our order sits as a maker order at price 20-levels deep. Of course, there are market orders too: <pre><code>res = await gateway.executor.market_order(ticker='PENDLE',amount=-3,exc='hyperliquid')\nprint(res)\n</code></pre> <pre><code>{'status': 'ok', 'response': {'type': 'order', 'data': {'statuses': [{'filled': {'totalSz': '3.0', 'avgPx': '4.8122', 'oid': 1234}}]}}}\n</code></pre></p> <p>It is often useful to have order book data during the execution stage. We can get an order book snapshot: <pre><code>res = await gateway.executor.l2_book_get(ticker='AAVE',exc=\"hyperliquid\")\nprint(res)\nres = await gateway.executor.l2_book_get(ticker='AAVE',exc='hyperliquid',depth=2,nsigfig=5)\nprint(res)\nres = await gateway.executor.l2_book_get(ticker='AAVEUSDT',exc=\"binance\")\nprint(res)\n</code></pre> <pre><code>{'ts': 1716119324540, 'b': array([[8.7165e+01, 6.7900e+00],...])'a':array([[8.7190e+01, 3.4490e+01],[8.7198e+01, 8.3140e+01],...])}\n{'ts': 1716119324940, 'b': (87.13, 48.1), 'a': (87.19, 34.49)}\n{'lastUpdateId': 4633878434615, 'E': 1716119327150, 'T': 1716119327141, 'bids': [['87.090', '25.7'], ['87.080', '29.9'], ['87.070', '76.1'], ['87.060', '111.7'], ['87.050', '87.9'], ['87.040', '80.8'], ['87.030', '34.1'], ['87.020', '179.0'], ['87.010', '130.4'], ['87.000', '190.9']], 'asks': [['87.100', '0.2'], ['87.110', '8.8'], ['87.120', '27.9'], ['87.130', '37.2'], ['87.140', '118.4'], ['87.150', '57.9'], ['87.160', '40.3'], ['87.170', '83.7'], ['87.180', '130.3'], ['87.190', '26.4']]}\n</code></pre> Instead of requesting a snapshot each time we need it, a socket subscription is probably more efficient if we need a constant stream of order book updates: <pre><code>await gateway.executor.l2_book_subscribe(ticker='BTC',handler=handler,exc='hyperliquid')\nawait gateway.executor.l2_book_subscribe(ticker='BTCUSDT',handler=handler,exc='binance',depth=5)\nawait asyncio.sleep(3)\n</code></pre> The handler will be invoked each time we receive an order book event or some interval. Our handler is just the print statement: <pre><code>{'ts': 1716119783147, 'b': [[67372.0, 0.68409], [67371.0, 0.56], [67370.0, 0.46385],...]...}\n</code></pre> Let's unsubscribe. <pre><code>print(gateway.executor.l2_book_subscriptions(exc='hyperliquid'))\nawait gateway.executor.l2_book_unsubscribe(ticker='BTC',exc='hyperliquid')\nprint(gateway.executor.l2_book_subscriptions(exc='hyperliquid'))\n</code></pre> Or maybe we just want mid-prices <pre><code>await gateway.executor.all_mids_subscribe(handler=handler,exc='hyperliquid')\nawait asyncio.sleep(5)\nawait gateway.executor.all_mids_unsubscribe(exc='hyperliquid')\nawait asyncio.sleep(5)\n</code></pre></p>"},{"location":"gateway/gateway/#orders","title":"Orders","text":"<p>We have order endpoints too. We can get order details using their ID: <pre><code>print(await gateway.orders.order_query(id=12345,exc='hyperliquid'))\nprint(await gateway.orders.order_query(id=1,ticker=\"PENDLEUSDT\",exc='binance'))\n</code></pre></p> <p>We want a snapshot of the orders page on the exchange: <pre><code>print(await gateway.orders.orders_get(exc='hyperliquid'))\nprint(await gateway.orders.orders_get(exc='binance'))\n</code></pre> We get <pre><code>{1234: {'ticker': 'PENDLE', 'order_id': '1234', 'limit_price': 5.001, 'amount_total': Decimal('-3.0'), 'amount_left': Decimal('-3.0'), 'timestamp': 000000}}\n{1234: {'ticker': 'PENDLEUSDT', 'order_id': '1234', 'limit_price': 5.001, 'amount_total': Decimal('-3'), 'amount_filled': Decimal('-0'), 'tif': 'GTC', 'timestamp': 000000}}\n</code></pre></p> <p>If we need to maintain a local copy of the orders page, it would be more suitable to use event subscriptions. The <code>orders_mirror</code> and <code>orders_peek</code> use the underlying socket endpoints available to keep an updated local copy of it. We need to mirror once, then subsequent calls to peek will fetch the local copy. Additionally, we may want to attach a callback handler, which is invoked whenever the local copy of the order book is modified: <pre><code>try:\n    await gateway.orders.orders_peek(exc='hyperliquid')\nexcept ValueError as e:\n    print(e)\n\nawait gateway.orders.orders_mirror(exc='hyperliquid') #OR\nawait gateway.orders.orders_mirror(on_update=handler,exc='hyperliquid')\nawait gateway.orders.orders_mirror(on_update=handler,exc='binance')\nprint(gateway.orders.orders_peek(exc='hyperliquid'))\nprint(gateway.orders.orders_peek(exc='binance'))\nawait asyncio.sleep(100)\n</code></pre> The handler receives the entire updated, local order page state when passed into the <code>orders_mirror</code> function, but we may prefer to receive just the realtime order event: <pre><code>await gateway.orders.order_updates_subscribe(handler=handler,exc='hyperliquid')\nawait asyncio.sleep(100)\nawait gateway.orders.order_updates_unsubscribe(exc='hyperliquid')\n</code></pre></p>"},{"location":"gateway/gateway/#positions","title":"Positions","text":"<p>We can get position details. As in the Orders gateway, we can request for a snapshot <pre><code>res = await gateway.positions.positions_get(exc='binance')\nres = await gateway.positions.positions_get(exc='hyperliquid')\nprint(res)\n</code></pre> <pre><code>{'SOL': {'ticker': 'SOL', 'amount': Decimal....'unrealized_pnl': 1315.35}}\n</code></pre> Or keep a local copy and peek: <pre><code>try:\n    await gateway.positions.positions_peek(exc='hyperliquid')\nexcept ValueError as e:\n    print(e)\nawait gateway.positions.positions_mirror(on_update=handler,exc='binance')\nawait gateway.positions.positions_mirror(on_update=handler,exc='hyperliquid')\nawait asyncio.sleep(100)\nprint(gateway.positions.positions_peek(exc='hyperliquid'))\n</code></pre></p>"},{"location":"gateway/master/","title":"quantpylib.gateway.master","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway","title":"<code>Gateway</code>","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.__init__","title":"<code>__init__(config_keys={'binance': {'alias': 'binance', 'key': None, 'secret': None}, 'hyperliquid': {'alias': 'hyperliquid', 'key': None, 'secret': None}, 'bybit': {'key': None, 'secret': None}})</code>","text":"<p>Initialize the Gateway class with the provided configuration keys. The configuration keys are passed in as dictionaries with the appropriate key-value pair. An example of the valid key-value format is shown as default arguments. You can create a <code>.env</code>file and place your keys there, or set it as environment variables. All the gateways are available through this master gateway,  by accessing the attribute values <code>gateway.account</code>, <code>gateway.executor</code> and so on.</p> <p>Parameters:</p> Name Type Description Default <code>config_keys</code> <code>dict</code> <p>A dictionary containing configuration keys for different exchange clients.  The key-pair dictionary is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code> where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the  <code>exc</code> parameter to the gateway methods. API keys are required for private endpoints only. For instance, we pass in <code>{ \"binance\": { \"api_key\" : MY_KEY , \"api_secret\" : SECRET } }</code> matching to the constructor in <code>quantpylib.wrappers.Binance</code> that looks like :</p> <code>{'binance': {'alias': 'binance', 'key': None, 'secret': None}, 'hyperliquid': {'alias': 'hyperliquid', 'key': None, 'secret': None}, 'bybit': {'key': None, 'secret': None}}</code> <p>Attributes:</p> Name Type Description <code>account</code> <code>Account</code> <p>An instance of Account for account related endpoints.</p> <code>exchange</code> <code>Exchange</code> <p>An instance of Exchange for exchange related endpoints.</p> <code>executor</code> <code>Executor</code> <p>An instance of Executor for execution related endpoints.</p> <code>orders</code> <code>Orders</code> <p>An instance of Orders for order related endpoints.</p> <code>positions</code> <code>Positions</code> <p>An instance of Positions for position related endpoints.</p> <code>trades</code> <code>Trades</code> <p>An instance of Trades for trades related endpoints.</p> <code>transactions</code> <code>Transactions</code> <p>An instance of Transactions for transaction related endpoints.</p>"},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.__init__--def-initselfapi_keynoneapi_secretnonekwargs","title":"def init(self,api_key=None,api_secret=None,**kwargs):","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.cleanup_clients","title":"<code>cleanup_clients()</code>  <code>async</code>","text":"<p>Cleanup all exchange clients that have a <code>cleanup</code> method.</p> <p>This method iterates through all the exchange clients and calls their <code>cleanup</code> method, if it exists. This is useful for performing any necessary cleanup actions, such as closing connections or releasing resources.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of results from the <code>cleanup</code> method calls.</p>"},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.init_clients","title":"<code>init_clients()</code>  <code>async</code>","text":"<p>Initialize all exchange clients that have an <code>init_client</code> method.</p> <p>This method iterates through all the exchange clients and calls their <code>init_client</code> method, if it exists. This is useful for setting up any necessary initializations before using the clients.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of results from the <code>init_client</code> method calls.</p>"},{"location":"gateway/orders/","title":"quantpylib.gateway.orders","text":""},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders","title":"<code>Orders</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_query","title":"<code>order_query(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(str, int)</code> <p>Order ID in exchange</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_get","title":"<code>orders_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_mirror","title":"<code>orders_mirror(exc, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_peek","title":"<code>orders_peek(exc, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/","title":"quantpylib.gateway.positions","text":""},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions","title":"<code>Positions</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_get","title":"<code>positions_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_mirror","title":"<code>positions_mirror(exc, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open positons.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_peek","title":"<code>positions_peek(exc, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/utils/","title":"quantpylib.gateway.utils","text":""},{"location":"gateway/utils/#quantpylib.gateway.utils.standardize_query","title":"<code>standardize_query(_func=None, *, tag=None)</code>","text":"<p>Decorator that standardizes key-value data types returned to their standard forms  as defined in <code>quantpylib.standards.markets</code>.</p>"},{"location":"hft/alpha/","title":"quantpylib.hft.alpha","text":""},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha","title":"<code>Alpha</code>","text":"<p>               Bases: <code>Simulator</code></p> <p>The <code>Alpha</code> class extends the <code>Simulator</code> class for implementing a backtest simulator for high-frequency trading (HFT) strategies.</p> <p>This class includes functionalities for handling order submissions, fills, and portfolio management. It allows for the simulation of a trading strategy's performance, including tracking inventory, cash, equity, and other portfolio metrics.</p> <p>Attributes:</p> Name Type Description <code>cash</code> <code>float</code> <p>The initial cash balance.</p> <code>maker_fees</code> <code>float</code> <p>The fee rate for maker orders.</p> <code>taker_fees</code> <code>float</code> <p>The fee rate for taker orders.</p> <code>maker_logs</code> <code>ndarray</code> <p>Array of logs for maker orders.</p> <code>taker_logs</code> <code>ndarray</code> <p>Array of logs for taker orders.</p> <code>maker_fills</code> <code>ndarray</code> <p>Array of filled maker orders.</p> <code>portfolio_df</code> <code>DataFrame</code> <p>DataFrame containing portfolio information including position, equity, and pnl.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.__init__","title":"<code>__init__(maker_fees=0.0, taker_fees=0.0, cash=10000, **kwargs)</code>","text":"<p>Initializes the Alpha class with trading fees and initial cash.</p> <p>Parameters:</p> Name Type Description Default <code>maker_fees</code> <code>float</code> <p>The fee rate for maker orders. Defaults to 0.0000. 0.0001 means 0.01%. Negative are rebates.</p> <code>0.0</code> <code>taker_fees</code> <code>float</code> <p>The fee rate for taker orders. Defaults to 0.0000. 0.0001 means 0.01%. Negative are rebates.</p> <code>0.0</code> <code>cash</code> <code>float</code> <p>The initial cash balance. Defaults to 10000.</p> <code>10000</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the Simulator class constructor.</p> <code>{}</code>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.cloid","title":"<code>cloid()</code>","text":"<p>Generate a unique client order ID (cloid), can be used to track orders.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A unique client order ID.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.df_actions","title":"<code>df_actions(plot=False, only_fills=True, ax=None)</code>","text":"<p>Generate and optionally plot a DataFrame of actions, including maker and taker fills and logs. In plots, buy/sell orders are green/red. Maker/taker orders are circle/squares. Filled orders shapes colored in, while unfilled orders are not colored in.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, plot the order logs. Defaults to False.</p> <code>False</code> <code>only_fills</code> <code>bool</code> <p>If True, only plots filled orders. Defaults to True.</p> <code>True</code> <code>ax</code> <code>Axes</code> <p>Axis to plot on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing maker fills, taker logs, and maker logs.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.df_markouts","title":"<code>df_markouts(plot=True)</code>","text":"<p>Calculate and optionally plot markouts for filled trades over different time intervals.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, plot the markout values. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the markout values for different time intervals.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.df_portfolio","title":"<code>df_portfolio(plot=False, plot_portfolio=True, plot_prices=False)</code>","text":"<p>Generate and optionally plot a DataFrame containing portfolio information, including position and pnl.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, plot the portfolio information. Defaults to False.</p> <code>False</code> <code>plot_portfolio</code> <code>bool</code> <p>If True, plot the portfolio position and pnl. Defaults to True.</p> <code>True</code> <code>plot_prices</code> <code>bool</code> <p>If True, overlay price data on the plot. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing portfolio information.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.event_orders_fill","title":"<code>event_orders_fill(cash, equity, position, ts, event_type, event_id, type_id, trade_buffer, ob_timestamps, ob_bids, ob_asks, ob_mids, features, running_event_ids, running_type_ids, orders, filled_orders, is_maker, **kwargs)</code>","text":"<p>Handle filled orders based on market events. Allowed to cancel orders in <code>orders</code> by returning  the subset of cloids in <code>orders</code>. Order creation and modification is not allowed on order fill.</p> <p>Parameters:</p> Name Type Description Default <code>cash</code> <code>float</code> <p>Current cash balance.</p> required <code>equity</code> <code>float</code> <p>Current equity value.</p> required <code>position</code> <code>int</code> <p>Current position size.</p> required <code>ts</code> <code>int</code> <p>Timestamp of the event.</p> required <code>event_type</code> <code>int</code> <p>Type of the event (e.g., EVENT_CLOCK, EVENT_LOB, EVENT_TRADE).</p> required <code>event_id</code> <code>int</code> <p>Index of the event among all events.</p> required <code>type_id</code> <code>int</code> <p>Index of the event among this event type.</p> required <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events. If <code>event_type == EVENT_TRADE</code>, the trade event at this event is <code>trade_buffer[type_id]</code>.</p> required <code>ob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps. If <code>event_type == EVENT_LOB</code>, the orderbook timestamp at this event is <code>ob_timestamp[type_id]</code>.</p> required <code>ob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook bids at this event is <code>ob_bids[type_id]</code>.</p> required <code>ob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook asks at this event is <code>ob_asks[type_id]</code>.</p> required <code>ob_mids</code> <code>ndarray</code> <p>Array of mid prices. If <code>event_type == EVENT_LOB</code>, the orderbook mid at this event is <code>ob_mids[type_id]</code>.</p> required <code>features</code> <code>dict</code> <p>Dictionary of computed features, with key as event_type. Feature scalar computed at this  timestamp can be referenced using <code>features[event_type][feature_name][type_id]</code>.</p> required <code>running_event_ids</code> <code>dict</code> <p>Dictionary of currently running event IDs with key-value <code>event_type : event_id</code>.</p> required <code>running_type_ids</code> <code>dict</code> <p>Dictionary of currently active type IDs with key-value <code>event_type : type_id</code>. For  instance, at this event, the last-known trade/trade-features can be obtained with <code>trade_buffer[running_type_ids[EVENT_TRADE]]</code> / <code>features[EVENT_TRADE][feature_name][running_type_ids[EVENT_TRADE]]</code>.</p> required <code>orders</code> <code>ndarray</code> <p>Array of current orders.</p> required <code>filled_orders</code> <code>ndarray</code> <p>Array of filled orders.</p> required <code>is_maker</code> <code>bool</code> <p>True if the fills are from maker orders, False if from taker orders.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of orders to cancel by cloids.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.event_orders_update","title":"<code>event_orders_update(cash, equity, position, ts, event_type, event_id, type_id, trade_buffer, ob_timestamps, ob_bids, ob_asks, ob_mids, features, open_orders, running_event_ids, running_type_ids, **kwargs)</code>","text":"<p>Update orders on event. Return None for no change to  orders, return [] to cancel all orders, otherwise return list of orders, each order is format (price, size, dir, cloid). Market orders are just aggressive  taker prices. Cloid is not used in logic, you may set to any value desired. </p> <p>Parameters:</p> Name Type Description Default <code>cash</code> <code>float</code> <p>Current cash balance.</p> required <code>equity</code> <code>float</code> <p>Current equity value.</p> required <code>position</code> <code>int</code> <p>Current position size.</p> required <code>ts</code> <code>int</code> <p>Timestamp of the event.</p> required <code>event_type</code> <code>int</code> <p>Type of the event (e.g., EVENT_CLOCK, EVENT_LOB, EVENT_TRADE).</p> required <code>event_id</code> <code>int</code> <p>Index of the event among all events.</p> required <code>type_id</code> <code>int</code> <p>Index of the event among this event type.</p> required <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events. If <code>event_type == EVENT_TRADE</code>, the trade event at this event is <code>trade_buffer[type_id]</code>.</p> required <code>ob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps. If <code>event_type == EVENT_LOB</code>, the orderbook timestamp at this event is <code>ob_timestamp[type_id]</code>.</p> required <code>ob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook bids at this event is <code>ob_bids[type_id]</code>.</p> required <code>ob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook asks at this event is <code>ob_asks[type_id]</code>.</p> required <code>ob_mids</code> <code>ndarray</code> <p>Array of mid prices. If <code>event_type == EVENT_LOB</code>, the orderbook mid at this event is <code>ob_mids[type_id]</code>.</p> required <code>features</code> <code>dict</code> <p>Dictionary of computed features, with key as event_type. Feature scalar computed at this  timestamp can be referenced using <code>features[event_type][feature_name][type_id]</code>.</p> required <code>open_orders</code> <code>ndarray</code> <p>Array of currently open orders.</p> required <code>running_event_ids</code> <code>dict</code> <p>Dictionary of currently running event IDs with key-value <code>event_type : event_id</code>.</p> required <code>running_type_ids</code> <code>dict</code> <p>Dictionary of currently active type IDs with key-value <code>event_type : type_id</code>. For  instance, at this event, the last-known trade/trade-features can be obtained with <code>trade_buffer[running_type_ids[EVENT_TRADE]]</code> / <code>features[EVENT_TRADE][feature_name][running_type_ids[EVENT_TRADE]]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of updated orders. If return None, assume no change in orders (same as <code>return open_orders</code>).</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Alpha.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Run the trading simulation, processing events and updating the portfolio accordingly.  On each (except <code>EVENT_TRADE</code>), we are allowed to update orders with <code>self.event_orders_update</code>. <code>EVENT_TRADE</code> is excluded from order updation since the trade event itself creates non-trivial market impact and reaction;  new orders created have miscellaneous queue position. </p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the portfolio's position, equity, and pnl over time.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Simulator</code></p> <p>A model that extends the <code>Simulator</code> class for estimating market features and/or doing fair price estimation.</p> <p>This class provides additional functionalities for running estimators on market events, computing features, and analyzing fair prices. It includes methods to generate data frames of estimators and fair price statistics.</p> <p>Attributes:</p> Name Type Description <code>estimator_df</code> <code>DataFrame</code> <p>A DataFrame containing the results of the event estimator.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initializes the Model with inherited Simulator attributes.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to the Simulator class initializer.</p> <code>{}</code>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model.df_estimators","title":"<code>df_estimators(include_forwards=True, include_zero=True, return_labels=False)</code>","text":"<p>Generate a DataFrame of estimator values with optional look-forward prices at different  intervals for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>include_forwards</code> <code>bool</code> <p>If True, includes forward prices in the returned DataFrame. Defaults to True.</p> <code>True</code> <code>include_zero</code> <code>bool</code> <p>If True and <code>include_forwards=True</code>, include the last-known orderbook mid price in the returned DataFrame. Defaults to True.</p> <code>True</code> <code>return_labels</code> <code>bool</code> <p>If True, returns the estimator DataFrame along with forward looking second intervals and labels. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>pd.DataFrame or tuple: A DataFrame of estimator values and forward prices, and optionally intervals and labels if <code>return_labels</code> is True.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model.df_fairprices","title":"<code>df_fairprices(plot=True)</code>","text":"<p>If the estimators returned in <code>event_estimator</code> are fair price estimators, this utility function  gives useful statistical properties about the estimator, as well as estimation errors. Optionally plot the results.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, plots the fair price differences. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - statistics (dict): A dictionary of statistical measures for each estimator and interval. - estimator_df (pd.DataFrame): A DataFrame of estimator and forward-looking feature values.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model.event_estimator","title":"<code>event_estimator(ts, event_type, event_id, type_id, trade_buffer, ob_timestamps, ob_bids, ob_asks, ob_mids, features, running_event_ids, running_type_ids, **kwargs)</code>","text":"<p>Estimate market features based on events. Returned dictionary should be a  key-value pair of <code>estimator_name : estimator_scalar</code> at this event. Return <code>None</code> or empty dictionary if no estimate is made.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>int</code> <p>The timestamp of the event.</p> required <code>event_type</code> <code>int</code> <p>The type of the event (e.g., EVENT_CLOCK, EVENT_LOB, EVENT_TRADE).</p> required <code>event_id</code> <code>int</code> <p>The index of the event among all events.</p> required <code>type_id</code> <code>int</code> <p>The index of the event among this event type.</p> required <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events. If <code>event_type == EVENT_TRADE</code>, the trade event at this event is <code>trade_buffer[type_id]</code>.</p> required <code>ob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps. If <code>event_type == EVENT_LOB</code>, the orderbook timestamp at this event is <code>ob_timestamp[type_id]</code>.</p> required <code>ob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook bids at this event is <code>ob_bids[type_id]</code>.</p> required <code>ob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes. If <code>event_type == EVENT_LOB</code>, the orderbook asks at this event is <code>ob_asks[type_id]</code>.</p> required <code>ob_mids</code> <code>ndarray</code> <p>Array of mid prices. If <code>event_type == EVENT_LOB</code>, the orderbook mid at this event is <code>ob_mids[type_id]</code>.</p> required <code>features</code> <code>dict</code> <p>Dictionary of computed features, with key as event_type. Feature scalar computed at this  timestamp can be referenced using <code>features[event_type][feature_name][type_id]</code>.</p> required <code>running_event_ids</code> <code>dict</code> <p>Dictionary of currently running event IDs with key-value <code>event_type : event_id</code>.</p> required <code>running_type_ids</code> <code>dict</code> <p>Dictionary of currently active type IDs with key-value <code>event_type : type_id</code>. For  instance, at this event, the last-known trade/trade-features can be obtained with <code>trade_buffer[running_type_ids[EVENT_TRADE]]</code> / <code>features[EVENT_TRADE][feature_name][running_type_ids[EVENT_TRADE]]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of estimated features for the event.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Model.run_estimator","title":"<code>run_estimator()</code>","text":"<p>Run through the events and collect estimators from <code>self.event_estimator</code>.</p> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the estimates for all events.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator","title":"<code>Simulator</code>","text":"<p>A simulator for modeling hft events. Base class for the <code>quantpylib.hft.alpha.Model</code>, which  is a statistical modeller for fair price estimation and other related estimators, as well as  for the <code>quantpylib.hft.alpha.Alpha</code>, which is a backtest simulator. <code>Simulator</code> instances  compute estimators (<code>Model</code>) and actions (<code>Alpha</code>) at events. Each event has an event type  marked by an integer. <code>EVENT_CLOCK:0</code>, <code>EVENT_LOB:1</code>, <code>EVENT_TRADE:2</code> are reserved since they are typical hft events for which one may decide to take action, such as in a clock-driven market-maker or event-driven  market-maker. Simulation is performed in two-steps: data-preprocessing and data-processing on the fly. In the pre-processing stage, we may compute vectorized features that do not require event-states, and only require the loaded data. This makes it performance-efficient. For instance,  orderbook features, trade features and clock-based features may be computed in  <code>compute_lob_features</code>, <code>compute_trade_features</code>, <code>compute_clock_features</code>, each returning numpy  arrays with scalar features. The second-part computes the estimators/actions chronologically, and may access the features computed, event states such as inventory, pnl and so on.</p> <p>Attributes:</p> Name Type Description <code>ob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps.</p> <code>ob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes.</p> <code>ob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes.</p> <code>ob_mids</code> <code>ndarray</code> <p>Array of mid prices.</p> <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events with timestamps, prices, sizes, and directions.</p> <code>clock_interval</code> <code>float</code> <p>The interval for the event clock in seconds.</p> <code>custom_events</code> <code>dict</code> <p>Dictionary of custom events with event IDs as keys and timestamps as values.</p> <code>custom_data</code> <code>dict</code> <p>Dictionary of additional data for custom events.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.__init__","title":"<code>__init__(lob=None, trades=None, ob_timestamps=None, ob_bids=None, ob_asks=None, ob_mids=None, trade_buffer=None, clock_interval=1000000000.0, custom_events={}, custom_data={})</code>","text":"<p>Initializes the Simulator with optional order book and trade data. One of <code>lob</code> or (<code>ob_timestamps,ob_bids,ob_asks,ob_mids</code>) are to provided. One of <code>trades</code> or <code>trade_buffer</code> is to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>lob</code> <code>`quantpylib.hft.lob.LOB`</code> <p>Orderbook object with filled data buffers. Defaults to None.</p> <code>None</code> <code>trades</code> <code>`quantpylib.hft.trades.Trades`</code> <p>Trades object with filled trade data buffers. Defaults to None.</p> <code>None</code> <code>ob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps. Defaults to None. 1-dimensional.</p> <code>None</code> <code>ob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes. Defaults to None. 3-dimensional (time, price, size)</p> <code>None</code> <code>ob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes. Defaults to None. 3-dimensional (time, price, size)</p> <code>None</code> <code>ob_mids</code> <code>ndarray</code> <p>Array of mid prices. Defaults to None. 1-dimensional.</p> <code>None</code> <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events. Defaults to None.</p> <code>None</code> <code>clock_interval</code> <code>float</code> <p>Interval for the event clock in seconds. Defaults to 1e9 (no clock events).</p> <code>1000000000.0</code> <code>custom_events</code> <code>dict</code> <p>Dictionary of custom events with key as integer event id and an array of timestamps for that event. Defaults to {}.</p> <code>{}</code> <code>custom_data</code> <code>dict</code> <p>Dictionary of additional data for custom events. No enforced data schema. Defaults to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reserved event IDs (0, 1, 2) are used in custom_events.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.compute_clock_features","title":"<code>compute_clock_features(clock_timestamps)</code>","text":"<p>Compute features based on clock events. Returned dictionary should be a key-value pair,  where the key is feature-name and value is a 1-d <code>np.ndarray</code> of same dimensions as <code>clock_timestamps</code>. Features unavailable at particular indices should be given <code>np.nan</code>.</p> <p>Parameters:</p> Name Type Description Default <code>clock_timestamps</code> <code>ndarray</code> <p>Array of clock event timestamps.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of computed clock features.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.compute_custom_features","title":"<code>compute_custom_features(event_id, timestamps, custom_data)</code>","text":"<p>Compute features for custom events. Returned dictionary should be a key-value pair,  where the key is feature-name and value is a 1-d <code>np.ndarray</code> of same dimensions as <code>timestamps</code>. Features unavailable at particular indices should be given <code>np.nan</code>.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>The ID of the custom event.</p> required <code>timestamps</code> <code>ndarray</code> <p>Array of custom event timestamps.</p> required <code>custom_data</code> <code>dict</code> <p>Additional data for custom events.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of computed custom features.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.compute_lob_features","title":"<code>compute_lob_features(lob_timestamps, lob_mids, lob_bids, lob_asks)</code>","text":"<p>Compute features based on limit order book events. Returned dictionary should be a key-value pair,  where the key is feature-name and value is a 1-d <code>np.ndarray</code> of same dimensions as <code>lob_timestamps</code>. Features unavailable at particular indices should be given <code>np.nan</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lob_timestamps</code> <code>ndarray</code> <p>Array of order book timestamps.</p> required <code>lob_mids</code> <code>ndarray</code> <p>Array of mid prices.</p> required <code>lob_bids</code> <code>ndarray</code> <p>Array of best bid prices and sizes.</p> required <code>lob_asks</code> <code>ndarray</code> <p>Array of best ask prices and sizes.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of computed limit order book features.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.compute_trade_features","title":"<code>compute_trade_features(trade_buffer)</code>","text":"<p>Compute features based on trade events. Returned dictionary should be a key-value pair,  where the key is feature-name and value is a 1-d <code>np.ndarray</code> of same length as <code>trade_buffer</code>. Features unavailable at particular indices should be given <code>np.nan</code>.</p> <p>Parameters:</p> Name Type Description Default <code>trade_buffer</code> <code>ndarray</code> <p>Array of trade events with timestamps, prices, sizes, and directions.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of computed trade features.</p>"},{"location":"hft/alpha/#quantpylib.hft.alpha.Simulator.df_prices","title":"<code>df_prices(plot=False, ax=None)</code>","text":"<p>Generate a DataFrame of bid, ask, and mid prices, with optional plotting.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, plots the price data. Defaults to False.</p> <code>False</code> <code>ax</code> <code>Axes</code> <p>Matplotlib axis object for plotting. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame with columns for bid, ask, and mid prices indexed by timestamp.</p>"},{"location":"hft/features/","title":"quantpylib.hft.features","text":""},{"location":"hft/features/#quantpylib.hft.features.rolling_vol","title":"<code>rolling_vol(mids, n, exp=False)</code>","text":"<p>Calculate rolling volatility of the mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>mids</code> <code>ndarray</code> <p>Array of mid prices.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling volatilities.</p>"},{"location":"hft/features/#quantpylib.hft.features.sample_vamp","title":"<code>sample_vamp(bids, asks, notional=None, bid_notional=None, ask_notional=None)</code>","text":"<p>Calculate the Volume Adjusted Mid Price (VAMP). </p> <p>Parameters:</p> Name Type Description Default <code>bids</code> <code>ndarray</code> <p>Array of bid levels as [price, volume].</p> required <code>asks</code> <code>ndarray</code> <p>Array of ask levels as [price, volume].</p> required <code>notional</code> <code>float</code> <p>The notional amount for both sides of the orderbook (each). Defaults to None.</p> <code>None</code> <code>bid_notional</code> <code>float</code> <p>The notional amount for bids. Defaults to <code>notional</code> if not provided.</p> <code>None</code> <code>ask_notional</code> <code>float</code> <p>The notional amount for asks. Defaults to <code>notional</code> if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated VAMP.</p>"},{"location":"hft/features/#quantpylib.hft.features.sample_vol","title":"<code>sample_vol(sample, exp=False)</code>","text":"<p>Calculate the sample volatility.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>ndarray</code> <p>The input sample.</p> required <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated sample volatility.</p>"},{"location":"hft/features/#quantpylib.hft.features.volume_weighted_price","title":"<code>volume_weighted_price(ob_levels, notional)</code>","text":"<p>Calculate the volume-weighted price for a given notional amount.</p> <p>Parameters:</p> Name Type Description Default <code>ob_levels</code> <code>ndarray</code> <p>The order book levels as an array of [price, volume].</p> required <code>notional</code> <code>float</code> <p>The notional amount.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The volume-weighted price.</p>"},{"location":"hft/feed/","title":"quantpylib.hft.feed","text":""},{"location":"hft/feed/#quantpylib.hft.feed.Feed","title":"<code>Feed</code>","text":""},{"location":"hft/feed/#quantpylib.hft.feed.Feed.__init__","title":"<code>__init__(gateway, exchanges=None)</code>","text":"<p>Initialize the feeder object.</p> <p>Parameters:</p> Name Type Description Default <code>gateway</code> <code>Gateway</code> <p>Initialized gateway object.</p> required <code>exchanges</code> <code>list</code> <p>The list of exchanges to subscribe to. If None, use the clients in the gateway.</p> <code>None</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_handler_to_feed","title":"<code>add_handler_to_feed(feed_id, handler)</code>","text":"<p>Add a handler to a feed.</p> <p>Parameters:</p> Name Type Description Default <code>feed_id</code> <code>str</code> <p>The feed id.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add.</p> required"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_l2_book_feed","title":"<code>add_l2_book_feed(exc, ticker, handler=None, depth=20, buffer=100, **kwargs)</code>  <code>async</code>","text":"<p>Add a level 2 order book feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The depth of the order book. Defaults to 20.</p> <code>20</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_trades_feed","title":"<code>add_trades_feed(exc, ticker, handler=None, buffer=100, **kwargs)</code>  <code>async</code>","text":"<p>Add a trades feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.get_feed","title":"<code>get_feed(feed_id)</code>","text":"<p>Get the feed object or buffer associated with feed_id.</p> <p>Parameters:</p> Name Type Description Default <code>feed_id</code> <code>str</code> <p>The feed id.</p> required"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.get_feed_ids","title":"<code>get_feed_ids()</code>","text":"<p>Get list of all feed ids.</p>"},{"location":"hft/feed/#quantpylib.hft.feed.FeedCls","title":"<code>FeedCls</code>","text":"<p>Asset classes.</p> <p>Attributes:</p> Name Type Description <code>PERPETUAL</code> <code>str</code> <p>Perpetual futures.</p> <code>FUTURES</code> <code>str</code> <p>Futures.</p> <code>SPOT</code> <code>str</code> <p>Spot.</p> <code>OPTIONS</code> <code>str</code> <p>Options.</p> <code>SWAPS</code> <code>str</code> <p>Swaps.</p>"},{"location":"hft/feed/#quantpylib.hft.feed.FeedType","title":"<code>FeedType</code>","text":"<p>Types of feeds.</p> <p>Attributes:</p> Name Type Description <code>L1BOOK</code> <code>str</code> <p>Level 1 order book feed.</p> <code>L2BOOK</code> <code>str</code> <p>Level 2 order book feed.</p> <code>L2DELTA</code> <code>str</code> <p>Level 2 order book delta feed.</p> <code>TRADES</code> <code>str</code> <p>Trades feed.</p> <code>NMIDS</code> <code>str</code> <p>Mid prices</p>"},{"location":"hft/hft/","title":"quantpylib.hft","text":"<p><code>quantpylib.hft</code> is our core module designed for hft-trading purposes, including modelling, analysis and simulation of high-frequency data.</p> <p><code>quantpylib.hft.alpha</code> is our simulator, modeller and backtester. You may simulate fills, portfolio wealth and do statistical modelling, such as fair price analysis.</p> <p><code>quantpylib.hft.feed</code> is our data feeder for public information and market data such as order book and trade feeds.</p> <p><code>quantpylib.hft.oms</code> is our order management system for positions, orders tracking and trade execution + management.</p> <p><code>quantpylib.hft.lob</code> is our internal limit-order book representation, and is designed to store orderbook states and buffers. There are utility functions to keep accurate representations of the internal state for both book snapshots and incremental updates. A host of other utility functions related to orderbook modelling can be found.</p> <p><code>quantpylib.hft.trades</code> is our internal trade buffer. There are utility functions to compute useful information and statistics from the data stored in the buffer.</p> <p><code>quantpylib.hft.statistics</code> is a statistics library for hft modelling - in addition it should work seamlessly with the data structures in the <code>quantpylib.hft.lob.LOB</code> and <code>quantpylib.hft.trades.Trades</code> object instances.</p>"},{"location":"hft/hft/#examples","title":"Examples","text":""},{"location":"hft/hft/#data-feed","title":"Data Feed","text":"<p>Obtaining data feeds are extremely simple with <code>quantpylib.hft.feed.Feed</code> objects. Simply - create a gateway object with the correct keys and pass them in</p> <p><pre><code>import os \nimport asyncio\n\nfrom pprint import pprint\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.gateway.master import Gateway \nfrom quantpylib.hft.feed import Feed\n\nkeys = {\n    \"binance\": {'key':'','secret':''},\n    \"hyperliquid\": {'key':'','secret':''},\n}\n\nasync def printer(data):\n    print(data)\n\nasync def printer_1(data):\n    print('1\\n',data.as_dict())\n\nasync def printer_2(data):\n    print('2\\n',data.as_dict())\n\nasync def main():\n    exchange,ticker = 'hyperliquid', 'BTC'\n    # exchange,ticker = 'binance', 'BTCUSDT'\n\n    gateway = Gateway(config_keys=keys)\n    await gateway.init_clients()\n    feed = Feed(gateway=gateway)\n    #code goes here\n    pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> To use binance, simply uncomment the line above. Proceeding... </p> <p>To get a order book feed, we can write: <pre><code>    l2_feed = await feed.add_l2_book_feed(exc=exchange,ticker=ticker,handler=printer_1)\n</code></pre> and we get <code>hyperliquid|perp|l2book|BTC</code>. Notice how we added a handler here - this is optional. We can add arbitrary number of coroutine handlers - when the feed is received, it will be broadcast to all handlers asynchronously. All the schema is standardized - there is no need to write exchange-dependent code. <pre><code>feed.add_handler_to_feed(l2_feed,printer_2)\n</code></pre> We will get (the same message) <pre><code>1\n {'ts': 1725903430442, \n 'bids': array([[5.65460e+04, 8.75000e-03],\n       [5.65430e+04, 9.33710e-01],\n       ...\n       [5.65220e+04, 1.98847e+00]]), \n 'asks': array([[5.65470e+04, 2.20767e+00],\n       [5.65480e+04, 1.67035e+00],\n       ...\n       [5.65710e+04, 2.64770e-01]])}\n2\n {'ts': 1725903430442, \n 'bids': array([[5.65460e+04, 8.75000e-03],\n       [5.65430e+04, 9.33710e-01],\n       ...\n       [5.65220e+04, 1.98847e+00]]), \n 'asks': array([[5.65470e+04, 2.20767e+00],\n       [5.65480e+04, 1.67035e+00],\n       ...\n       [5.65710e+04, 2.64770e-01]])}\n</code></pre> This message is constructed from order-book delta updates - it is a local order book state. We can also control the depth of the streams, speed of update and how much data buffer we keep. This data buffer is actually given to us as a <code>quantpylib.hft.lob.LOB</code> object -  we can retrieve it using the feed id. <pre><code>lob = feed.get_feed(l2_feed)\nprint(l2_feed)\nprint(lob) #`quantpylib.hft.lob.LOB` object\nprint(lob.get_mid(), lob.get_vamp(notional=30000)) #54884.5 54883.872068603436\nprint(lob.get_bids_buffer())\n</code></pre> We can get the time-series of bids, most recent mid-price, bba, vamp indicators and what not from this object. It is equally simple to get the trades feed, obtain a <code>quantpylib.hft.trades.Trades</code> object and get the running buffer, statistics and what not: <pre><code>trades_feed = await feed.add_trades_feed(exc=exchange,ticker=ticker,handler=printer)\ntrades = feed.get_feed(trades_feed)\nawait asyncio.sleep(5)\nprint(trades) #`quantpylib.hft.trades.Trades` object\nprint(trades.get_imbalance()) #0.8328041302230744\n</code></pre> The messages look like this: <pre><code>(1725904146989, 56497.0, 0.00037, -1)\n(1725904147170, 56498.0, 0.01171, 1)\n(1725904147773, 56498.0, 0.02284, 1)\n(1725904148396, 56497.0, 0.03539, -1)\n(1725904148401, 56498.0, 0.14221, 1)\n(1725904148401, 56498.0, 0.52174, 1)\n(1725904148401, 56498.0, 1.06198, 1)\n(1725904148401, 56498.0, 0.27407, 1)\n(1725904153032, 56492.0, 0.00887, 1)\n(1725904154037, 56490.0, 0.00022, 1)\n(1725904157831, 56476.0, 0.002, 1)\n(1725904158024, 56475.0, 0.00021, -1)\n(1725904159031, 56476.0, 0.00963, 1)\n</code></pre> It is simple to interpret: <code>time, price, size, dir</code>. When <code>dir = 1</code>, it means a taker buy initiated trade. </p> <p>Get all the running feed ids here: <pre><code>print(feed.get_feed_ids())\n</code></pre></p>"},{"location":"hft/hft/#oms","title":"OMS","text":"<p>It is easy to create a manager class - it is similar to the<code>quantpylib.hft.feed.Feed</code> objects. Simply - create a gateway object with the correct keys and pass them in.</p> <p>We will demonstrate with examples: <pre><code>import os \nimport asyncio \n\nfrom pprint import pprint\nfrom dotenv import load_dotenv \nload_dotenv()\n\nfrom quantpylib.hft.oms import OMS\nfrom quantpylib.gateway.master import Gateway\nimport quantpylib.standards.markets as markets\n\nconfig_keys = {\n    'binance': {\n        'key': '1234',\n        'secret': '1234',\n    },\n    'hyperliquid': {\n        'key': '1234',\n        'secret': '1234',\n    }\n}\ngateway = Gateway(config_keys)\n\nasync def main():\n    await gateway.init_clients()\n    oms = OMS(gateway)\n    await oms.init()\n    #code goes here... \n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>For all of our socket-based message handlers, we will use a generic printer to showcase results: <pre><code>async def printer(data):\n    if isinstance(data,dict) or isinstance(data,list):\n        pprint(data)\n    else:\n        try: pprint(data.as_dict())\n        except: pprint(data.as_list())\n</code></pre> Now, let us take a look at the functionalities. We can get trading specifications for the contracts on initiated exchanges: <pre><code>pprint(oms.contract_specs(exc='hyperliquid', ticker='BTC'))\n</code></pre> we get <pre><code>{'base_asset': 'BTC',\n'min_notional': Decimal('10.0'),\n'price_precision': 1,\n'quantity_precision': 5,\n'quote_asset': 'USDT'}\n</code></pre> Some useful statistics and utilities: <pre><code>pprint(oms.lagged_price(exc='hyperliquid', ticker='ETH')) #Decimal('2368.25')\npprint(oms.lot_precision(exc='hyperliquid', ticker='BTC')) #5\npprint(oms.price_precision(exc='hyperliquid', ticker='DOGE')) #6\npprint(oms.rounded_lots(exc='hyperliquid', ticker='BTC',amount=0.0023032)) #0.0023\npprint(oms.min_notional(exc='hyperliquid', ticker='BTC')) #Decimal('10.0')\npprint(oms.rand_cloid(exc='binance')) #'b486130e1b35986abc803bb79d2e675d'\npprint(oms.common_lot_precision(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #3\npprint(oms.common_price_precision(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #1\npprint(oms.common_min_notional(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #Decimal('100')\n</code></pre> We would like to get some positions data. Note that when <code>oms.init()</code> is called, all orders and positions are automatically mirrored using underlying exchange socket subscriptions. We can make connection-less request by retrieving local state: <pre><code>pprint(oms.get_position(exc='hyperliquid', ticker='SOL')) #Decimal('1.0') (no requests made)\n</code></pre> or we can force the OMS to make a HTTP request: <pre><code>pprint(await oms.positions_get(exc='hyperliquid')) #HTTP requests made\npprint(await oms.positions_get_all())\n</code></pre> which gives us outputs <pre><code>{'SOL': {'amount': Decimal('1.0'),\n         'entry': Decimal('134.81'),\n         'ticker': 'SOL',\n         'unrealized_pnl': -0.3,\n         'value': Decimal('134.51')}}\n</code></pre> and <pre><code>{'binance': {'QUANTUSDT': {'amount': Decimal('826'),\n                         'entry': Decimal('0.1250522412206'),\n                         'ticker': 'QUANTUSDT',\n                         'unrealized_pnl': 1.03231002,\n                         'value': Decimal('104.32546026')}},\n 'hyperliquid': {'SOL': {'amount': Decimal('1.0'),\n                         'entry': Decimal('134.81'),\n                         'ticker': 'SOL',\n                         'unrealized_pnl': -0.3,\n                         'value': Decimal('134.51')}}}\n</code></pre> respectively. Only one of each schema level is shown - obviously if more positions were held, more entries would be seen.</p> <p>If we want to get the live positions object that tracks all positions, or register a handler on position change, we may do so. In particular, we can register handler <code>on_update</code> which passes the entire positions page (and/or) <code>on_delta</code> which passes the change in positions. Furthermore, the return value is the <code>Positions</code> object which is 'alive', so to speak, and keeps up to date with filled orders. <pre><code>live_positions = await oms.positions_mirror(exc='hyperliquid',on_update=printer,on_delta=printer)\nprint(live_positions)#&lt;quantpylib.standards.portfolio.Positions object at 0x12a98c8f0&gt;\n</code></pre></p> <p>We may do the same with orders: <pre><code>pprint(await oms.orders_get(exc='hyperliquid')) #HTTP\npprint(await oms.orders_get_all())\n</code></pre> for output: <pre><code>{1234: {\n        'amount': Decimal('1.0'),\n        'cloid': '',\n        'filled_sz': Decimal('0.0'),\n        'oid': '1234',\n        'ord_status': 'NEW',\n        'price': Decimal('100.0'),\n        'ticker': 'SOL',\n        'timestamp': 1726113126684\n        }\n}\n{'hyperliquid': {1234: {'amount': Decimal('1.0'),\n                        'cloid': '',\n                        'filled_sz': Decimal('0.0'),\n                        'oid': '1234',\n                        'ord_status': 'NEW',\n                        'price': Decimal('100.0'),\n                        'ticker': 'SOL',\n                        'timestamp': 1726113126684}}}\n'binance': .... {}\n</code></pre> Or...register handlers for orders page snapshot (and/or) just the changes. This also returns us a live <code>Orders</code> object: <pre><code>live_orders = await oms.orders_mirror(exc='hyperliquid',on_update=printer,on_delta=printer)\nprint(live_orders)#&lt;quantpylib.standards.portfolio.Orders object at 0x13252f050&gt;\n</code></pre></p> <p>Now that we have registered some handlers for orders, and what not - let us see what the messages look like. We can make a limit order through the OMS - the parameters are the same as in <code>Gateway</code> usage: <pre><code>cloid = oms.rand_cloid(exc='hyperliquid')\nawait oms.limit_order(exc='hyperliquid',ticker='SOL',amount=1,price=129.56,cloid=cloid)\nawait oms.limit_order(exc='binance',ticker='SOLUSDT',price_match=markets.PRICE_MATCH_QUEUE_1,amount=1)\n</code></pre> Recall that our handlers are registered for <code>hyperliquid</code>, so let's see what gets printed: The <code>on_delta</code> handler receives two messages: <pre><code>{'amount': Decimal('1'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154778980,\n 'tp': None}\n{'amount': Decimal('1.0'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '1234',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154781307,\n 'tp': None}\n</code></pre> The first is order-creation: a request has been sent to the exchange, but not yet acknowledged. Only the local trading agent is aware, but the order is possibly unsuccessful; hence <code>PENDING</code> status. This is followed by a <code>NEW</code> order which means the order was acknowledged successful by the exchange. The <code>on_update</code> handler sends this order, along with all the other open orders - which we print as a list: <pre><code>[{'amount': Decimal('1.0'),\n  ...\n  'timestamp': 1726123317580,\n  'tp': None},\n {'amount': Decimal('1.0'),\n  'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n  'exc': 'hyperliquid',\n  'filled_sz': Decimal('0.0'),\n  'last_fill_sz': Decimal('0.0'),\n  'oid': '1234',\n  'ord_status': 'NEW',\n  'ord_type': None,\n  'price': Decimal('129.56'),\n  'price_match': None,\n  'reduce_only': None,\n  'sl': None,\n  'ticker': 'SOL',\n  'tif': None,\n  'timestamp': 1726154781307,\n  'tp': None}]\n</code></pre> Next we submit an order cancel: <pre><code>await oms.cancel_order(exc='hyperliquid',ticker='SOL',cloid=cloid) #or use oid\n</code></pre> and this is acknowledged <code>on_delta</code>: <pre><code>{'amount': Decimal('1.0'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '1234',\n 'ord_status': 'CANCELLED',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154781307,\n 'tp': None}\n</code></pre> and the <code>on_update</code> prints the new list (not shown), this time without the cancelled order - since it is not on the orders page anymore (it is no longer open).</p> <p>We can of course, do a market-order: <pre><code>await oms.market_order(exc='hyperliquid',ticker='SOL',amount=-1)\n</code></pre> Which also gives a <code>on_delta</code>, <code>PENDING</code> message: <pre><code>{'amount': Decimal('-1'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154778980,\n 'tp': None}\n</code></pre> This is filled immediately in two blocks, and the <code>positions</code>'s <code>on_delta</code> message is called with each fill <pre><code>{'amount': Decimal('0.19'),\n 'delta': Decimal('-0.81'),\n 'entry': Decimal('134.81'),\n 'ticker': 'SOL'}\n{'amount': Decimal('0.00'),\n 'delta': Decimal('-0.19'),\n 'entry': Decimal('134.79'),\n 'ticker': 'SOL'}\n</code></pre> where <code>amount</code> is the new signed position held after <code>delta</code> is filled - at the end of this market order our <code>SOL</code> position is closed fully, so our <code>positions</code>'s <code>on_update</code> receives the positions page (no open positions): <pre><code>{}\n</code></pre> on the other hand the <code>PENDING</code> order created is acknowledged by exchange to <code>NEW</code> and then immediately <code>FILLED</code> on creation with <code>on_delta</code> triggers: <pre><code>{'amount': Decimal('-1.0'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': 'yomama',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('127.69'), #hyperliquid's market order is an aggressive limit order\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154797325,\n 'tp': None}\n{'amount': Decimal('-1.0'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('1.0'),\n 'last_fill_sz': Decimal('1.0'),\n 'oid': 'yomama',\n 'ord_status': 'FILLED',\n 'ord_type': None,\n 'price': Decimal('127.69'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154797325,\n 'tp': None}\n</code></pre> and <code>on_update</code> triggers: <pre><code>[{'amount': Decimal('1.0'),\n  ...\n  'timestamp': 1726123317580,\n  'tp': None},]\n</code></pre> We will demonstrate a complex order supported by the OMS - let's call it <code>hedge_order</code>. It is quite often that we want one order to trigger another in a multi-leg trade. For instance, a triangular arbitrage, cross-exchange market making, funding arbitrage and l/s arbitrage all often use similar fixtures. A hedge order allows us to submit a maker-order, and the matching taker order is triggered with size matching that of the filled amount on the maker-leg. When lot size rounding doesn't allow for complete hedging, the remaining balance is stored and flushed with the next best available order. Let's see how we can make use of this. To get information from both exchanges, we wil add the binance handlers: <pre><code>await oms.positions_mirror(exc='binance',on_update=printer,on_delta=printer)\nawait oms.orders_mirror(exc='binance',on_update=printer,on_delta=printer)\nawait asyncio.sleep(5)\n</code></pre> and then make a hedge order <pre><code>await oms.hedge_order(\n    maker_order = {\n        \"exc\": \"binance\",\n        \"ticker\": \"SOLUSDT\",\n        \"amount\": -3,\n        \"price_match\": markets.PRICE_MATCH_QUEUE_5\n    },\n    hedge_order = {\n        \"exc\": \"hyperliquid\",\n        \"ticker\": \"SOL\",\n    }\n)\n</code></pre> Note that an amount is not specified for the hedge-order - since we are listening for the filled sizes on binance. First - a pending order is created on binance, then acknowledged <pre><code>&gt;&gt; orders delta:\n{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': 'QUEUE_5',\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': None,\n 'timestamp': 1726199235551,\n 'tp': None}\n{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': '68254554715',\n 'ord_status': 'NEW',\n 'ord_type': 'LIMIT',\n 'price': Decimal('134.5460'),\n 'price_match': 'QUEUE_5',\n 'reduce_only': False,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': 'GTC',\n 'timestamp': 1726199241966,\n 'tp': None}\n&gt;&gt; orders snapshot:\n[{'amount': Decimal('-3'),\n  'cloid': 'c484811d8ce145004eeb26c917013c29',\n  'exc': 'binance',\n  'filled_sz': Decimal('0'),\n  'last_fill_sz': Decimal('0'),\n  'oid': '68254554715',\n  'ord_status': 'NEW',\n  'ord_type': 'LIMIT',\n  'price': Decimal('134.5460'),\n  'price_match': 'QUEUE_5',\n  'reduce_only': False,\n  'sl': None,\n  'ticker': 'SOLUSDT',\n  'tif': 'GTC',\n  'timestamp': 1726199241966,\n  'tp': None}]\n</code></pre> It is later filled: <pre><code>&gt;&gt; positions delta:\n{'amount': Decimal('-3'),\n 'delta': Decimal('-3'),\n 'entry': Decimal('134.546'),\n 'ticker': 'SOLUSDT'}\n&gt;&gt; positions snapshot:\n{'SOLUSDT': {'amount': Decimal('-3'),\n            'entry': Decimal('134.546'),\n            'ticker': 'SOLUSDT'}}\n</code></pre> Which also shows up in the orders: <pre><code>{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('3'),\n 'last_fill_sz': Decimal('3'),\n 'oid': '68254554715',\n 'ord_status': 'FILLED',\n 'ord_type': 'LIMIT',\n 'price': Decimal('134.5460'),\n 'price_match': 'QUEUE_5',\n 'reduce_only': False,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': 'GTC',\n 'timestamp': 1726199256915,\n 'tp': None}\n</code></pre> This triggers a taker order on hyperliquid - which goes from <code>PENDING</code> to <code>NEW</code> to <code>FILLED</code> <pre><code>{'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199235551,\n 'tp': None}\n {'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '37771235449',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('141.36'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199257706,\n 'tp': None}\n{'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('3.0'),\n 'last_fill_sz': Decimal('3.0'),\n 'oid': '37771235449',\n 'ord_status': 'FILLED',\n 'ord_type': None,\n 'price': Decimal('141.36'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199257706,\n 'tp': None}\n</code></pre> We also get the positions delta and snapshots on hyperliquid: <pre><code>{'amount': Decimal('3.0'),\n 'delta': Decimal('3.0'),\n 'entry': Decimal('134.65'),\n 'ticker': 'SOL'}\n\n{'SOL': {'amount': Decimal('3.0'), 'entry': Decimal('134.65'), 'ticker': 'SOL'}}\n</code></pre> Note that the orders are sent even if it is a partial-fill with matching size - we don't have to wait for the entire maker order to be complete.</p>"},{"location":"hft/hft/#backtest","title":"Backtest","text":"<p>We may want to test some order simulation and fills. To do that, we would need to use the  <code>quantpylib.hft.alpha.Alpha</code> object, which extends the <code>quantpylib.hft.alpha.Simulator</code>. Looking at the documentation, the <code>Alpha</code> object takes in cash, maker fees, taker fees and arguments to <code>Simulator</code>, which takes in some <code>numpy</code> orderbook and trades data.</p> <p>Let's load some data (note that the <code>ob</code> and <code>trades</code> objects in Section Statistics example can be directly passed  into <code>Simulator</code> instances).</p> <p><pre><code>from quantpylib.utilities.general import load_pickle \n(\n    ob_timestamps, #milliseconds\n    bids,\n    asks,\n    mids,\n    trades\n) = load_pickle(\"hft_data\") #from the /examples folder\n</code></pre> The data formats are simple (and standard) - don't worry about the order, they will be internally sorted by timestamps: <pre><code>print(ob_timestamps.shape, bids.shape, asks.shape, mids.shape) #(6101,) (6101, 20, 2) (6101, 20, 2) (6101,)\nprint(trades.shape) #(3242, 4)\n</code></pre> like <pre><code>ob_timestamps &gt;&gt; [1722092399738 1722092400349 ... 1722095998678 1722095999283]\n\nbids[0] &gt;&gt; [[2.0245e-01 1.9000e+02]\n [2.0244e-01 1.2500e+02]\n [2.0243e-01 7.5000e+02]\n [2.0242e-01 2.5800e+02]\n...]\n\nasks[0] &gt;&gt; [[2.0263e-01 2.3800e+02]\n [2.0264e-01 2.4600e+02]\n [2.0265e-01 3.2500e+02]\n [2.0266e-01 8.4400e+02]\n...]\n\nmids &gt;&gt; [0.20254  0.202545 0.202545 ... 0.20073  0.20073  0.20073 ]\n</code></pre> Trades data are also numpy arrays with (time, price, size, dir) like <pre><code>trades &gt;&gt; \n[[ 1.72209242e+12  2.02640000e-01  6.80000000e+01  1.00000000e+00]\n [ 1.72209242e+12  2.02450000e-01  2.13000000e+02 -1.00000000e+00]\n [ 1.72209242e+12  2.02440000e-01  1.25000000e+02 -1.00000000e+00]\n ...\n [ 1.72209600e+12  2.00810000e-01  1.07000000e+03  1.00000000e+00]\n [ 1.72209600e+12  2.00810000e-01  8.57000000e+02  1.00000000e+00]\n [ 1.72209600e+12  2.00810000e-01  1.15000000e+02  1.00000000e+00]]\n</code></pre></p> <p>Some imports: <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom quantpylib.hft.alpha import EVENT_CLOCK, EVENT_LOB, EVENT_TRADE\nfrom quantpylib.hft.alpha import Alpha\nfrom quantpylib.hft.features import rolling_vol\n</code></pre></p> <p>There are not that many endpoints to implement. We can see in the docs that <code>Simulator</code> exposes <code>compute_*_features</code>, and <code>Alpha</code> exposes <code>event_orders_update</code> and <code>event_orders_fill</code>.  The <code>compute</code> methods are data pre-processing step where you can do heavy numerical/vectorized work on your data buffers to aid in your signal. The <code>event_orders_update</code> handles your live orders; here you can handle order creates, cancels and modifies. <code>event_orders_fill</code> is a notification for orders filled. All orders created have the format (price, size, dir, cloid). Cloid can be set to any value or specific value for your own needs. Taker orders are just aggressive prices, the actual filled price is matched against the order book liquidity. Maker orders are assumed filled when there is a crossing (strict inequality) trade event.</p> <p>For demonstration, we will just use some orderbook features. In fact we are just going to use volatility and quote symmetrically around the mid price: <pre><code>class Strat(Alpha):\n\n    def event_orders_fill(\n        self,cash,equity,position,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,    \n        running_event_ids,running_type_ids,\n        orders,filled_orders,is_maker,**kwargs\n        ):\n        pass\n\n    def event_orders_update(\n        self,cash,equity,position,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        open_orders,running_event_ids,running_type_ids,**kwargs\n        ): \n        pass\n\n    def compute_lob_features(self,lob_timestamps,lob_mids,lob_bids,lob_asks):   \n        pass\n\n    def compute_trade_features(self,trade_buffer):\n        pass\n\n    #def other compute_*_\n</code></pre> The lob features are to return a n-dimensional numpy scalar values, where <code>n = len(lob_timestamps)</code>. We are just going to use the rolling volatility function from <code>quantpylib.hft.features</code>. <pre><code>    def compute_lob_features(self,lob_timestamps,lob_mids,lob_bids,lob_asks):   \n        return {\n            \"vol\" : rolling_vol(lob_mids,n=200),\n        }\n</code></pre> In <code>event_orders_update</code>, <code>kwargs</code> contain additional information w.r.t to the event type. You can have custom events, but by default, we have <code>EVENT_CLOCK</code>, <code>EVENT_LOB</code> and <code>EVENT_TRADE</code>. Since these events have different cardinality (number of orderbook data different from trades, for instance), the last/most-recent index  we are able to access is given in <code>running_type_ids</code>. To create quotes symmetrically about the mid-price on each orderbook tick and four standard deviations wide, we can do: <pre><code>    def event_orders_update(\n        self,cash,equity,position,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        open_orders,running_event_ids,running_type_ids,**kwargs\n        ): \n        if event_type == EVENT_LOB:\n            mid = kwargs['mid']\n            sigma = features[EVENT_LOB][\"vol\"][type_id]\n            return np.array([\n                [mid - 4 * sigma, 100/mid, 1, self.cloid()],\n                [mid + 4 * sigma, 100/mid, -1, self.cloid()]                \n            ],dtype=np.float64)\n</code></pre> Here the bid is <code>mid - 4sigma</code>, order value is <code>100</code>, size is <code>100/mid</code>, and direction is long <code>1</code>. We submit both bid and ask orders. If the event is ignored, that is <code>None</code> is returned, then it is the same as returning <code>open_orders</code>: <pre><code>    def event_orders_update(\n        self,cash,equity,position,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        open_orders,running_event_ids,running_type_ids,**kwargs\n        ): \n        if event_type == EVENT_LOB:\n            mid = kwargs['mid']\n            sigma = features[EVENT_LOB][\"vol\"][type_id]\n            return np.array([\n                [mid - 4 * sigma, 100/mid, 1, self.cloid()],\n                [mid + 4 * sigma, 100/mid, -1, self.cloid()]                \n            ],dtype=np.float64)\n        if event_type == EVENT_CLOCK:\n            return open_orders\n</code></pre> Of course you can return <code>[]</code> to cancel all orders. There is no action to take on filled orders for this simple setup. It is simple to run <pre><code>alpha = Strat(\n    cash=5000,\n    ob_timestamps=ob_timestamps,ob_bids=bids,ob_asks=asks,ob_mids=mids,\n    trade_buffer=trades,\n    taker_fees=0.00035, maker_fees=-0.00001,\n)\ndf = alpha.run_simulation()\n</code></pre> and after running the simulation we can ask for a bunch of useful plots. For instance, the prices and actions overlayed. Default shows filled orders on prices: <pre><code>alpha.df_prices(plot=True)\nalpha.df_actions(plot=True)\nplt.show()\nplt.close()\n</code></pre> </p> <p>We can plot next-tick markouts and second interval markouts of fills against mid price: <pre><code>alpha.df_markouts(plot=True)\n</code></pre> </p> <p>as well as pnl, inventory overlayed on prices: <pre><code>print(alpha.df_portfolio(plot=True,plot_prices=True))\nplt.show()\n</code></pre> </p> <p>Of course, this was a highly simplistic market-making logic. Obviously the  position sizing should be a function of <code>cash</code>, <code>equity</code> and <code>position</code> and other portfolio states. We can also trade on clock-cycles - to do this,  say we want to refresh our orders every second rather than on a orderbook update. Since we want would be trading on <code>EVENT_CLOCK</code>, the <code>type_id</code> refers  to the index within the clock events. However, we can use <code>running_type_ids</code> and <code>EVENT_LOB</code> to get the recent bid-asks - the orders update function is updated: <pre><code>    def event_orders_update(\n        self,cash,equity,position,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        open_orders,running_event_ids,running_type_ids,**kwargs\n        ): \n        if event_type == EVENT_CLOCK:\n            bids = ob_bids[running_type_ids[EVENT_LOB]]\n            asks = ob_asks[running_type_ids[EVENT_LOB]]\n            mid = (bids[0,0] + asks[0,0])/2\n            #or simply =&gt; ob_mids[running_type_ids[EVENT_LOB]]\n            sigma = features[EVENT_LOB][\"vol\"][running_type_ids[EVENT_LOB]]\n\n            return np.array([\n                [mid - 4 * sigma, 100/mid, 1, self.cloid()],\n                [mid + 4 * sigma, 100/mid, -1, self.cloid()]                \n            ],dtype=np.float64)\n        # if event_type == EVENT_LOB:\n        #     mid = kwargs['mid']\n        #     sigma = features[EVENT_LOB][\"vol\"][type_id]\n        #     return np.array([\n        #         [mid - 4 * sigma, 100/mid, 1, self.cloid()],\n        #         [mid + 4 * sigma, 100/mid, -1, self.cloid()]                \n        #     ],dtype=np.float64)\n</code></pre> and we would explicitly pass in a clock-interval <pre><code>alpha = Strat(\n    cash=5000,\n    ob_timestamps=timestamps,ob_bids=bids,ob_asks=asks,ob_mids=mids,\n    trade_buffer=trades,\n    taker_fees=0.00035, maker_fees=-0.00001,clock_interval=1,\n\n)\n</code></pre> This is in seconds, so if we were to refresh every 250ms we can simply do <code>clock_interval=0.25</code>.</p>"},{"location":"hft/hft/#modelling","title":"Modelling","text":"<p>Instead of judging the trading problem by terminal wealth, which is certainly affected by a large number of factors - we may be interested in modelling subproblems in market microstructure. Here the <code>quantpylib.hft.alpha.Model</code> is of help - which also extends the <code>Simulator</code> class as did the <code>Alpha</code> backtester. Hence the same logic applies to <code>compute_*_features</code> methods - they are pre-processing logic. Here the <code>Model</code> class only take in the orderbook and trades data without cash, fees et cetera.</p>"},{"location":"hft/hft/#vamp-demo","title":"VAMP-Demo","text":"<p>For instance, we may interested in a fair price estimator that deviates from the mid price using orderbook features. One example is that of the Volume-Adjusted Mid Price estimator, brought up in this paper on short-term crypto price prediction. </p> <p>Here is the definition (with some improvements to notation):</p> <p></p> <p>It is purported that the VAMP is a better estimate for short-term price prediction, as opposed to the mid-price itself. Let's use the same dataset (here, the sample size is about 6000 for 1hour of orderbook data, reduced to conform to Github LFS restrictions; we encourage you to use your own data archives. The conclusions, however, are fairly typical.)</p> <p>Here is the data-loading and imports: <pre><code>from quantpylib.utilities.general import load_pickle \n\n(\n    ob_timestamps,\n    bids,\n    asks,\n    mids,\n    trades\n) = load_pickle(\"hft_data\")\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pprint import pprint\nfrom quantpylib.hft.alpha import EVENT_CLOCK, EVENT_LOB, EVENT_TRADE\nfrom quantpylib.hft.alpha import Model\nfrom quantpylib.hft.features import sample_vamp\n</code></pre> This time, we would like to extend the <code>Model</code> class: <pre><code>class VAMP(Model):\n\n    #def compute_clock_features ...\n    #def compute_lob_features ...\n    #def compute_trade_features ...\n\n    def event_estimator(\n        self,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        running_event_ids,running_type_ids,**kwargs\n    ):\n        pass        \n</code></pre> Here, instead of pre-processing the order book VAMP features, we will just compute it on the fly. Let us compare four different estimators, mid, and VAMP for notional value at 200, 1000 and 3000 - here the dataset is actually from a 'thinner' book taken from Hyperliquid's spot pair <code>PURR/USDC</code>. The notional value should be adjusted w.r.t to the actual exchange volume - a VAMP of 1000 for <code>BTCUSDT</code> on Binance would likely just be the mid price itself, since only the bba is involved.</p> <p>We are going to use <code>sample_vamp</code> from <code>quantpylib.hft.features</code> - the implementation is rather simple: <pre><code>def volume_weighted_price(ob_levels, notional):\n    cumvol = 0\n    wsum = 0\n    for price, volume in ob_levels:\n        if cumvol + volume &gt;= notional:\n            volume = notional - cumvol\n        wsum += price * volume\n        cumvol += volume\n        if cumvol &gt;= notional:\n            break\n    return wsum / notional\n\ndef sample_vamp(bids, asks, notional):\n    P_b = volume_weighted_price(bids, notional)\n    P_a = volume_weighted_price(asks, notional)\n    return (P_b + P_a) / 2\n</code></pre> Our <code>event_estimator</code> should just return a dictionary of valid estimates. We are only making estimates on order book events. <pre><code>    def event_estimator(\n        self,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        running_event_ids,running_type_ids,**kwargs\n    ):\n        estimates = {}\n        if event_type == EVENT_LOB:\n            mid = kwargs['mid']\n            estimates[\"mid\"] = mid\n\n            bids,asks = ob_bids[type_id],ob_asks[type_id]\n            vamp200 = sample_vamp(bids,asks,notional=200)\n            vamp1000 = sample_vamp(bids,asks,notional=1000)\n            vamp3000 = sample_vamp(bids,asks,notional=3000)\n            estimates['vamp200'] = vamp200\n            estimates['vamp1000'] = vamp1000\n            estimates['vamp3000'] = vamp3000\n        return estimates\n</code></pre> Running it is simple <pre><code>alpha = VAMP(\n    ob_timestamps=ob_timestamps,\n    ob_bids=bids,\n    ob_asks=asks,\n    ob_mids=mids,\n    trade_buffer=trades,\n)\nalpha.run_estimator()\n</code></pre> Since our case study involve statistical estimators, in particular fair price estimators, we can use <code>df_fairprice</code> to get some useful dataframes and plots. <pre><code>pprint(alpha.df_fairprices(plot=True))\n</code></pre> For example, we obtain plots of the difference <code>price_{t + x} - estimator_t</code> for different <code>x</code> intervals. We can see that at short distances: </p> <p>the <code>mid</code> estimator is best and thinnest in spread. That is, the <code>mid</code> price is probably a good estimator of the mid price in the next second. This is less clear, say thirty seconds out: </p> <p>In fact the <code>df_fairprices</code> method prints out some useful statistics: <pre><code>({'t1':\n                  mid       vamp200      vamp1000      vamp3000\nMSE     1.263283e-09  1.318690e-09  1.593077e-09  2.173601e-09\nMAD     7.467348e-06  1.055727e-05  1.837794e-05  3.000805e-05\nQ3      5.000000e-06  9.375000e-06  2.276000e-05  3.833000e-05\nQ1      0.000000e+00  0.000000e+00  4.085000e-06  1.375750e-05\nMedian  0.000000e+00  3.150000e-06  1.047000e-05  2.525750e-05,\n  't5':\n                    mid       vamp200      vamp1000      vamp3000\nMSE     1.059491e-08  1.057470e-08  1.039111e-08  1.054808e-08\nMAD     3.701356e-05  3.820434e-05  4.156697e-05  4.989065e-05\nQ3      4.000000e-05  3.860000e-05  4.199625e-05  4.848083e-05\nQ1      0.000000e+00  2.925000e-06  6.315000e-06  1.808167e-05\nMedian  1.000000e-05  1.062500e-05  1.850500e-05  3.192917e-05,\n  't15':\n                    mid       vamp200      vamp1000      vamp3000\nMSE     2.972277e-08  2.954644e-08  2.893512e-08  2.886935e-08\nMAD     8.059360e-05  8.102625e-05  8.183297e-05  8.628753e-05\nQ3      8.000000e-05  8.000000e-05  7.799500e-05  7.926542e-05\nQ1      1.000000e-05  1.000000e-05  1.402500e-05  2.502417e-05\nMedian  3.500000e-05  3.562500e-05  3.755750e-05  4.391167e-05,\n  't30':\n                    mid       vamp200      vamp1000      vamp3000\nMSE     5.757793e-08  5.727437e-08  5.650527e-08  5.595095e-08\nMAD     1.264484e-04  1.272426e-04  1.283955e-04  1.310334e-04\nQ3      1.200000e-04  1.200000e-04  1.175287e-04  1.153988e-04\nQ1      2.000000e-05  2.000000e-05  2.407625e-05  3.529458e-05\nMedian  5.500000e-05  5.625000e-05  5.992500e-05  6.022833e-05,\n  't60':\n                    mid       vamp200      vamp1000      vamp3000\nMSE     1.007904e-07  1.000718e-07  9.870321e-08  9.699616e-08\nMAD     1.961512e-04  1.959267e-04  1.962974e-04  1.968203e-04\nQ3      2.400000e-04  2.439063e-04  2.441700e-04  2.331175e-04\nQ1      3.500000e-05  3.500000e-05  3.868875e-05  4.891542e-05\nMedian  1.050000e-04  1.050000e-04  1.085200e-04  1.075792e-04}, ...)\n</code></pre> One second out, the <code>mid</code> estimator has the lowest mean-squared error. From five seconds out and further, the <code>vamp*</code> estimators have lower mean-squared errors due to orderbook imbalance being realized.</p> <p>Another interesting feature that I have noticed reflected in this dataset and larger datasets, if not somewhat anecdotal, is that as the time interval increases, the notional value of the <code>vamp</code> estimator increases up to certain depths before worsening sharply. This is quite intuitive - longer term price movements take into account deeper structural imbalance; but as we traverse into deeper levels, we start picking up more noise and spoof orders. </p>"},{"location":"hft/hft/#ti-demo","title":"TI-Demo","text":"<p>Not all estimators are fair price estimators - in the same paper - another feature studied was the trade imbalance (TI) estimator. It can be a feature in fair price estimation, but a mathematical model needs to be proposed to make fair price estimates from a TI estimate. The idea is simple; short term lop-sided trading on the bid or ask side are likely to lead to further price moves in the same direction. Here is the definition from the paper:</p> <p></p> <p>A positive correlation is assumed between the trade imbalance and mid price changes, to reflect demand for the asset when there is trend of market bids. The gamma weight decay gives more weightage to recent trades.</p> <p>However, this formula is unsatisfactory for a number of general purposes. First, if there is consensus that information decay exists; then there serves no specific reason as to why such decay should not be applied to higher resolutions within each aggregated interval. This may be a trivial concern for second intervals. A bigger issue is that the trade imbalance would be jumpy, or inestimable in the case of illiquid markets where trades occur at infrequent intervals. For example, one buy two minutes ago, and then one sell a minute later would give trade imbalance figures: -1,1 respectively. One may attend to this by widening the interval at which trades are aggregated - for which then the issue waved trivial earlier is no longer so. Imagine a aggregation interval of five minutes: a buy and sell order in the most recent interval 4.59m ago and another 0.01m ago contain significantly different amount of priced-in 'information' to market participants.</p> <p>That there should be a decay is almost undisputed in finance. Nature of decay, and whether the decay should be w.r.t to trade arrivals in numbers, time distance or some other axis is philosophical. We propose a generalized estimator:</p> <p></p> <p>The aformentioned TI formula would be a specific instance of this generalization, where <code>n = number of trades within x</code> seconds, and omega is a piecewise constant decay function.</p> <p>Again, let's load the same dataset: <pre><code>from quantpylib.utilities.general import load_pickle \n\n(\n    ob_timestamps,\n    bids,\n    asks,\n    mids,\n    trades\n) = load_pickle(\"hft_data\")\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pprint import pprint\nfrom quantpylib.hft.alpha import EVENT_CLOCK, EVENT_LOB, EVENT_TRADE\nfrom quantpylib.hft.alpha import Model\nfrom quantpylib.hft.utils import rolling_apply\nfrom quantpylib.hft.features import trade_imbalance\n\nclass TI(Model):\n\n    def compute_trade_features(self,trade_buffer):  \n        pass\n\n    def event_estimator(\n        self,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        running_event_ids,running_type_ids,**kwargs\n    ):\n        pass\n</code></pre> This time, the feature is trade-related. So we will pre-process the TI estimates and then make estimates on each <code>EVENT_TRADE</code>. We can do this using the <code>quantpylib.hft.utils</code>'s <code>rolling_apply</code> function that does what the name-suggests, on rolling numpy array samples: <pre><code>    def compute_trade_features(self,trade_buffer):  \n        tis = rolling_apply(a=trade_buffer,window=20,func=trade_imbalance)\n        return {\n            \"TI\":tis\n        }\n</code></pre> The trade-imbalance from <code>quantpylib.hft.features</code> has implementation like this: <pre><code>def trade_imbalance(\n    trades, \n    decay_function=lambda sample: exponential_weights(arr=sample,unique_values=True,normalize=True), \n    window_n=None, window_s=None, T=None\n):\n    if T is not None: trades = trades[trades[:,0] &lt;= T] \n    if sum(1 for param in [window_n,window_s] if param is not None) &gt; 1: \n        raise ValueError(\"sample window can only be defined by one of window_n, window_s\") \n    if window_n is not None :  trades = trades[-window_n:]\n    if T is None: T = trades[-1,0]\n    if window_s is not None: trades = trades = trades[trades[:, 0] &gt;= (T - window_s*1000)]\n\n    #trade = ts, price, size, dir \n    if len(trades) == 0: return 0 \n    weights = decay_function(T - trades[:, 0])\n    signed_volume = trades[:, 2] * trades[:, 3]\n    return np.sum(weights * signed_volume) / np.sum(weights * trades[:, 2])\n</code></pre> refer to implementation of <code>exponential_weights</code> in the repository code; or use your imagination. We just used the last twenty trade events, but of course this is up to you. Making estimates are simple, we just echo this at the correct event: <pre><code>    def event_estimator(\n        self,ts,event_type,event_id,type_id,\n        trade_buffer,ob_timestamps,ob_bids,ob_asks,ob_mids,features,\n        running_event_ids,running_type_ids,**kwargs\n    ):\n        estimates = {}\n        if event_type == EVENT_TRADE:\n            estimates['TI'] = features[EVENT_TRADE][\"TI\"][type_id]\n        return estimates\n</code></pre> Running it is even simpler <pre><code>alpha = TI(\n    ob_timestamps=ob_timestamps,\n    ob_bids=bids,\n    ob_asks=asks,\n    ob_mids=mids,\n    trade_buffer=trades,\n)\nalpha.run_estimator()\n</code></pre> In this case TI just ranges from -1 to 1 - it is not yet a fair price estimator. But we can ask for useful dataframes: <pre><code>variable_df = alpha.df_estimators(include_forwards=True)\n</code></pre> which looks like this: <pre><code>                     TI        t0        t1        t5       t15       t30       t60\n1722092423332 -1.000000  0.202500  0.202340  0.202275  0.202275  0.202205  0.202255\n1722092423534 -0.951384  0.202500  0.202345  0.202275  0.202275  0.202205  0.202255\n1722092424342 -0.903858  0.202340  0.202305  0.202275  0.202275  0.202205  0.202255\n1722092428167 -0.869708  0.202275  0.202275  0.202275  0.202275  0.202205  0.202250\n1722092447111 -0.730021  0.202335  0.202305  0.202205  0.202245  0.202265  0.202315\n...                 ...       ...       ...       ...       ...       ...       ...\n1722095930541  0.784021  0.200680  0.200705  0.200740  0.200655  0.200775  0.200730\n1722095933658  0.847519  0.200705  0.200685  0.200735  0.200635  0.200830  0.200710\n1722095934190  0.805306  0.200755  0.200740  0.200730  0.200635  0.200830  0.200690\n1722095938015  0.821895  0.200735  0.200730  0.200715  0.200470  0.200865  0.200730\n1722095939023  0.696006  0.200730  0.200730  0.200675  0.200465  0.200900  0.200730\n</code></pre> for each TI estimate at each trade event, we have preloaded a dataframe with the instantaneous mid price, and mid prices up to sixty seconds out.</p> <p>Let's propose a fair price model using this TI figures. The model we choose should be determined by the average holding period - obviously if we are buying and selling out the position within one-second, the price in sixty seconds is less relevant.</p> <p>We shall try a least-squares, zero-intercept simple regression model, with the help of our regression library <code>quantpylib.simulator.models.GeneticRegression</code>. This allows us to do things like <pre><code>from quantpylib.simulator.models import GeneticRegression\nregmodel = GeneticRegression(\n    formula=\"div(minus(t1,t0),t0) ~ TI\",\n    df=variable_df,\n    intercept=False\n)\nres = regmodel.ols()\nregmodel.plot()\nprint(res.summary())\n</code></pre> We get a bunch of useful plots - here is one:</p> <p></p> <p>with summary <pre><code>                                 OLS Regression Results\n=======================================================================================\nDep. Variable:                     b0   R-squared (uncentered):                   0.051\nModel:                            OLS   Adj. R-squared (uncentered):              0.050\nMethod:                 Least Squares   F-statistic:                              44.43\nDate:                Sat, 03 Aug 2024   Prob (F-statistic):                    4.81e-11\nTime:                        18:56:51   Log-Likelihood:                          5116.2\nNo. Observations:                 825   AIC:                                 -1.023e+04\nDf Residuals:                     824   BIC:                                 -1.023e+04\nDf Model:                           1\nCovariance Type:            nonrobust\n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nb1             0.0002   2.59e-05      6.666      0.000       0.000       0.000\n==============================================================================\nOmnibus:                      898.172   Durbin-Watson:                   0.984\nProb(Omnibus):                  0.000   Jarque-Bera (JB):           163861.949\nSkew:                          -4.759   Prob(JB):                         0.00\nKurtosis:                      71.383   Cond. No.                         1.00\n==============================================================================\n</code></pre> Statistically significant it says. Perhaps we would like to zoom out more and see some aggregated features.  The <code>GeneticRegression.ols</code> allows us to bin data into blocks, and then aggregate  the axis values. We will take defaults: <pre><code>from quantpylib.simulator.models import Bin\nregmodel.ols(bins=50,bin_block=\"b1\",binned_by=Bin.WIDTH)\nregmodel.plot()\n</code></pre> and we see:</p> <p></p> <p>Here the sample size is 825. Let's do the regression on some 448228 trade data samples (collect your own data boys and girls), and then binned, regressed and plotted:</p> <p></p> <p>When more data samples are collected, here the trend is obvious. However, we can see that the residuals are non-random. The suggested relationships appears to be curvilinear. Perhaps a higher order polynomial (cubic?). We stop here, fit your own data! The tools have been provided. On the same 448228 size dataset, we try a longer prediction <code>div(minus(t30,t0),t0) ~ TI</code> and get </p> <p></p> <p>the result is similar.</p>"},{"location":"hft/hft/#limit-order-book","title":"Limit-Order Book","text":"<p>You may want to use the orderbook with your own data stream. Here is an example of how you can do it (speudo-code) <pre><code>from quantpylib.hft.lob import LOB \nob = LOB(depth=depth,buffer_size=buffer_size)   \n\nasync def on_stream(msg):\n    ob.update(msg['ts'],msg['b'],msg['a'],is_snapshot=True / False)\n</code></pre></p> <p>A limit order book object is only interesting with data already in it. Although we can create a <code>LOB</code> object directly, for demonstration - we are going to obtain it from a market data stream. Fortunately, our <code>quantpylib.gateway.executor</code> library has a <code>l2_book_mirror</code> method that returns a live orderbook object.</p> <p>We will get data from hyperliquid through the gateway object: <pre><code>import asyncio\n\nfrom quantpylib.gateway.master import Gateway\n\ngateway = Gateway(config_keys={\"hyperliquid\":{}})\n\nasync def ob_handler(ob):\n    print(ob.get_mid(), ob.get_spread())\n    return\n\nasync def main():\n\n    await gateway.init_clients()\n    ob_model = await gateway.executor.l2_book_mirror(\n        ticker=\"SOL\",\n        depth=20,\n        buffer_size=200,\n        as_dict=False,\n        on_update=ob_handler,\n        exc='hyperliquid'\n    )\n\n    await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> This maps to the <code>l2_book_mirror</code> method in <code>quantpylib.wrappers.hyperliquid</code> wrapper, and <code>as_dict=False</code> specifices we want a <code>quantpylib.hft.lob.LOB</code> object.</p> <p>We can now use the utility functions of the orderbook class. While we are sleeping, the <code>ob_handler</code> prints out... <pre><code>182.04500000000002 0.010000000000019327\n182.04500000000002 0.010000000000019327\n182.04500000000002 0.010000000000019327\n182.05 0.020000000000010232\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n</code></pre> and so on. We do not have to call the <code>LOB.update</code> method here, since the mirror method takes care of the state of the orderbook on data stream. Let's take a look at some of the utility functions after sleeping: <pre><code>    print(ob_model.get_mid(),ob_model.get_vamp(notional=3000))\n    print(ob_model.get_vol(exp=True))\n    print(ob_model.buffer_len())\n</code></pre> and we get  <pre><code>182.085 182.06296258333333\n0.018219811123247037\n104\n</code></pre> We get different figures for mid-price, fair-price estimator using quote volume imbalance, volatility and length of running buffer. Of course, these methods have additional parameters, such as the sample size used to compute volatility - we refer to documentation.</p>"},{"location":"hft/hft/#trades","title":"Trades","text":"<p>Like the <code>LOB</code> object, <code>Trades</code> is a trade buffer stream. Using the data streamed in, we may get useful information such as trade imbalance.</p> <p>Filling in the trade buffer is extremely easy, let's get the hyperliquid BTC trade stream: <pre><code>import asyncio\n\nfrom quantpylib.hft.trades import Trades\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def main():\n    ticker = \"BTC\"\n\n    hpl = Hyperliquid()\n    await hpl.init_client()\n    trades = Trades(buffer_size=1_000_000)\n    async def trade_handler(trade):\n        #trade is (time_ms, price, size, dir)\n        #&gt;&gt;&gt; (1722177301662, 67749.0, 0.0003, -1)\n        trades.append(trade=trade) \n\n    await hpl.trades_subscribe(ticker=ticker,handler=trade_handler)\n    await asyncio.sleep(1000)\n</code></pre> That's pretty much it - from here the buffer is being populated, and we can  compute figures such as trade imbalance and so on.</p>"},{"location":"hft/hft/#statistics","title":"Statistics","text":"<p>This is our statistical library for hft modelling. It is designed to work seamlessly with the data structures from our internal state representations, such as the orderbook <code>LOB</code> and trades <code>Trades</code>, but will work just as well with external data.</p> <p>For instance, we may be interested in computing orderbook liquidity - to do this we fit an exponential decay model for the hit and -lifted amounts against the distance to mid price. This figure is directly related to the Poisson intensity that is often taken as a model for trade arrivals.</p> <p>Let's stream both the l2-book data and the trades occuring: <pre><code>import asyncio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom quantpylib.hft.lob import LOB\nfrom quantpylib.hft.trades import Trades\nfrom quantpylib.hft.stats import intensity\n\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def main():\n    ticker = \"BTC\"\n\n    hpl = Hyperliquid()\n    await hpl.init_client()\n\n    ob = await hpl.l2_book_mirror(\n        ticker=ticker,\n        depth=20,\n        buffer_size=1_000_000,\n        as_dict=False\n    )\n    trades = Trades(buffer_size=1_000_000)\n    async def trade_handler(trade):\n        trades.append(trade=trade)\n\n    await hpl.trades_subscribe(ticker=ticker,handler=trade_handler)\n    await asyncio.sleep(60 * 20)\n\n    #code goes here...\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> After twenty minutes, we get some two thousand data points and four hundred trades. Let's fit the exponential function using <code>quantpylib.hft.stats.intensity</code>, and make some plots: <pre><code>    print(ob.buffer_len()) #2051\n    print(trades.buffer_len()) #408\n\n    params = intensity(\n        lob_timestamps=ob.get_ts_buffer(),\n        lob_mids=ob.get_mids_buffer(),\n        trades=trades.get_buffer(),\n    )   \n\n    alpha = params.get(\"alpha\")\n    kappa = params.get(\"kappa\")\n    levels = params.get(\"levels\")\n    agg_amounts = params.get(\"amounts\")\n    fitted_values = alpha * np.exp(-kappa * levels)\n\n    # Plot the actual and fitted\n    plt.figure(figsize=(10, 6))\n    plt.plot(levels, agg_amounts, 'o', label='Aggregated Amounts', color='red')\n    plt.plot(levels, fitted_values, '-', label=f'Fitted Model: $A(d) = {alpha:.2f} e^{{-{kappa:.2f} d}}$', color='blue')\n    plt.xlabel('Distance from Mid-Price (d)')\n    plt.ylabel('Aggregated Trade Amount (A(d))')\n    plt.title('Exponential Decay Model Fit to Aggregated Trade Amounts')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n</code></pre> Obviously, the sample size is rather small, but we will carry on for the sake of demonstration. Here is the decay function:</p> <p></p> <p>Values such as kappa are often used as measures of orderbook liquidity. Higher values of kappa indicate strong decay, hence greater trading near the mid-price. Lower values indicate weak decay - market order sizes often wipe out a few levels in the orderbook and have strong  price impact. See Hummingbot implementation of computing trade intensity. In stoikov-avellaneda market making formula, kappa appears as term in optimal spread; see Hummingbot avellaneda_market_making.pyx: <pre><code>self._optimal_spread = self.gamma * vol * time_left_fraction\nself._optimal_spread += 2 * Decimal(1 + self.gamma / self._kappa).ln() / self.gamma\n</code></pre> Optimal spread has an additive factor of log(1 + c/kappa), where smaller values of kappa encourages wider maker orders (although I am pretty sure this should be dollar-normalized first).</p>"},{"location":"hft/hft/#hftlob","title":"hft.lob","text":""},{"location":"hft/hft/#hfttrades","title":"hft.trades","text":""},{"location":"hft/hft/#hftfeatures","title":"hft.features","text":""},{"location":"hft/hft/#hftstats","title":"hft.stats","text":""},{"location":"hft/lob/","title":"quantpylib.hft.lob","text":""},{"location":"hft/lob/#quantpylib.hft.lob.LOB","title":"<code>LOB</code>","text":""},{"location":"hft/lob/#quantpylib.hft.lob.LOB.__init__","title":"<code>__init__(timestamp=time.time() * 1000, bids=None, asks=None, depth=100, buffer_size=100)</code>","text":"<p>A class representing a Limit Order Book (LOB) for financial trading.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The initial timestamp in milliseconds. Defaults to current time.</p> <code>time() * 1000</code> <code>bids</code> <code>ndarray</code> <p>Initial bid array. Defaults to None.</p> <code>None</code> <code>asks</code> <code>ndarray</code> <p>Initial ask array. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The maximum depth of the order book. Defaults to 100.</p> <code>100</code> <code>buffer_size</code> <code>int</code> <p>The size of the buffers for storing historical data. Defaults to 100.</p> <code>100</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.as_dict","title":"<code>as_dict()</code>","text":"<p>Represent the current state of the order book as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The current timestamp, bids, and asks.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.as_tuple","title":"<code>as_tuple()</code>","text":"<p>Represent the current state of the order book as a tuple.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The current timestamp, bids, and asks.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.buffer_len","title":"<code>buffer_len()</code>","text":"<p>Get the length of the buffers.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the buffers.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.clear_buffer","title":"<code>clear_buffer()</code>","text":"<p>Clear all historical data buffers.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_asks_buffer","title":"<code>get_asks_buffer()</code>","text":"<p>Get the buffer of three-dimensional (time,price,size) ask arrays.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of ask arrays in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bids_buffer","title":"<code>get_bids_buffer()</code>","text":"<p>Get the buffer of three-dimensional (time,price,size) bid arrays.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of bid arrays in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_mid","title":"<code>get_mid()</code>","text":"<p>Get the mid price of the current order book.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The mid price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_mids_buffer","title":"<code>get_mids_buffer()</code>","text":"<p>Get the buffer of one-dimensional mid prices.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of mid prices in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_spread","title":"<code>get_spread()</code>","text":"<p>Get the spread of the current top of book.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The spread.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_ts_buffer","title":"<code>get_ts_buffer()</code>","text":"<p>Get the buffer of one-dimensional timestamps.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of timestamps in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_vamp","title":"<code>get_vamp(notional)</code>","text":"<p>Calculate the volume-adjusted mid price.</p> <p>Parameters:</p> Name Type Description Default <code>notional</code> <code>float</code> <p>The notional amount for the calculation.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The volume-adjusted mid price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_vol","title":"<code>get_vol(n=None, absolute=True, exp=False)</code>","text":"<p>Calculate the volatility of the mid prices over the last <code>n</code> updates. Excludes zero differences.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of updates to consider. Defaults to the length of the mids buffer.</p> <code>None</code> <code>absolute</code> <code>bool</code> <p>Whether to return absolute volatility. Defaults to True.</p> <code>True</code> <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated volatility.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.load_buffer","title":"<code>load_buffer(timestamps_buffer, bids_buffer, asks_buffer, mids_buffer)</code>  <code>staticmethod</code>","text":"<p>Load a Limit Order Book (LOB) from existing buffers.</p> <p>Parameters:</p> Name Type Description Default <code>timestamps_buffer</code> <code>RingBuffer</code> <p>Buffer containing timestamps.</p> required <code>bids_buffer</code> <code>RingBuffer</code> <p>Buffer containing bid arrays.</p> required <code>asks_buffer</code> <code>RingBuffer</code> <p>Buffer containing ask arrays.</p> required <code>mids_buffer</code> <code>RingBuffer</code> <p>Buffer containing mid prices.</p> required <p>Returns:</p> Name Type Description <code>LOB</code> <p>The loaded Limit Order Book.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.load_numpy_arr","title":"<code>load_numpy_arr(timestamps_array, bids_array, asks_array, mids_array)</code>  <code>staticmethod</code>","text":"<p>Load a Limit Order Book (LOB) from existing numpy arrays. Buffer attributes  are instantiated exactly equal to the length of arrays passed in.</p> <p>Parameters:</p> Name Type Description Default <code>timestamps_array</code> <code>ndarray</code> <p>Array containing timestamps.</p> required <code>bids_array</code> <code>ndarray</code> <p>Array containing bid arrays.</p> required <code>asks_array</code> <code>ndarray</code> <p>Array containing ask arrays.</p> required <code>mids_array</code> <code>ndarray</code> <p>Array containing mid prices.</p> required <p>Returns:</p> Name Type Description <code>LOB</code> <p>The loaded Limit Order Book.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.update","title":"<code>update(timestamp, bids, asks, is_snapshot)</code>","text":"<p>Update the order book with new bid and ask data.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The current timestamp in milliseconds.</p> required <code>bids</code> <code>ndarray</code> <p>The new bid array.</p> required <code>asks</code> <code>ndarray</code> <p>The new ask array.</p> required <code>is_snapshot</code> <code>bool</code> <p>Whether the update is a snapshot (true) or an incremental update (false).</p> required"},{"location":"hft/lob/#quantpylib.hft.lob.a_in_b","title":"<code>a_in_b(a, b)</code>","text":"<p>Check if elements of array <code>a</code> are in array <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The array of elements to check.</p> required <code>b</code> <code>ndarray</code> <p>The array to check against.</p> required <p>Returns:</p> Type Description <p>np.ndarray: A boolean array indicating if elements of <code>a</code> are in <code>b</code>.</p>"},{"location":"hft/oms/","title":"quantpylib.hft.oms","text":""},{"location":"hft/oms/#quantpylib.hft.oms.OMS","title":"<code>OMS</code>","text":""},{"location":"hft/oms/#quantpylib.hft.oms.OMS.__init__","title":"<code>__init__(gateway, exchanges=None, pending_timeout=5000)</code>","text":"<p>Intialize the Order Management System object.</p> <p>Parameters:</p> Name Type Description Default <code>gateway</code> <code>Gateway</code> <p>Initialized gateway object.</p> required <code>exchanges</code> <code>list</code> <p>The list of exchanges to subscribe to. If None, use the clients in the gateway.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.cancel_order","title":"<code>cancel_order(exc, ticker=None, oid=None, cloid=None)</code>  <code>async</code>","text":"<p>Cancel an order by order id or client order id. If both oid and cloid are None, cancel all open orders for given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker. Defaults to None.</p> <code>None</code> <code>oid</code> <code>str</code> <p>The order id. Defaults to None.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>The client order id. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.cloid_query","title":"<code>cloid_query(exc, cloid)</code>","text":"<p>Query order information by client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>cloid</code> <code>str</code> <p>The client order id.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_lot_precision","title":"<code>common_lot_precision(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the lot precision for trading on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_min_notional","title":"<code>common_min_notional(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the minimum notional trade on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_price_precision","title":"<code>common_price_precision(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the price precision for trading on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.contract_specs","title":"<code>contract_specs(exc, ticker)</code>","text":"<p>Get the contract specifications for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.get_position","title":"<code>get_position(exc, ticker)</code>","text":"<p>Get the position for a given exchange and ticker. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.hedge_order","title":"<code>hedge_order(maker_order, hedge_order)</code>  <code>async</code>","text":"<p>Place a maker-taker order. The maker order is the order that is being hedged. The taker order is the order that hedges the maker order - taker order has no <code>amount</code> specified, size executed is contingent on the size of maker fills.  Each order are dictionaries - and are passed as named arguments (**order) into the gateway  as per the <code>quantpylib.gateway.executor.limit_order</code> and <code>quantpylib.gateway.executor.market_order</code> methods respectively.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.init","title":"<code>init()</code>  <code>async</code>","text":"<p>Initialize the OMS object with information such as exchange contract trading specifications and metadata.  To be called after the OMS has been created.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.lagged_price","title":"<code>lagged_price(exc, ticker)</code>","text":"<p>Get the lagged price for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.limit_order","title":"<code>limit_order(round_to_specs=False, **kwargs)</code>  <code>async</code>","text":"<p>Place a limit order. If round_to_specs is True, round the order amount to the lot precision. Updates the orders page maintained by the OMS with a PENDING status.</p> <p>Parameters:</p> Name Type Description Default <code>round_to_specs</code> <code>bool</code> <p>Round the order amount to the lot precision. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>The order parameters. Parameter usage is same as the <code>quantpylib.gateway.executor.limit_order</code> method.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.lot_precision","title":"<code>lot_precision(exc, ticker)</code>","text":"<p>Get the lot precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.market_order","title":"<code>market_order(round_to_specs=False, **kwargs)</code>  <code>async</code>","text":"<p>Place a market order. If round_to_specs is True, round the order amount to the lot precision. Updates the orders page maintained by the OMS with a PENDING status.</p> <p>Parameters:</p> Name Type Description Default <code>round_to_specs</code> <code>bool</code> <p>Round the order amount to the lot precision. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>The order parameters. Parameter usage is same as the <code>quantpylib.gateway.executor.market_order</code> method.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.min_notional","title":"<code>min_notional(exc, ticker)</code>","text":"<p>Get the minimum notional required to trade for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.oid_query","title":"<code>oid_query(exc, oid)</code>","text":"<p>Query order information by order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>oid</code> <code>str</code> <p>The order id.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.order_delta_hedge","title":"<code>order_delta_hedge()</code>","text":"<p>Hedge order logic. Fill sizes on maker exchange that are not compatible with trading rules on taker exchange are hedged as much as possible, and size differences are submitted to a hedge balance that waits for future arriving fills to be hedged.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_get","title":"<code>orders_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get the orders for a given exchange. Uses HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_get_all","title":"<code>orders_get_all()</code>  <code>async</code>","text":"<p>Get the orders for all exchanges.Uses HTTP request.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_mirror","title":"<code>orders_mirror(exc, on_update=None, on_delta=None)</code>  <code>async</code>","text":"<p>Mirror the orders for a given exchange. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>on_update</code> <code>coroutine</code> <p>The update handler receives order page snapshots. Defaults to None.</p> <code>None</code> <code>on_delta</code> <code>coroutine</code> <p>The delta handler receives order page changes. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_peek","title":"<code>orders_peek(exc)</code>","text":"<p>Return the <code>quantpylib.standards.portfolio.Orders</code> object maintained for a given exchange.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get","title":"<code>positions_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get the positions for a given exchange. Uses HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get_all","title":"<code>positions_get_all()</code>  <code>async</code>","text":"<p>Get the positions for all exchanges. Uses HTTP request.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of positions for all exchanges.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_mirror","title":"<code>positions_mirror(exc, on_update=None, on_delta=None)</code>  <code>async</code>","text":"<p>Mirror the positions for a given exchange. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>on_update</code> <code>coroutine</code> <p>The update handler. Defaults to None.</p> <code>None</code> <code>on_delta</code> <code>coroutine</code> <p>The delta handler. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_peek","title":"<code>positions_peek(exc)</code>","text":"<p>Return the <code>quantpylib.standards.portfolio.Positions</code> object maintained for a given exchange.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.price_precision","title":"<code>price_precision(exc, ticker)</code>","text":"<p>Get the price precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.rand_cloid","title":"<code>rand_cloid(exc, **kwargs)</code>","text":"<p>Generate a client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.rounded_lots","title":"<code>rounded_lots(exc, ticker, amount, **kwargs)</code>","text":"<p>Round an amount to the lot precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>amount</code> <code>Decimal</code> <p>The amount to round.</p> required"},{"location":"hft/stats/","title":"quantpylib.hft.stats","text":""},{"location":"hft/stats/#quantpylib.hft.stats.intensity","title":"<code>intensity(lob_timestamps, lob_mids, trades, alpha_0=0, kappa_0=0)</code>","text":"<p>Calculate the trading intensity in a Limit Order Boosk.</p> <p>The function takes the historical data of the LOB timestamps, mid prices, and trades,  then calculates the liquidity of the orderbook by fitting an exponential decay model for A = alpha * exp ( - kappa * delta ), where A is the trade amount, alpha is scale, kappa is decay rate, and delta is price distance to mid. Large values of kappa implies is related with higher liquidity and tighter spreads.</p> <p>Parameters:</p> Name Type Description Default <code>lob_timestamps</code> <code>ndarray</code> <p>Array of LOB timestamps.</p> required <code>lob_mids</code> <code>ndarray</code> <p>Array of LOB mid prices.</p> required <code>trades</code> <code>ndarray</code> <p>Array of trade data with columns for timestamp, price, and amount.</p> required <code>alpha_0</code> <code>float</code> <p>Initial guess for the alpha parameter in the exponential decay model. Defaults to 0.</p> <code>0</code> <code>kappa_0</code> <code>float</code> <p>Initial guess for the kappa parameter in the exponential decay model. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the estimated alpha and kappa parameters. Returns (None, None) if no valid data is found.</p> Algorithm <ol> <li>Initialize arrays to store quote and trade events.</li> <li>Populate quote events with timestamps and mid prices from the LOB.</li> <li>Populate trade events with timestamps, prices, and amounts from the trade data.</li> <li>Combine quote and trade events, and sort them by timestamp.</li> <li>Calculate the distance between trade prices and the last observed mid price from the quotes.</li> <li>Aggregate the trade amounts by the calculated distance levels.</li> <li>Fit an exponential decay model to the aggregated data to estimate the alpha and kappa parameters.</li> </ol> Notes <p>see Hummingbot implementation.</p>"},{"location":"hft/trades/","title":"quantpylib.hft.trades","text":""},{"location":"hft/trades/#quantpylib.hft.trades.Trades","title":"<code>Trades</code>","text":""},{"location":"hft/trades/#quantpylib.hft.trades.Trades.__init__","title":"<code>__init__(buffer_size=100)</code>","text":"<p>A class representing a buffer for storing trade logs with attributes for timestamp, price, size, and direction.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>The size of the buffer for storing trades. Defaults to 100.</p> <code>100</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.append","title":"<code>append(trade=None, ts=None, price=None, size=None, dir=None)</code>","text":"<p>Append a new trade to the buffer. A trade is specified by the arguments ts,price,size,dir or with the 4-tuple (ts,price,size,dir).</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>int</code> <p>The timestamp of the trade. Defaults to None.</p> <code>None</code> <code>price</code> <code>float</code> <p>The price of the trade. Defaults to None.</p> <code>None</code> <code>size</code> <code>float</code> <p>The size of the trade. Defaults to None.</p> <code>None</code> <code>dir</code> <code>int</code> <p>The direction of the trade, 1 or -1. Defaults to None.</p> <code>None</code> <code>trade</code> <code>tuple</code> <p>A tuple representing the trade (ts,price,size,dir).</p> <code>None</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.buffer_len","title":"<code>buffer_len()</code>","text":"<p>Get the length of the trade buffer.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the trade buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.clear_buffer","title":"<code>clear_buffer()</code>","text":"<p>Clear the trade buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_buffer","title":"<code>get_buffer()</code>","text":"<p>Get the current contents of the trade buffer.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of trades in the buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.load_buffer","title":"<code>load_buffer(trade_buffer)</code>  <code>staticmethod</code>","text":"<p>Load a Trades object from an existing buffer.</p> <p>Parameters:</p> Name Type Description Default <code>trade_buffer</code> <code>RingBuffer</code> <p>An existing buffer containing trade logs.</p> required <p>Returns:</p> Name Type Description <code>Trades</code> <p>The loaded Trades object.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.load_numpy_arr","title":"<code>load_numpy_arr(trades_array)</code>  <code>staticmethod</code>","text":"<p>Load a Trades object from existing numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>trades_array</code> <code>ndarray</code> <p>Array containing trade logs with each row containing </p> required <p>Returns:</p> Name Type Description <code>Trades</code> <p>The loaded Trades object.</p>"},{"location":"hft/utils/","title":"quantpylib.hft.utils","text":""},{"location":"hft/utils/#quantpylib.hft.utils.exponential_weights","title":"<code>exponential_weights(arr, unique_values=False, normalize=False)</code>","text":"<p>Generates exponential weights for an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray or list</code> <p>The input array.</p> required <code>unique_values</code> <code>bool</code> <p>If True, weights are generated based on the number of unique values in the array.          Duplicate values share the same weight.</p> <code>False</code> <code>normalize</code> <code>bool</code> <p>If True, the weights are normalized to sum to 1.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of exponential weights.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_ema","title":"<code>rolling_ema(arr, n)</code>","text":"<p>Calculate the rolling Exponential Moving Average (EMA).</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input array.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling EMAs.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_window","title":"<code>rolling_window(a, window)</code>","text":"<p>Create a rolling window view of the array <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The input array.</p> required <code>window</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: A view of the input array with the specified rolling window.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_zscore","title":"<code>rolling_zscore(arr, n)</code>","text":"<p>Calculate the rolling Z-score.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input array.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling Z-scores.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.simple_weights","title":"<code>simple_weights(arr, normalize=False)</code>","text":"<p>Generates simple weights for an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray or list</code> <p>The input array.</p> required <code>normalize</code> <code>bool</code> <p>If True, the weights are normalized to sum to 1.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of simple weights.</p>"},{"location":"logger/formatters/","title":"quantpylib.logger.formatters","text":""},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter","title":"<code>JSONFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>A custom JSON formatter for logging.</p> <p>This formatter converts log records to JSON format. It includes level, time, and message by default and can optionally include additional attributes. Key-value pairs in the <code>extra</code> variable of logs are included in the JSON log.</p> <p>Parameters:</p> Name Type Description Default <code>include_attrs</code> <code>list</code> <p>List of additional attributes to include in the log record. Valid entries in the list can be found in <code>quantpylib.logger.utils</code>.</p> <code>[]</code>"},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter.__init__","title":"<code>__init__(include_attrs=[])</code>","text":"<p>Initializes the JSONFormatter.</p> <p>Parameters:</p> Name Type Description Default <code>include_attrs</code> <code>list</code> <p>List of additional attributes to include in the log record.                   Defaults to an empty list. Valid entries in the list can be found in <code>quantpylib.logger.utils</code>.</p> <code>[]</code>"},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter.format","title":"<code>format(record)</code>","text":"<p>Formats a log record and converts it to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The JSON-formatted log record as a string.</p>"},{"location":"logger/handlers/","title":"quantpylib.logger.handlers","text":""},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler","title":"<code>BufferedFileHandler</code>","text":"<p>               Bases: <code>FileHandler</code></p> <p>A logging handler that buffers log messages and writes them to a file when the buffer is full or on exit.</p> <p>This handler extends <code>logging.FileHandler</code> to provide buffered writing. Log messages are stored in a buffer and are written to the file only when the buffer reaches a specified size or the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.__init__","title":"<code>__init__(filename, mode='a', encoding=None, delay=False, errors=None, buffer_size=64)</code>","text":"<p>Initializes the BufferedFileHandler with the specified parameters.</p> <p>Registers an atexit function to flush the buffer when the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.emit","title":"<code>emit(record)</code>","text":"<p>Adds a log record to the buffer and writes to the file if the buffer is full.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to add to the buffer.</p> required"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Writes the contents of the buffer to the file and clears the buffer.</p> <p>This method is thread-safe.</p>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler","title":"<code>BufferedRotatingFileHandler</code>","text":"<p>               Bases: <code>RotatingFileHandler</code></p> <p>A rotating file handler with buffered writing.</p> <p>This handler extends <code>RotatingFileHandler</code> to buffer log messages and write them to the file only when the buffer reaches a specified size. The file is rotated when it reaches a certain size.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>maxBytes</code> <code>int</code> <p>The maximum size of the file before it is rotated. Defaults to 1GB.</p> <code>1 * 1024 * 1024 * 1024</code> <code>backupCount</code> <code>int</code> <p>The number of backup files to keep. Defaults to 5.</p> <code>5</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.__init__","title":"<code>__init__(filename, mode='a', maxBytes=1 * 1024 * 1024 * 1024, backupCount=5, encoding=None, delay=False, errors=None, buffer_size=64)</code>","text":"<p>Initializes the BufferedRotatingFileHandler with the specified parameters.</p> <p>Registers an atexit function to flush the buffer when the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>maxBytes</code> <code>int</code> <p>The maximum size of the file before it is rotated. Defaults to 1GB.</p> <code>1 * 1024 * 1024 * 1024</code> <code>backupCount</code> <code>int</code> <p>The number of backup files to keep. Defaults to 5.</p> <code>5</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.emit","title":"<code>emit(record)</code>","text":"<p>Adds a log record to the buffer and writes to the file if the buffer is full.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to add to the buffer.</p> required"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Writes the contents of the buffer to the file and clears the buffer.</p> <p>This method is thread-safe. Only the last log record in the buffer state is used to check for rotate condition.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written to.</p>"},{"location":"logger/logger/","title":"logger","text":"<p><code>quantpylib.logger</code> is a thread-safe logging module for quantpylib featuring custom formatters and handlers for recording structured log messages and reducing log latency.   </p> <p>The logger is designed for easy usage in Python applications that require both log analysis and performance requirements. </p> <p>In particular, the formatters in <code>quantpylib.logger.formatters</code>  contain log formatters extending the <code>logging.Formatter</code> classes,  designed for structured logging to be used in log aggregation and analysis tools  downstreams. The <code>quantpylib.logger.handlers</code> contain handlers extending  <code>logging.Handler</code> classes, designed for improving write log latencies, such as  buffered handlers that reduce I/O operations. These can be used separetely in your own  logging setup.</p> <p>Alternatively, the <code>quantpylib.logger.Logger</code> object pre-configures a singleton,  named logger. It allows the user to be able to log messages to stdout, files or both,  with the custom handlers and formatters. We will immediately demonstrate with examples.  The documentations follow.</p>"},{"location":"logger/logger/#examples","title":"Examples","text":"<p>The examples are really simple to use. Let us start with some imports, taking the <code>logging</code> library and the <code>quantpylib.logging</code>'s <code>Logger</code> and <code>JSONFormatter</code> object. Let's also take the ability to parse arguments into our Python script.</p> <pre><code>import logging \nfrom quantpylib.logger.logger import Logger \nfrom quantpylib.logger.formatters import JSONFormatter\n\nimport argparse\nparser = argparse.ArgumentParser()\nparser.add_argument('-c', '--config', type=str, help='Specify logging config')\nargs = parser.parse_args()\n</code></pre> <p>We want to log different kinds of information about our Python application - let's create a function that generates the logs. We will use the same function for all configurations, and see how the different specifications change logging behavior.</p> <p><pre><code>def log():\n    logging.debug(\"debug log\", extra={\"my debug key\":\"my debug value\"})\n    logging.info(\"info log\", extra={\"my info key\":\"my info value\"})\n    # input(\"hold\")\n    logging.warning(\"warning log\", extra={\"my warning key\":\"my warning value\"})\n    try:\n        1/0\n    except ZeroDivisionError:\n        logging.exception(\"caught zero denominator\", extra={\"my exception key\":\"my exception value\"})\n</code></pre> Let us ignore <code>input('hold')</code> for now, and have it commented out. We will look at that later. Let us take a look at what are the configuration options for our  <code>Logger</code> object (see documentation) <pre><code>class Logger:\n    #... some stuff\n    def __new__(\n        cls,\n        name='root',\n        register_handlers=[],\n        stdout_register=True,\n        stdout_level=logging.INFO, \n        stdout_formatter_cls=JSONFormatter,\n        stdout_formatter_kwargs={},\n\n        file_register=True,\n        filename=\"app.log\", \n        logs_dir=\"./logs/\",\n        file_level=logging.INFO, \n        file_formatter_cls=JSONFormatter,\n        file_formatter_kwargs={},        \n        file_handler_cls=BufferedFileHandler, \n        file_handler_kwargs={\"buffer_size\": 64},\n    ):\n</code></pre> The default is to configure the <code>root</code> logger. <code>stdout_register</code> and <code>file_register</code> is both set to <code>True</code>, meaning we log to console and to a file. Both levels are set as <code>logging.INFO</code>, meaning we should only see <code>logging.INFO</code> and higher levels. The remainder of the arguments are quite self intuitive, so let us try different configurations:</p>"},{"location":"logger/logger/#default-python-logger","title":"Default Python Logger","text":"<p>Let us begin with no arguments: <pre><code>if __name__ == \"__main__\":\n    if not args.config:\n        print(\"using default python logger\")\n\n    #...\n\n    log()\n</code></pre> We run <pre><code>python example_logger.py\n</code></pre> and we get <pre><code>using default python logger\nWARNING:root:warning log\nERROR:root:caught zero denominator\nTraceback (most recent call last):\n  File \"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\", line 16, in log\n    1/0\n    ~^~\n</code></pre> We get no <code>logging.DEBUG</code>, <code>logging.INFO</code> level messages, and we get a nice, compact message. However, this can be rather difficult to parse in a log ingestion stack.</p> <p>Additionally, we see that the <code>extra</code> values in the log records are ignored.</p>"},{"location":"logger/logger/#default-configurations","title":"Default Configurations","text":"<p>Let's try the default configs in the <code>Logger</code>: <pre><code>    example_configs = {\n        \"name\" : \"root\",\n        \"register_handlers\" : [],\n        \"stdout_register\" : True,\n        \"stdout_level\" : logging.INFO,\n        \"file_register\" : True,\n        \"file_level\" : logging.INFO\n    }\n    if args.config:\n        if args.config == \"d\":\n            print(\"using default quantpylib logger\")\n            Logger()\n</code></pre> We run  <pre><code>python example_logger.py -c d\n</code></pre> and we get <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T15:48:17.562138+00:00\", \"message\": \"info log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T15:48:17.562633+00:00\", \"message\": \"warning log\", \"my warning key\": \"my warning value\"}\n{\"level\": \"ERROR\", \"time\": \"2024-06-15T15:48:17.562706+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"my exception key\": \"my exception value\"}\n</code></pre> We also will see a new <code>./logs/app.log</code> file with the same content. Here, we see that the key-values in the <code>extra</code> parameter are written as part of the logs.</p>"},{"location":"logger/logger/#custom-configuring-our-logger","title":"Custom Configuring our Logger","text":"<p>We can of course, configure the logger. Say, we want to print to console logs formatted by <code>logging.Formatter</code>, while writing to file logs formatted by <code>JSONFormatter</code>. Furthermore, in the <code>JSONFormatter</code>, I also want to include more information from the <code>logging.LogRecord</code>. I choose <code>funcName</code> and <code>filename</code> from the possible attributes, listed here. <pre><code>    elif args.config == \"jf\":\n        print(\"using quantpylib logger with json formatter\")\n        Logger(\n            stdout_formatter_cls=logging.Formatter,\n            file_formatter_cls=JSONFormatter,\n            file_formatter_kwargs={\"include_attrs\":[\"funcName\",\"filename\"]},\n            file_handler_cls=logging.FileHandler,\n            file_handler_kwargs={},\n            **example_configs\n        )\n</code></pre> and run <pre><code>python example_logger.py -c jf\n</code></pre> and we get (we used the standard <code>logging.Formatter</code>) <pre><code>using quantpylib logger with json formatter\ninfo log\nwarning log\ncaught zero denominator\nTraceback (most recent call last):\n  File \"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\", line 16, in log\n    1/0\n    ~^~\nZeroDivisionError: division by zero\n</code></pre> printed to console, and (we used <code>JSONFormatter</code> with <code>funcName</code> and <code>filename</code>) <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T16:26:01.515551+00:00\", \"message\": \"info log\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T16:26:02.830514+00:00\", \"message\": \"warning log\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my warning key\": \"my warning value\"}\n{\"level\": \"ERROR\", \"time\": \"2024-06-15T16:26:02.830820+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my exception key\": \"my exception value\"}\n</code></pre> in the <code>app.log</code> file. So far, the default is the <code>BufferedFileHandler</code>, which is a <code>logging.Filehandler</code> that only flushes log to files when a buffer is full or on application exit.  What you would have noticed is that if you now uncomment the <code>input('hold')</code> line and run  <pre><code>python example_logger.py -c jf\n</code></pre> again, you would not see the logs written to file yet, when the execution pauses waiting for input. You can of course, adjust this buffer size.</p> <p>We can also used the <code>BufferedRotatingFileHandler</code>, so that we can store logs in different back up files - this of course - extends the <code>logging.handlers.RotatingFileHandler</code>. Let us try: <pre><code>    elif args.config == \"brfh\":\n        print(\"using quantpylib logger with buffered rotating file handler\")\n        from quantpylib.logger.handlers import BufferedRotatingFileHandler\n        Logger(\n            stdout_formatter_cls=logging.Formatter,\n            file_formatter_cls=JSONFormatter,\n            filename=\"brfh.log\",\n            logs_dir=\"./logs/\",\n            file_handler_cls=BufferedRotatingFileHandler,\n            file_handler_kwargs={\"maxBytes\":64},\n            **example_configs\n        )\n</code></pre> Like the parent <code>RotatingFileHandler</code>, we can set the the number of backup files. the maximum byte condition for rotation and so on. This now behaves like a combination of <code>BufferedFileHandler</code> we have defined and <code>RotatingFileHandler</code> we extended - the only difference is that this rotation is only checked when the buffer is flushed, and the rotate condition is checked on the last record inside the buffer state.</p> <p>We can run: <pre><code>python example_logger.py -c brfh\n</code></pre></p> <p>and we since we set the <code>maxBytes</code> to only 64 - when we flush the three log messages, we get <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T16:04:58.394926+00:00\", \"message\": \"info log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T16:05:02.579663+00:00\", \"message\": \"warning log\", \"my warning key\": \"my warning value\"}\n</code></pre> and then the last item triggers the rotation, putting those log messages in <code>brfh.log.1</code>, and the last record <pre><code>{\"level\": \"ERROR\", \"time\": \"2024-06-15T16:05:02.579820+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"my exception key\": \"my exception value\"}\n</code></pre> in <code>brfh.log</code>.</p>"},{"location":"logger/logger/#documentation","title":"Documentation","text":""},{"location":"logger/logger/#quantpylib.logger.logger.Logger","title":"<code>Logger</code>","text":"<p>A configurable singleton logger class that sets up logging for the application.</p> <p>This logger allows for the registration of custom handlers and configuration of console (stdout) and file handlers. It supports various configuration options including log levels, formatters, and buffer sizes for file handling.</p> <p>Attributes:</p> Name Type Description <code>_logger</code> <code>Logger</code> <p>The singleton logger instance.</p>"},{"location":"logger/logger/#quantpylib.logger.logger.Logger.__new__","title":"<code>__new__(name='root', register_handlers=[], stdout_register=True, stdout_level=logging.INFO, stdout_formatter_cls=JSONFormatter, stdout_formatter_kwargs={}, file_register=True, filename='app.log', logs_dir='./logs/', file_level=logging.INFO, file_formatter_cls=JSONFormatter, file_formatter_kwargs={}, file_handler_cls=BufferedFileHandler, file_handler_kwargs={'buffer_size': 64}, *args, **kwargs)</code>","text":"<p>Creates and configures the logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger. Defaults to 'root'.</p> <code>'root'</code> <code>register_handlers</code> <code>list</code> <p>A list of additional logging handlers to register. Defaults to an empty list.</p> <code>[]</code> <code>stdout_register</code> <code>bool</code> <p>Whether to register a console (stdout) handler. Defaults to True.</p> <code>True</code> <code>stdout_level</code> <code>int</code> <p>The logging level for the console handler. Defaults to logging.INFO.</p> <code>INFO</code> <code>stdout_formatter_cls</code> <code>type</code> <p>The formatter class for the console handler. Defaults to <code>quantpylib.logger.formatters.JSONFormatter</code>.</p> <code>JSONFormatter</code> <code>stdout_formatter_kwargs</code> <code>dict</code> <p>Keyword arguments for the console handler formatter. Defaults to an empty dict.</p> <code>{}</code> <code>file_register</code> <code>bool</code> <p>Whether to register a file handler. Defaults to True.</p> <code>True</code> <code>filename</code> <code>str</code> <p>The name of the log file. Defaults to \"app.log\".</p> <code>'app.log'</code> <code>logs_dir</code> <code>str</code> <p>The directory where log files are stored. Defaults to \"./logs/\".</p> <code>'./logs/'</code> <code>file_level</code> <code>int</code> <p>The logging level for the file handler. Defaults to logging.INFO.</p> <code>INFO</code> <code>file_formatter_cls</code> <code>type</code> <p>The formatter class for the file handler. Defaults to <code>quantpylib.logger.formatters.JSONFormatter</code>.</p> <code>JSONFormatter</code> <code>file_formatter_kwargs</code> <code>dict</code> <p>Keyword arguments for the file handler formatter. Defaults to an empty dict.</p> <code>{}</code> <code>file_handler_cls</code> <code>type</code> <p>The handler class for file logging. Defaults to <code>quantpylib.logger.handlers.BufferedFileHandler</code>.</p> <code>BufferedFileHandler</code> <code>file_handler_kwargs</code> <code>dict</code> <p>Keyword arguments for the file handler. Defaults to {\"buffer_size\": 64}.</p> <code>{'buffer_size': 64}</code> <code>*args</code> <p>Additional positional arguments passed to the logging configuration.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the logging configuration.</p> <code>{}</code> <p>Returns:</p> Type Description <p>logging.Logger: The configured singleton logger instance.</p>"},{"location":"logger/utils/","title":"quantpylib.logger.utils","text":""},{"location":"logger/utils/#log-record-attributes","title":"Log Record Attributes","text":"<ul> <li><code>args</code>: The tuple of arguments passed to the logging call.</li> <li><code>asctime</code>: The string representation of the time when the <code>LogRecord</code> was created.</li> <li><code>created</code>: The time when the <code>LogRecord</code> was created, in seconds since the epoch.</li> <li><code>exc_info</code>: Exception tuple (type, value, traceback) if an exception occurred during logging.</li> <li><code>exc_text</code>: Textual representation of the exception information.</li> <li><code>filename</code>: The name of the file in which the logging call was made.</li> <li><code>funcName</code>: The name of the function or method from which the logging call was made.</li> <li><code>levelname</code>: The textual representation of the log level (e.g., 'DEBUG', 'INFO').</li> <li><code>levelno</code>: The numeric representation of the log level.</li> <li><code>lineno</code>: The line number in the source code where the logging call was made.</li> <li><code>module</code>: The name of the module in which the logging call was made.</li> <li><code>msecs</code>: The millisecond portion of the time when the <code>LogRecord</code> was created.</li> <li><code>message</code>: The logged message after merging any user-supplied arguments with the message.</li> <li><code>msg</code>: The logged message, before merging with user-supplied arguments.</li> <li><code>name</code>: The name of the logger that created the <code>LogRecord</code>.</li> <li><code>pathname</code>: The full path of the source file where the logging call was made.</li> <li><code>process</code>: The process ID of the process that created the <code>LogRecord</code>.</li> <li><code>processName</code>: The name of the process that created the <code>LogRecord</code>.</li> <li><code>relativeCreated</code>: The time since the logging module was loaded, in milliseconds.</li> <li><code>stack_info</code>: A string representation of the current stack frame.</li> <li><code>thread</code>: The thread ID of the thread that created the <code>LogRecord</code>.</li> <li><code>threadName</code>: The name of the thread that created the <code>LogRecord</code>.</li> <li><code>taskName</code>: The name of the task that created the <code>LogRecord</code>, relevant in asynchronous environments.</li> </ul>"},{"location":"simulator/alpha/","title":"quantpylib.simulator.alpha","text":"<p><code>quantpylib.simulator.alpha</code> is our core backtesting module, and exposes multiple abstract  base classes that can be easily extended to implement your own custom trading strategies. <code>quantpylib.simulator.alpha.BaseAlpha</code> encodes the underlying backtest logic, and <code>quantpylib.simulator.alpha.Alpha</code> extends <code>BaseAlpha</code> and implements important features such that the user only has to write code for generating relative forecasts/signals. Position-sizing, risk-management, volatility targeting, PnL accounting and trade simulation is then handled by the backtest logic.</p> <p>In addition, we provide simple but powerful access to an assortment of performance metrics and hypothesis tests (monte carlo permutation tests) on any instance of the <code>BaseAlpha</code> object to test for strategy effectiveness.</p> <p>Users would likely only have to interact with the abstract <code>quantpylib.simulator.alpha.Alpha</code> class, and implement the<code>compute_forecasts</code> and <code>compute_signals</code> function in custom-classes that extend the <code>Alpha</code> class. Additionally, users may opt to use our automatic formulaic parser and use <code>quantpylib.simulator.gene.GeneticAlpha</code> that extends the <code>Alpha</code> class to opt for a no-code backtest by just encoding their trading strategy as a simple Python <code>str</code>, for which all the abstract functions would be automatically implemented.</p>  Using the quantpylib.simulator.gene.GeneticAlpha is the simplest and recommended way of using our BaseAlpha and Alpha classes, as no additional code needs to be written. If the primitives supported by our gene module is not sufficient to encode your trading strategy, then the Alpha class should be sufficient for most needs."},{"location":"simulator/alpha/#alpha","title":"Alpha","text":"<code>     __init__     </code> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume min of OHLC dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume max of OHLC dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of traded instruments.</p> <code>[]</code> <code>execrates</code> <code>ndarray</code> <p>Execution rates for each instrument. Default is None.</p> <code>None</code> <code>commrates</code> <code>ndarray</code> <p>Commission rates for each instrument. Default is None.</p> <code>None</code> <code>longswps</code> <code>ndarray</code> <p>Long annualized swap/funding rates for each instrument. Positive swaps means long positions incur swap fees. Default is None.</p> <code>None</code> <code>shortswps</code> <code>ndarray</code> <p>Short annualized swap/funding rates for each instrument. Positive swaps means short positions incur swap fees. Default is None.</p> <code>None</code> <code>granularity</code> <code>Period</code> <p>The granularity of each trading signal evaluation.  Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>positional_inertia</code> <code>float</code> <p>Parameter controlling position change inertia. Default is 0.</p> <code>0</code> <code>portfolio_vol</code> <code>float</code> <p>Target portfolio volatility. Default is 0.20, representing 20% annualized volatility.</p> <code>0.2</code> <code>weekend_trading</code> <code>bool</code> <p>Indicates if there is weekend trading, such as in cryptocurrency markets. Defaults to False.</p> <code>False</code> <code>around_the_clock</code> <code>bool</code> <p>Indicates if there is 24H trading, such as in cryptocurrency and fx markets. Defaults to False.</p> <code>False</code> <code>currency_denomination</code> <code>str</code> <p>Currency denomination for the portfolio. Default is \"USD\".</p> <code>'USD'</code> <code>starting_capital</code> <code>float</code> <p>Amount to begins the backtest with. Defaults to 10000.0.</p> <code>10000.0</code> <p>Notes:     execrates, commrates, longswps, shortswps are presented in decimals. <code>execrates = [0.001, 0.005, ...]</code> encodes     that 0.1% of notional value transacted is deducted as execution costs for first instrument, second instrument...      commrates specify commisions in the same units (as percentage of notional value),      as for overnight swap rates for both long and short positions.</p>  For the dfs dictionary passed into BaseAlpha objects, it should contain the DataFrames for all data required in the trading strategy. Minimally, dfs should contain key-value pair of (ticker:pd.DataFrame) with OHLCV data for PnL accounting. The pd.DataFrame objects provided should have timezone aware DatetimeIndex properties. For instance: <pre><code>{\n    'BRKB':\n                                open      high       low        close        adj_close volume\n    datetime\n    2000-01-03 00:00:00+00:00  1825.0000  1829.0000  1741.0000  1765.0000    35.3000   873500     \n    2000-01-04 00:00:00+00:00  1725.0000  1733.0000  1695.0000  1704.0000    34.0800  1380000     \n    2000-01-05 00:00:00+00:00  1707.0000  1773.0000  1695.0000  1732.0000    34.6400   997000     \n    2000-01-06 00:00:00+00:00  1745.0000  1804.0000  1727.0000  1804.0000    36.0800   917000     \n    2000-01-07 00:00:00+00:00  1830.0000  1848.0000  1805.0000  1820.0000    36.4000  1001500     \n    ...                              ...        ...        ...        ...        ...      ...     \n    2009-12-24 00:00:00+00:00  3281.9999  3295.9899  3274.9999  3286.9999    65.7400   607600     \n    2009-12-28 00:00:00+00:00  3279.9999  3289.9999  3274.9999  3285.3699    65.7074  1080250     \n    2009-12-29 00:00:00+00:00  3284.9999  3289.6899  3269.9999  3279.9999    65.6000  1105300     \n    2009-12-30 00:00:00+00:00  3282.9999  3289.6499  3279.9999  3289.6499    65.7930   560350     \n    2009-12-31 00:00:00+00:00  3289.9999  3300.9899  3279.9999  3285.9999    65.7200   972900 \n} \n</code></pre> <code>     compute_signals     </code> <code>async, abstract</code> <p>Abstract function that should be implemented in child-class extending the <code>Alpha</code> class. This is where users can manipulate the dataframes in <code>dfs</code> dict passed by accessing  <code>self.dfs</code> to compute useful metrics such as technical indicators.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>DatetimeIndex</code> <p>datetime index for intervals at specified granularity.</p> required <code>     compute_forecasts     </code> <code>abstract</code> <p>Abstract function that should be implemented in child-class extending the <code>Alpha</code> class. Computes relative forecasts for <code>self.instruments</code> on <code>dt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_i</code> <p>Number of time intervals passed between date and backtest start.</p> required <code>dt</code> <code>datetime</code> <p>The datetime for which forecasts are to be computed.</p> required <code>eligibles_row</code> <code>ndarray</code> <p>An array mask of length <code>len(self.instruments)</code> that acts as a bit mask for eligible trading universe.</p> required <p>Returns:</p> Type Description <code>array</code> <p>An array representing the relative forecasts for each of instruments in <code>self.instruments</code> with length <code>len(self.instruments)</code>.</p> Notes <p>It is not required for the forecasts to be indicative of the number of contracts the strategy should trade. The values in the returned array need only be indicative of the relative strength in the signal forecast. For instance, <code>[-1, 1, 1.5]</code> means we want to be as short the first instrument as we are long the second instrument, and we want to be longer by a factor of 1.5 in the third instrument as we are in the second instrument. Position sizing in the underlying contracts are dealt with automatically in the backtest engine using volatility  targeting at the instrument and strategy level. <code>np.nan</code>, <code>np.inf</code> values are treated as zero.</p> <code>     instantiate_eligibilities_and_strat_variables     </code> <p>This is where the child class can instantiate object attributes that can be used in the <code>compute_forecasts</code> function. Optional to implement. <code>eligiblesdf</code> is the default bit mask DataFrame encoding trading universe on  each time point between <code>start</code> and <code>end</code>, but it may be modified in an overriding method to use a different universe set throughout the backtest. </p> <p>Parameters:</p> Name Type Description Default <code>eligiblesdf</code> <code>DataFrame</code> <p>Bit mask DataFrame. Value of 1 means the instrument is eligible to be considered  for trading on given date, and value of 0 means not eligible. Computed based on the market data given in <code>self.dfs</code>.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>eligiblesdf is returned to the caller, and is used as the updated (if modified) bit-mask. If the function is not  implemented, the default <code>eligiblesdf</code> is used.</p> Notes <p>This function is optional to implement. The default implemention is a one-liner returning <code>eligiblesdf</code>.</p> <p>The remaining functions are not abstract and no further implementation is required or warranted.</p> <code>     run_simulation     </code> <code>async</code> <p>Runs the entire backtest. Should only be called after concrete implementation of <code>compute_signals</code> and <code>compute_forecasts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>(boolean, optional) flag to print out backtest simulation information at runtime.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a DataFrame containing backtest statistics. Contains information about contracts held throughtout the backtest, portfolio weights, portfolio leverage, nominal exposusure, execution costs, commissions, swaps, PnL, portfolio capital and so on.</p> <code>     get_performance_measures     </code> <p>Computes the performance metrics for the trading strategy.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul> <code>     hypothesis_tests     </code> <code>async</code> <p>Conducts monte carlo permutation p-value hypothesis tests on the performance of the  trading strategy represented by the object instance.</p> <p>Parameters:</p> Name Type Description Default <code>num_decision_shuffles</code> <code>int</code> <p>Number of decision shuffles for monto carlo permutation tests. Default is 1000.</p> <code>1000</code> <code>num_data_shuffles</code> <code>int</code> <p>Number of data shuffles for permutation tests. Default is 10 (computationally expensive).</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of hypothesis tests.</p> <ul> <li>'timer_p': p-value from asset-timing test that shuffles time-series asset returns.</li> <li>'picker_p': p-value from asset-picking shuffler test that shuffles cross-sectional asset returns.</li> <li>'trader_p1': p-value from decision-making test that shuffles both time-series and cross-sectional asset returns.</li> <li>'trader_p2': p-value from decision-making test that shuffles market data.</li> </ul>"},{"location":"simulator/gene/","title":"quantpylib.simulator.gene","text":"<p><code>quantpylib.simulator.gene</code> houses powerful features for numerical computations involving market  and non-market variables, including a no-code mathematical parser-evaluator that computes trading signals/indicators from formulaic, well-defined Python <code>str</code> objects. The parser-evaluator is exposed via the  <code>quantpylib.simulator.gene.Gene</code> class APIs, which internally uses a tree-data structure to encode trading formulas. The <code>quantpylib.simulator.gene.GeneticAlpha</code> class leverages this parser-evaluator, as well as the backtest engine provided by our <code>quantpylib.simulator.alpha.Alpha</code>  class to provide a no-code solution to backtesting trading strategies. The <code>GeneticAlpha</code> class  extends the <code>Alpha</code>   class to implement all the necessary methods for signal computation, forecast generation, position sizing, risk-management, volatility targeting and backtest logic. All the performance metrics and hypothesis testing suites made available to the <code>Alpha</code>  objects are naturally available to any <code>GeneticAlpha</code> instance via the same function signatures.</p>"},{"location":"simulator/gene/#geneticalpha","title":"GeneticAlpha","text":"<p>(Bases: <code>quantpylib.simulator.alpha.Alpha</code>  )</p> <p>Parameters:</p> Name Type Description Default <code>genome</code> <code>Gene or str</code> <p>Genome representation as <code>Gene</code> object or in mathematical string format.   </p> required <code>**kwargs</code> <p>Backtest parameters required to instantiate <code>quantpylib.simulator.alpha.Alpha</code> objects.</p> <code>{}</code> <p>Parameters in <code>**kwargs</code> are required and passed into <code>quantpylib.simulator.alpha.Alpha</code>  and are as follows: </p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume min of OHLC dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume max of OHLC dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of traded instruments.</p> <code>[]</code> <code>execrates</code> <code>ndarray</code> <p>Execution rates for each instrument. Default is None.</p> <code>None</code> <code>commrates</code> <code>ndarray</code> <p>Commission rates for each instrument. Default is None.</p> <code>None</code> <code>longswps</code> <code>ndarray</code> <p>Long annualized swap/funding rates for each instrument. Positive swaps means long positions incur swap fees. Default is None.</p> <code>None</code> <code>shortswps</code> <code>ndarray</code> <p>Short annualized swap/funding rates for each instrument. Positive swaps means short positions incur swap fees. Default is None.</p> <code>None</code> <code>granularity</code> <code>Period</code> <p>The granularity of each trading signal evaluation.  Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>positional_inertia</code> <code>float</code> <p>Parameter controlling position change inertia. Default is 0.</p> <code>0</code> <code>portfolio_vol</code> <code>float</code> <p>Target portfolio volatility. Default is 0.20, representing 20% annualized volatility.</p> <code>0.2</code> <code>weekend_trading</code> <code>bool</code> <p>Indicates if there is weekend trading, such as in cryptocurrency markets. Defaults to False.</p> <code>False</code> <code>around_the_clock</code> <code>bool</code> <p>Indicates if there is 24H trading, such as in cryptocurrency and fx markets. Defaults to False.</p> <code>False</code> <code>currency_denomination</code> <code>str</code> <p>Currency denomination for the portfolio. Default is \"USD\".</p> <code>'USD'</code> <code>starting_capital</code> <code>float</code> <p>Amount to begins the backtest with. Defaults to 10000.0.</p> <code>10000.0</code> <p>Notes:     execrates, commrates, longswps, shortswps are presented in decimals. <code>execrates = [0.001, 0.005, ...]</code> encodes     that 0.1% of notional value transacted is deducted as execution costs for first instrument, second instrument...      commrates specify commisions in the same units (as percentage of notional value),      as for overnight swap rates for both long and short positions.</p> <code>     run_simulation     </code> <code>async</code> <p>Runs the entire backtest. </p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>(boolean, optional) flag to print out backtest simulation information at runtime.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a DataFrame containing backtest statistics. Contains information about contracts held throughtout the backtest, portfolio weights, portfolio leverage, nominal exposusure, execution costs, commissions, swaps, PnL, portfolio capital and so on.</p> <code>     get_performance_measures     </code> <p>Computes the performance metrics for the trading strategy.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul> <code>     hypothesis_tests     </code> <code>async</code> <p>Conducts monte carlo permutation p-value hypothesis tests on the performance of the  trading strategy represented by the object instance.</p> <p>Parameters:</p> Name Type Description Default <code>num_decision_shuffles</code> <code>int</code> <p>Number of decision shuffles for monto carlo permutation tests. Default is 1000.</p> <code>1000</code> <code>num_data_shuffles</code> <code>int</code> <p>Number of data shuffles for permutation tests. Default is 10 (computationally expensive).</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of hypothesis tests.</p> <ul> <li>'timer_p': p-value from asset-timing test that shuffles time-series asset returns.</li> <li>'picker_p': p-value from asset-picking shuffler test that shuffles cross-sectional asset returns.</li> <li>'trader_p1': p-value from decision-making test that shuffles both time-series and cross-sectional asset returns.</li> <li>'trader_p2': p-value from decision-making test that shuffles market data.</li> </ul>"},{"location":"simulator/gene/#gene","title":"<code>Gene</code>","text":"<p>Represents a formulaic alpha expression used to encode trading rules.</p> <p>This class internally represents a trading rule as a tree data structure, where each node can either be a terminal (leaf) node or a functional node. Terminal nodes represent data points or constants, while functional nodes represent operations on their child nodes.</p> <code>     str_to_gene     </code> <code>staticmethod</code> <code>     __init__     </code> <p>Initializes a Gene object.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <code>str</code> <p>The primary function/terminal of the gene.</p> required <code>space</code> <code>str</code> <p>The space value associated with the gene, specifying      details of the primitive. For example, in the context of financial     trading, this could represent parameters such as window size or lookback     period of a rolling correlation function. Defaults to None.</p> <code>None</code> <code>is_terminal</code> <code>bool</code> <p>Indicates whether the gene is terminal node.</p> required <code>parent</code> <code>Gene</code> <p>The parent gene. Defaults to None.</p> <code>None</code> <code>children</code> <code>list</code> <p>The list of child genes. Defaults to an empty list.</p> <code>[]</code> <p>The list of <code>prim</code> primitives supported by our library, their behavior and their interpretations can be found here.</p> <code>     evaluate_node     </code> <p>Recursively evaluates a node in the formulaic alpha expression. When called on the root node in the  gene representation, this function evaluates the entire formulaic expression.</p> <p>Parameters:</p> Name Type Description Default <code>insts</code> <code>list</code> <p>The list of instrument names.</p> required <code>dfs</code> <code>dict</code> <p>A dictionary containing pricing/alternative data DataFrames for each instrument.</p> required <code>idx</code> <code>Index</code> <p>The index for alignment.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The evaluated node with DataFrame.index=idx and DataFrame.columns=insts.</p>  dfs should contain DataFrames for all terminals required in the evaluation of the gene representation. For OHLCV terminals, dfs should contain key-value pair of (ticker:pd.DataFrame). pd.DataFrame objects provided should have timezone aware DatetimeIndex properties. For instance: <pre><code>{\n    'BRKB':\n                                open      high       low        close        adj_close volume\n    datetime\n    2000-01-03 00:00:00+00:00  1825.0000  1829.0000  1741.0000  1765.0000    35.3000   873500     \n    2000-01-04 00:00:00+00:00  1725.0000  1733.0000  1695.0000  1704.0000    34.0800  1380000     \n    2000-01-05 00:00:00+00:00  1707.0000  1773.0000  1695.0000  1732.0000    34.6400   997000     \n    2000-01-06 00:00:00+00:00  1745.0000  1804.0000  1727.0000  1804.0000    36.0800   917000     \n    2000-01-07 00:00:00+00:00  1830.0000  1848.0000  1805.0000  1820.0000    36.4000  1001500     \n    ...                              ...        ...        ...        ...        ...      ...     \n    2009-12-24 00:00:00+00:00  3281.9999  3295.9899  3274.9999  3286.9999    65.7400   607600     \n    2009-12-28 00:00:00+00:00  3279.9999  3289.9999  3274.9999  3285.3699    65.7074  1080250     \n    2009-12-29 00:00:00+00:00  3284.9999  3289.6899  3269.9999  3279.9999    65.6000  1105300     \n    2009-12-30 00:00:00+00:00  3282.9999  3289.6499  3279.9999  3289.6499    65.7930   560350     \n    2009-12-31 00:00:00+00:00  3289.9999  3300.9899  3279.9999  3285.9999    65.7200   972900 \n} \n</code></pre> For non-OHLCV terminals, dfs should be supplemented with key-value pair of (ticker_terminal:pd.Series). pd.Series objects provided should have timezone aware DatetimeIndex properties. <pre><code>{\n    'BRKB_earnings' : pd.Series(\n            index=[2000-01-03 00:00:00+00:00, ..., 2009-12-30 00:00:00+00:00],\n            data=[...]\n    ),\n    'BRKB_sentiment' : pd.Series(\n            index=[2010-01-03 00:00:00+00:00, ..., 2016-12-30 00:00:00+00:00],\n            data=[...]\n    )\n}\n</code></pre> <code>     make_dot     </code> <p>Generate a DOT language representation of the tree structure rooted at this node.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the DOT language representation of the tree.</p> Notes <p>This method uses pre-order traversal to generate the DOT representation of the tree rooted at the current node. Each node in the tree corresponds to a vertex in the DOT graph, and each edge represents the parent-child relationship between nodes.</p> <p>The generated DOT string can be rendered into a graphical visualization using graphviz or other tools that support the DOT language.</p> <code>     height     </code> <p>Return the maximium distance from current node to any leaf node that is a descendant.</p> <code>     depth     </code> <p>Return the distance from current node to the root node.</p> <code>     size     </code> <p>Return the number of nodes in the graphical respresentation of the formulaic alpha.</p> <code>     pre_ord_apply     </code> <p>Apply a function to each node in the tree using pre-order traversal.</p> <p>This method traverses the tree in a pre-order fashion, meaning it applies the function to the current node before recursively traversing its children. The function is applied to each node along with any additional keyword arguments provided.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>A function to be applied to each node in the tree.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the function.</p> <code>{}</code>"},{"location":"simulator/gene/#list-of-primitives","title":"List of Primitives","text":"<p>The Op value = <code>idx_op</code> can be taken to be default as <code>union_idx_op</code>, or when explicitly paired with the <code>un</code> Space value. It takes <code>intersect_idx_op</code> when paired with the <code>ix</code> Space value. Examples would be <code>plus(open,close)</code>, <code>plus_un(open,close)</code>, <code>plus_ix(open,close)</code>. The different operators and their behavior is documented here.</p> Primitive Space Op Terminal Args Meaning Example const int,float - Yes - represents a constant numerical value of x const_3.14 open - - Yes - open price open high - - Yes - high price high low - - Yes - low price low close - - Yes - close price close volume - - Yes - trade volume volume * - - Yes - custom variable * (e.g. epsEst, sentiment) abs - self_idx_op2 No 1 absolute value abs(minus(close,open)) neg - self_idx_op2 No 1 negation neg(minus(close,open)) log - self_idx_op2 No 1 natural logarithm (replacing inf with NaN) log(volume) sign - self_idx_op2 No 1 sign function sign(minus(close,open)) tanh - self_idx_op2 No 1 tanh function tanh(cszscre(logret_1())) sigmoid - self_idx_op2 No 1 sigmoid function sigmoid(cszscre(logret_1())) recpcal - self_idx_op2 No 1 reciprocal (replacing inf with NaN) recpcal(close) pow int self_idx_op2 No 1 power function (replacing inf with NaN) pow_2(close) csrank - all_idx_op No 1 cross-sectional rank (smallest=1, average draws) csrank(volume) cszscre - all_idx_op No 1 cross-sectional Z-score cszscre(volume) percentile - all_idx_op No 1 cross-sectional percentile values percentile(volume) ls int,float / int,float all_idx_op No 1 -1 for values below 25 percentile and +1 for values above 75 percentile ls_25/75(volume) delta int self_idx_op No 1 time-series change in variable over time delta_1(close) delay int self_idx_op No 1 time-series delay by specified number of periods delay_1(close) forward int self_idx_op No 1 time-series lookahead by specified number of periods forward_1(close) sum int self_idx_op No 1 sum of time-series values sum_5(volume) prod int self_idx_op No 1 product of time-series values prod_5(volume) mean, sma int self_idx_op No 1 simple mean of time-series values mean_5(volume) ema, ewma int self_idx_op No 1 exponentially weighted moving average ewma_5(volume) median int self_idx_op No 1 median of time-series values median_5(volume) std int self_idx_op No 1 standard deviation of time-series values std_5(volume) var int self_idx_op No 1 variance of time-series values var_5(volume) skew int self_idx_op No 1 skewness of time-series values skew_5(volume) kurt int self_idx_op No 1 kurtosis of time-series values kurt_5(volume) tsrank int self_idx_op No 1 time-series rank tsrank_5(volume) tsmax int self_idx_op No 1 maximum value over time tsmax_5(volume) tsmin int self_idx_op No 1 minimum value over time tsmin_5(volume) tsargmax int self_idx_op No 1 index of maximum value over time tsargmax_5(volume) tsargmin int self_idx_op No 1 index of minimum value over time tsargmin_5(volume) tszscre int self_idx_op No 1 time-series Z-score tszscre_5(volume) max -,un,ix idx_op No &gt;=2 maximum over arguments max_ix(open,close,high) plus -,un,ix idx_op No &gt;=2 sum over arguments plus_un(open,close,high) minus -,un,ix idx_op No 2 subtraction minus(high,low) mult -,un,ix idx_op No 2 multiplication mult(open,close) div -,un,ix idx_op No 2 division div(open,close) and -,un,ix idx_op No 2 logical AND and(gt(high,low),lt(high,low)) or -,un,ix idx_op No 2 logical OR or(gt(high,low),lt(high,low)) eq -,un,ix idx_op No 2 logical EQUALS eq(gt(high,low),lt(high,low)) gt -,un,ix idx_op No 2 greater-than comparison gt(open,close) gte -,un,ix idx_op No 2 greater-than-equals comparison gte(open,close) lt -,un,ix idx_op No 2 less-than comparison lt(open,close) lte -,un,ix idx_op No 2 less-than-equals comparison lte(open,close) ite -,un,ix idx_op No 3 if-then-else operation ite(or(gt(high,low),lt(high,low)),const_1,const_-1) cor int slow_idx_op No 2 rolling-correlation cor_12(volume,close) kentau int slow_idx_op No 2 rolling-Kendall's tau correlation kentau_12(volume,close) cov int slow_idx_op No 2 rolling-covariance cov_12(volume,close) dot int slow_idx_op No 2 rolling-dot product dot_12(volume,close) wmean, wma int slow_idx_op No 2 weighted moving average wmean_12(close,weights) grssret int - Pseudo 0 period gross returns grssret_12() logret int - Pseudo 0 period log returns logret_12() netret int - Pseudo 0 period net returns (gross returns - 1) netret_12() volatility int - Pseudo 0 volatility (standard deviation of log returns) volatility_12() rsi int - Pseudo 0 relative strength index indicator rsi_12() mvwap int - Pseudo 0 moving volume-weighted average price indicator mvwap_12() obv int - Pseudo 0 on-balance volume indicator obv_12() atr int - Pseudo 0 average true range indicator atr_12() tr - - Pseudo 0 true range indicator tr() adx int - Pseudo 0 average directional movement index adx_12() addv int - Pseudo 0 average daily dollar volume addv_12() mac int / int - No 1 moving average crossover indicator function for fast/slow mac_20/50 vma, vwma int - No 1 volume weighted moving average vma_20(close) vwvar int - No 1 volume weighted variance vmvar_20(logret_1()) vwstd int - No 1 volume weighted standard deviation vmstd_20(logret_1()) between int,float / int,float - No 1 indicator function for  a &lt;= x &lt;= b between_10/90(percentile(volume))"},{"location":"simulator/models/","title":"quantpylib.simulator.models","text":"<p><code>quantpylib.simulator.models</code> house powerful features for statistical analysis involving market and non-market variables. It features <code>quantpylib.simulator.models.GeneticRegression</code> class that is an abstraction layer written on top of the  <code>quantpylib.simulator.gene.Gene</code> class and <code>statsmodels.formula.api</code> to perform no-code  regression analysis using simple string specifications.</p> <p>An example scenario for quantitative analysis is a momentum study on the impact of standardized  returns on forward returns. We may specify such a regression study by the following regression formula: <pre><code>forward_1(logret_1()) ~ div(logret_25(),volatility_25()) + tsargmax_16(close)\n</code></pre> The <code>GeneticRegression</code> enables this in multiple steps:</p> <ul> <li>Parse the formula into blocks: <ul> <li><code>b0</code>: <code>forward_1(logret_1())</code></li> <li><code>b1</code>: <code>div(logret_25(),volatility_25())</code></li> <li><code>b2</code>: <code>tsargmax_16(close)</code></li> </ul> </li> <li>Construct the equivalent regression specification: <code>b0 ~ b1 + b2</code></li> <li>Evaluate each block using our evaluator-parser in the <code>Gene</code> class.</li> <li>Pass the evaluated blocks and regression specification into <code>statsmodels</code> for regression analysis.</li> </ul> <p>This allows the user to both leverage on the well-tested and familiar statistical package developed under <code>statsmodels</code>, while enhancing the expressive capabilities of the formulaic language specialized for trading analysis. The full list of primitives (constants and functions) are documented here.</p> <p>We also provide additional convenience methods for data binning and aggregation, diagnostics and plotting. The specifications are to be referred below.</p> <p>The following notations apply in the documentation:</p> <pre><code>- y, b0 : response variable\n- x[*], b[1..] : independent variable(s)\n- y^ : fitted response\n- uCI : upper confidence interval\n- lCI : lower confidence interval\n- res : residuals\n- res# : (z-score) normalized residuals\n- res+ : internally studentized residuals\n- res* : externally studentized residuals\n- PRP : partial regression plot\n- CCPR : component-component plus residual plot\n</code></pre>"},{"location":"simulator/models/#quantpylib.simulator.models.Bin","title":"<code>Bin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration representing different binning methods.</p> <p>Attributes:</p> Name Type Description <code>WIDTH</code> <p>Binning method where each bin has an equal interval length.</p> <code>OBSERVATIONS</code> <p>Binning method where each bin contains an equal number of observations.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression","title":"<code>GeneticRegression</code>","text":""},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.__init__","title":"<code>__init__(formula='forward_1(logret_1()) ~ div(logret_25(),volatility_25())', intercept=True, df=None, start=None, end=None, dfs={}, instruments=[], granularity=Period.DAILY, build=True)</code>","text":"<p>Initializes a GeneticRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The regression formula. The formula describes the statistical model being analysed, and is closely inspired by the formula mini-language used in R and S. The model formula should consist of valid string representations of <code>Gene</code> formula blocks as  dependent and independent variables delimited by the operators [ ~ + * : ] of the <code>patsy</code> language.</p> <code>'forward_1(logret_1()) ~ div(logret_25(),volatility_25())'</code> <code>start</code> <code>datetime</code> <p>Start period for regression analysis. If not tz-aware, assumed UTC. If not given, assume min of dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>End period for regression analysis. If not tz-aware, assumed UTC. If not given, assume max of dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of instruments used in the regression analysis.</p> <code>[]</code> <code>granularity</code> <code>Period</code> <p>The granularity of the regression analysis. Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>build</code> <code>bool</code> <p>Whether to evaluate the formulaic blocks upon initialization. Default is True.</p> <code>True</code>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.build","title":"<code>build()</code>","text":"<p>Evaluates the formulaic (dependent and independent) blocks to be used as regression  variables using the initialized formula and dataframes provided. If <code>build=False</code> at initialization, then  <code>build()</code> needs to be called before any of the regression methods, such as <code>ols</code>, are called.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.diagnose","title":"<code>diagnose()</code>","text":"<p>Diagnoses the regression model for multicollinearity and other issues.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the following:</p> <ul> <li>\"cond_num\": Condition number of the derived design matrix</li> <li>\"vif b[1..]\" : variance inflation factor for the relevant regressor variable.</li> </ul>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.ols","title":"<code>ols(axis='flatten', bins=0, binned_by=Bin.OBSERVATIONS, bin_block='b0', selector=None, aggregator=lambda x: np.mean(winsorize(x, limits=(0.05, 0.05))))</code>","text":"<p>Performs Ordinary Least Squares (OLS) regression analysis. </p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>The axis along which the regression analysis is performed. Possible values are <code>flatten</code>, <code>xs</code>, or <code>ts</code>. <code>flatten</code> uses all of the available data as regression input. <code>xs</code> uses cross sectional data on a particular date as regression input. <code>ts</code> uses time series data for a particular instrument as regression input.</p> <code>'flatten'</code> <code>bins</code> <code>int</code> <p>The number of bins for grouping the data. If 0, no binning is performed. Defaults to 0.</p> <code>0</code> <code>binned_by</code> <code>Bin</code> <p>The method used for binning the data. Possible values are <code>Bin.OBSERVATIONS</code> or <code>Bin.WIDTH</code>, corresponding to  equal number of observations in each bin and equal interval length in each bin respectiely.                </p> <code>OBSERVATIONS</code> <code>bin_block</code> <code>str</code> <p>The block used for binning the data. Defaults to <code>b0</code>, the dependent variable.</p> <code>'b0'</code> <code>selector</code> <code>str or datetime</code> <p><code>str</code> instrument when <code>axis=ts</code> and <code>datetime</code> index when <code>axis=xs</code> to perform regression on. Ignored when <code>axis=flatten</code>.</p> <code>None</code> <code>aggregator</code> <code>callable or dict</code> <p>Used for aggregating data within each bin. If callable is provided, then all of the blocks are aggregated using this  function. Different aggregators can be provided for different blocks, by providing dictionary containing <code>block : aggregator</code> such as <code>{\"b0\" : np.mean, \"b1\" : np.median}</code>. Defaults to <code>lambda x:np.mean(winsorize(x, limits=(0.05, 0.05)))</code>.</p> <code>lambda x: mean(winsorize(x, limits=(0.05, 0.05)))</code> <p>Returns:</p> Type Description <code>RegressionResults</code> <p>The statsmodels results  of the OLS regression analysis.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.parse_formula","title":"<code>parse_formula(formula)</code>  <code>staticmethod</code>","text":"<p>Obtains the block-formula mapping and the derived <code>patsy</code> formula describing the regression model.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The regression formula. The formula describes the statistical model being analyzed and follows the syntax of the patsy formula. Supports [ ~ + * : ] operators.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing</p> <ul> <li>dict: Mapping of block names to their respective formula blocks.</li> <li>str: The derived patsy formula representing the regression model.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; GeneticRegression.parse_formula(\"forward_1(logret_1()) ~ div(logret_25(),volatility_25()) + tsargmax_16(close)\")\n({'b0': 'forward_1(logret_1())', 'b1': 'div(logret_25(),volatility_25())', 'b2': 'tsargmax_16(close)'}, 'b0~b1+b2')\n</code></pre>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.plot","title":"<code>plot(fit=True, diagnostics=True, influence=True, leverage=True)</code>","text":"<p>Plots various diagnostic plots for the regression model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>bool</code> <p>If <code>True</code>, plots, for each regressor x,</p> <ul> <li>uCI ~ x</li> <li>lCI ~ x</li> <li>y ~ x</li> <li>y^ ~ x</li> </ul> <code>True</code> <code>diagnostics</code> <code>bool</code> <p>If <code>True</code>, plots, for each regressor x,</p> <ul> <li>y ~ x, y^ ~ x, uCI ~ x, lCI ~ x</li> <li>res ~ x</li> <li>PRP</li> <li>CCPR</li> </ul> <code>True</code> <code>influence</code> <code>bool</code> <p>If <code>True</code>, plots</p> <ul> <li>res* ~ leverage</li> </ul> <code>True</code> <code>leverage</code> <code>bool</code> <p>If <code>True</code>, plots</p> <ul> <li>leverage ~ (res#)**2</li> </ul> <code>True</code>"},{"location":"simulator/operators/","title":"quantpylib.simulator.operators","text":"<p>The <code>quantpylib.simulator.operators</code> is a helper module consisting of operators that are used for data alignment in the evaluation of functions used by the <code>quantpylib.simulator.gene</code>'s Gene class. The semantics of the functions defined and how they operate on the arguments provided depend on the class of operators the primitive belongs to. See the list of primitives here.</p> <p>For example, we may be interested in using as our trading signal the sum of <code>facebook_sentiment</code> and <code>twitter_sentiment</code>, where the former is sampled everyday  and latter is sampled only weekly. The formula <code>plus(facebook_sentiment,twitter_sentiment)</code> can have different interpretations depending on how we want to align data for which one or both of the arguments is <code>nan</code>.</p> <p> last-known basis: this phrase can be construed as forward filling DataFrames and applying the relevant operation.</p> <code>     all_idx_op(op, chress, **kwargs)     </code> <p>Apply a specified operation to each row of the provided DataFrame. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to each row of the DataFrame. It must accept a pandas Series as input and return a pandas Series/numpy.ndarray of same length.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the result of the operation applied to each row of the provided DataFrame.</p> <p>Examples: <pre><code>def test_all_idx_op():\n    data = {'inst1': [3,      5, 2,  np.nan, 8,   np.nan, np.nan, 10, np.nan, 7],\n            'inst2': [np.nan, 5, 12, 9,      15,  np.nan, 8,      13, 14,     11]\n            }\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    result = all_idx_op(lambda x: scipy.stats.rankdata(x, method=\"average\", nan_policy=\"omit\"), [df])\n    expected_data = {'inst1':[1.0,    1.5, 1.0, 1.0, 1.0, 1.0, 1.5, 1.0, 1.0, 1.0],\n                    'inst2': [np.nan, 1.5, 2.0, 2.0, 2.0, 2.0, 1.5, 2.0, 2.0, 2.0]}\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(df.index)\n    assert result.columns.equals(df.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     intersect_idx_op(op, insts, aligner, chress, **kwargs)     </code> <p>Perform a intersection operation on index labels and apply a given operation across multiple arrays or pandas DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across arrays/DataFrames.</p> required <code>insts</code> <code>list</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the result DataFrame with.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames or numbers.Number containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the input arrays/DataFrames.</p> <p>Examples: <pre><code>def test_intersect_idx_op():\n    data1 = {'inst1': [np.nan, 2.0,    3,      np.nan, 5], \n             'inst2': [6,      np.nan, 8,      9,      10]}\n\n    data2 = {'inst1': [1.0,    2,      np.nan, np.nan, 5], \n             'inst2': [11,     12,     13,     np.nan, 15]}\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    result = intersect_idx_op(np.add, ['inst1', 'inst2'], aligner, [df1, df2])    \n    expected_data = {\n        'inst1': [np.nan, 4.0,    np.nan, np.nan, 10], \n        'inst2': [17.0,   np.nan, 21,     np.nan, 25]\n    }\n    expected_result = pd.DataFrame(\n        expected_data, index=pd.date_range(start='2022-01-01', periods=5,freq='D')\n    )\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     self_idx_op(op, insts, aligner, win, chress, **kwargs)     </code> <p>Apply a specified operation to each instance in the provided time series data, using a rolling window. Missing arguments are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to each instance in the time series data.  It must accept a pandas Series as input and return a scalar value.</p> required <code>insts</code> <code>list of str</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the results.</p> required <code>win</code> <code>int</code> <p>Window size for the rolling computation.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to each instance, aligned with the provided aligner.</p> <p>Examples: <pre><code>def test_self_idx_op():\n    data = {'inst1': [1, 2,      3, np.nan, 5,  np.nan, np.nan, 8,  np.nan, 10],\n            'inst2': [6, np.nan, 8, 9,      10, np.nan, 12,     13, 14,     15]}\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', end='2022-01-10', freq='D'))\n    result = self_idx_op(np.mean, ['inst1', 'inst2'], aligner, 3, [df])\n\n    expected_data = {\n        'inst1': [\n            np.nan, np.nan, 2.0,    np.nan,   3.333333, np.nan, np.nan,    5.333333,  np.nan, 7.666667\n        ],\n        'inst2': [\n            np.nan, np.nan, np.nan, 7.666667, 9.0,      np.nan, 10.333333, 11.666667, 13.0,   14.0\n        ]\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     self_idx_op2(op, chress, **kwargs)     </code> <p>Apply a specified unary transformation to the provided time series data.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to the provided time series data. It must accept a pandas DataFrame as input and return a pandas DataFrame.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Result of applying the operation to the provided time series data. The output DataFrame will have the same index and columns as the input DataFrame.</p> <p>Examples: <pre><code>def test_self_idx_op2():\n    data = {'inst1': [1, 2,      3, np.nan, 5,  np.nan, np.nan, 8,  np.nan, 10],\n            'inst2': [6, np.nan, 8, 9,      10, np.nan, 12,     13, 14,     15]}\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    result = self_idx_op2(lambda x: -1 * x, [df])\n\n    expected_data = {'inst1':[-1, -2,     -3, np.nan, -5,  np.nan, np.nan, -8,  np.nan, -10],\n                    'inst2': [-6, np.nan, -8, -9,     -10, np.nan, -12,    -13, -14,    -15]\n                }\n    expected_result = pd.DataFrame(\n        expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D')\n    )\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(df.index)\n    assert result.columns.equals(df.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     slow_idx_op(op, insts, aligner, win, chress, **kwargs)     </code> <p>Apply a specified operation to aligned time series data, potentially handling unequal indices. The reference indices aligned to for each inst is the argument with the smallest number of data points. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across time series data. It must accept numpy arrays as input.</p> required <code>insts</code> <code>list of str</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to determine the common index for alignment.</p> required <code>win</code> <code>int</code> <p>Window size for rolling computation. Used for operations that involve a rolling window, such as rolling correlation.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the aligned time series data.</p> <p>Examples: <pre><code>def test_slow_idx_op():\n    data1 = {\n        'inst1': [np.nan, 2,      3,      np.nan, 5,  6,      np.nan, 8,  9,      10], #7 data points\n        'inst2': [6,      np.nan, 8,      9,      10, np.nan, 12,     13, np.nan, 15] #7 data points\n    }\n    data2 = {\n        'inst1': [1,      2,      np.nan, 4,      5,  6,      7,      8, 9,       10], #9 data points\n        'inst2': [11,     12,     13,     np.nan, 15, 16,     17,     18, np.nan, 20] #8 data points\n    }\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', end='2022-01-10', freq='D'))\n    result = slow_idx_op(lambda a,b:np.add(a,b)[0], ['inst1', 'inst2'], aligner, 1, [df1, df2])\n    expected_data = {\n        'inst1': [np.nan, 4.0,    5.0,  np.nan, 10.0, 12.0,   np.nan, 16.0, 18.0,   20.0], #min(7,9)=7, choose df1.inst1.index as reference\n        'inst2': [17.0,   np.nan, 21.0, 22.0,   25.0, np.nan, 29.0,   31.0, np.nan, 35.0] #min(7,8)=7, choose df1.inst2.index as reference\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     union_idx_op(op, insts, aligner, chress, **kwargs)     </code> <p>Perform a union operation on index labels and apply a given operation across multiple arrays or pandas DataFrames. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across arrays/DataFrames.</p> required <code>insts</code> <code>list</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the result DataFrame with.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames or numbers.Number containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the input arrays/DataFrames.</p> <p>Examples: <pre><code>def test_union_idx_op():\n    data1 = {'inst1': [np.nan, 2.0,    3,      np.nan, 5], \n             'inst2': [6,      np.nan, 8,      9,      10]}\n    data2 = {'inst1': [1.0,    2,      np.nan, np.nan, 5], \n             'inst2': [11,     12,     13,     np.nan, 15]}\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n\n    result = union_idx_op(np.add, ['inst1', 'inst2'], aligner, [df1, df2])\n\n    expected_data = {\n        'inst1': [np.nan, 4.0, 5,  np.nan, 10], \n        'inst2': [17.0,   18,  21, 22,     25]\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p>"},{"location":"simulator/performance/","title":"quantpylib.simulator.performance","text":""},{"location":"simulator/performance/#quantpylib.simulator.performance.performance_measures","title":"<code>performance_measures(r, w, periods_in_year=252, plot=False, path='./output')</code>","text":"<p>Calculate and visualize various performance measures of a trading strategy.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Series</code> <p>Time series of returns.</p> required <code>w</code> <code>DataFrame</code> <p>DataFrame of weights corresponding to each asset over time, with same index as r.</p> required <code>periods_in_year</code> <code>int</code> <p>Number of time periods in a year for the granularity of return series passed in. Defaults to 252, the number of trading days in a year.</p> <code>252</code> <code>plot</code> <code>bool</code> <p>Whether to generate and save plots. Defaults to True.</p> <code>False</code> <code>path</code> <code>str</code> <p>Path to save generated plots, if plot=True</p> <code>'./output'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul>"},{"location":"simulator/simulator/","title":"simulator","text":"<p>This page describes how you may use our <code>quantpylib.simulator</code> module and the functionalities exposed by our APIs. This module provides comprehensive backtesting functionality and statistical tools to analyse your own trading strategies. The core backtesting engine is made available via the <code>quantpylib.simulator.alpha</code> module's <code>Alpha</code> class, which leverages in-house statistical packages such as monte-carlo permutation hypothesis tests and performance metrics computation. This feature is further enhanced by our evaluator-parser in the <code>quantpylib.simulator.gene</code> module's <code>Gene</code> class, which is leveraged by the <code>GeneticAlpha</code> class to bring simple, efficient, accurate and no-code 'batteries-included' backtesting functionality.</p> <p>A high-level walkthrough of the individual quant packages are presented in this page. Comprehensive documentation may be found in the respective pages. To follow along, make sure you have installed the necessary dependencies. Code example scripts are also provided in the repo. Suppose we would like to test some trading strategy ideas, as well as run some tests and performance metrics on them. The trading strategies may be encoded via the succinct rules as follows: <pre><code>example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\"\nexample2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\" \nexample3=\"mac_50/100(close)\"\n</code></pre> <code>example1</code> tests for some intraday-effects, <code>example2</code> tests for mean-reversionary effects on risk-adjusted returns, and <code>example3</code> is a simple trend following strategy. The first two-examples are long-short market neutral strategies and third-example is a long-only strategy.</p>"},{"location":"simulator/simulator/#examples","title":"Examples","text":""},{"location":"simulator/simulator/#backtesting","title":"Backtesting","text":"<p>In this section we demonstrate how to run backtesting with <code>quantpylib.simulator.alpha</code>. We would need the following imports:</p> <p><pre><code>import pytz\nimport yfinance\nimport requests\nimport threading\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom bs4 import BeautifulSoup\nimport matplotlib.pyplot as plt \n\nfrom quantpylib.simulator.alpha import Alpha\nfrom quantpylib.simulator.gene import GeneticAlpha\n</code></pre> First, determine the universe of instruments you would like to trade. Take for instance, the SP500 universe. We would poll this from wikipedia and take the first 100 tickers polled, and then get their  historical OHLCV data from <code>yfinance</code>. We would like to test for a period from 1 Jan 2000 to the current date.</p> <p>We write some code to poll data from the free open-source <code>yfinance</code> library:</p>  Code for Polling OHLCV Data  <pre><code>def get_sp500_tickers():\n    res = requests.get(\"https://en.wikipedia.org/wiki/List_of_S%26P_500_companies\")\n    soup = BeautifulSoup(res.content,'html')\n    table = soup.find_all('table')[0] \n    df = pd.read_html(str(table))\n    tickers = list(df[0].Symbol)\n    return tickers\n\ndef get_history(ticker,period_start,period_end,granularity=\"1d\",tries=0):\n    try:\n        df = yfinance.Ticker(ticker).history(\n            start=period_start,\n            end=period_end,\n            interval=granularity,\n            auto_adjust=True\n        ).reset_index()\n    except Exception as err:\n        if tries &lt; 5:\n            return get_history(ticker,period_start,period_end,granularity,tries+1)\n        return pd.DataFrame()\n\n    df = df.rename(columns={\n        \"Date\":\"datetime\",\n        \"Open\":\"open\",\n        \"High\":\"high\",\n        \"Low\":\"low\",\n        \"Close\":\"close\",\n        \"Volume\":\"volume\"\n    })\n    if df.empty:\n        return pd.DataFrame()\n    df.datetime = pd.DatetimeIndex(df.datetime.dt.date).tz_localize(pytz.utc)\n    df = df.drop(columns=[\"Dividends\", \"Stock Splits\"])\n    df = df.set_index(\"datetime\",drop=True)\n    return df\n\ndef get_histories(tickers, period_starts,period_ends, granularity=\"1d\"):\n    dfs = [None]*len(tickers)\n    def _helper(i):\n        print(tickers[i])\n        df = get_history(\n            tickers[i],\n            period_starts[i], \n            period_ends[i], \n            granularity=granularity\n        )\n        dfs[i] = df\n    threads = [threading.Thread(target=_helper,args=(i,)) for i in range(len(tickers))]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n    tickers = [tickers[i] for i in range(len(tickers)) if not dfs[i].empty]\n    dfs = [df for df in dfs if not df.empty]\n    return tickers, dfs\n\ndef get_ticker_dfs(start,end,tickers):\n    starts=[start]*len(tickers)\n    ends=[end]*len(tickers)\n    tickers,dfs = get_histories(tickers,starts,ends,granularity=\"1d\")\n    ticker_dfs = {ticker:df for ticker,df in zip(tickers,dfs)}    \n    return tickers, ticker_dfs \n</code></pre> <p>We now want to use our <code>quantpylib.simulator.alpha.Alpha</code> class engine to drive our backtest simulations. We would have to implement the abstract methods to test out our trading strategy. The abstract methods are  <code>compute_signals</code>, <code>compute_forecasts</code>. The documentation also suggests that we may optionally implement  <code>instantiate_eligibilities_and_strat_variables</code> to refine our trading universe. </p> <p>Let's create a class for that  <pre><code>class Example1(Alpha):\n    async def compute_signals(self,index=None):\n        pass\n\n    def instantiate_eligibilities_and_strat_variables(self, eligiblesdf):\n        pass\n\n    def compute_forecasts(self, portfolio_i, dt, eligibles_row):\n        pass\n</code></pre></p> <p>Let us fill in the blanks to get a concrete implementation:</p> <pre><code>class Example1(Alpha):\n    async def compute_signals(self,index=None):\n        '''\n        ls_10/90(\n            mult(\n                div(\n                    minus(low,close),\n                    minus(high,low)\n                ),\n                div(open,close)\n            )\n        )\n        '''\n        alphas = []\n        for inst in self.instruments:\n            alpha = (self.dfs[inst].low - self.dfs[inst].close) \\\n                / (self.dfs[inst].high - self.dfs[inst].low ) \\\n                * (self.dfs[inst].open / self.dfs[inst].close)\n            alphas.append(alpha.replace([np.inf, -np.inf], np.nan))\n\n        alphadf = pd.concat(alphas, axis=1) #outer join, take the union of the different datetime indices\n        alphadf.columns = self.instruments\n        alphadf = pd.DataFrame(index=index).join(alphadf).ffill()\n        is_short = lambda x: x &lt; np.nanpercentile(x,10)\n        is_long = lambda x: x &gt; np.nanpercentile(x,90)\n        self.alphadf = alphadf.apply(lambda row: (-1*(0+is_short(row)))+(0+is_long(row)),axis=1)\n\n    def instantiate_eligibilities_and_strat_variables(self, eligiblesdf):\n        eligblesdf = eligiblesdf &amp; (~pd.isna(self.alphadf))\n        return eligblesdf\n\n    def compute_forecasts(self, portfolio_i, dt, eligibles_row):\n        forecast = self.alphadf.loc[dt]\n        return forecast\n</code></pre> <p>We notice that the alpha forecast is an array of values consisting of elements of <code>[-1,0,1]</code>, representing short, neutral and long positions respectively. It should be noted that this alpha forecast is not restricted any set of discrete values, or magnitude - only the relative scale of the forecasts w.r.t other values in the array matter. Our <code>Alpha</code> backtesting engine automatically adjusts for the position sizing cross sectionally and across time through a combination of forecast size, instrument volatility and strategy volatility, using volatility targeting as risk control. The volatility targeted may be set by a (optional) parameter <code>portfolio_vol</code> to an instance of the <code>Alpha</code> class in the constructor. Now, we can call the <code>async</code> <code>run_simulation</code> method to get backtest results.</p> <p>The <code>Alpha</code> class takes in some parameters for our backtest strategy, including backtest date ranges, tickers and ticker data. Let's try to run our strategy now:</p> <p><pre><code>async def main():\n    example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\n    example2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\"\n    example3=\"mac_50/100(close)\"\n\n    period_start = datetime(2000,1,1, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = get_sp500_tickers()[:100]\n    tickers, ticker_dfs = get_ticker_dfs(start=period_start,end=period_end,tickers=tickers)\n    configs={\n        \"start\":period_start,\n        \"end\":period_end,\n        \"instruments\":tickers,\n        \"dfs\":ticker_dfs,\n    }\n\n    alpha1 = Example1(**configs)\n    df1 = await alpha1.run_simulation()\n    print(df1)\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())    \n</code></pre> We obtain an output in our console a dataframe consisting of the details of our backtest simulations: <pre><code>terminal value 1237397.022956312\n                           MMM units  AOS units    ABT units  ADBE units  AES units  AFL units  A units  ...  exec_penalty  comm_penalty  swap_penalty  cost_penalty  nominal_ret  capital_ret       capital\n2000-01-01 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-02 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-03 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-04 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-05 00:00:00+00:00        0.0        0.0     0.000000    0.000000  -2.207572   8.323184      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n...                              ...        ...          ...         ...        ...        ...      ...  ...           ...           ...           ...           ...          ...          ...           ...\n2024-02-02 00:00:00+00:00        0.0        0.0  2491.717072 -296.303782   0.000000   0.000000      0.0  ...           0.0           0.0          -0.0           0.0     0.004586     0.005435  1.235953e+06\n2024-02-03 00:00:00+00:00        0.0        0.0  2540.356454 -302.087758   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.235953e+06\n2024-02-04 00:00:00+00:00        0.0        0.0  2540.356454 -302.087758   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.235953e+06\n2024-02-05 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0          -0.0           0.0     0.001004     0.001168  1.237397e+06\n2024-02-06 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.237397e+06\n</code></pre> From this dataframe, we are able to see our pnl, individual positions held, portfolio allocation, notional exposure, leverage, trading costs (swap/execution/commissions if defined) and more.</p>"},{"location":"simulator/simulator/#no-code-backtesting","title":"No-Code Backtesting","text":"<p>Continuing with our code from the Backtesting section, although all we had to do was to implement a couple or so abstract methods for signal computation and forecasts depending our strategy/formula, we want to take an even more hands-off approach and skip implementing the signal logic all together. A no-code solution gives us a more robust approach, as we may make errors in the implementation of the signal compute. For instance, since the division operator involved in the formula for <code>Example1</code> may cause <code>ZeroDivisionError</code>, without the line <code>alphas.append(alpha.replace([np.inf, -np.inf], np.nan))</code>, we would be making logical errors.</p> <p>The functionality to parse mathematical/formulaic strings and evaluate them is implemented in our <code>quantpylib.simulator.gene.Gene</code> class and made accessible as an <code>Alpha</code> instance via the <code>quantpylib.simulator.gene.GeneticAlpha</code> module. The <code>GeneticAlpha</code> class inherits from the <code>Alpha</code> class like <code>Example1</code>, but instead of having to implement the three functions, all the computation is done via an automatic evaluator and the abstract methods are implemented internally.</p> <p>The <code>GeneticAlpha</code> takes a <code>str</code> or <code>Gene</code> object in addition to the parameters in the <code>Alpha</code> object. The formulaic representation, syntax and primitives supported by our <code>Gene</code> parser is given here.</p> <p>Continuing from the previous code, <pre><code>async def main():\n\n    '''\n    ...\n    '''\n\n    _alpha1 = GeneticAlpha(genome=example1,**configs)\n    _df1 = await _alpha1.run_simulation()\n    print(_df1)\n\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3,**configs, portfolio_vol=0.10)\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    print(df2)    \n    print(df3)\n</code></pre> All three examples are well defined by our list-of-primitives and supported by our parser-evaluator, so we can get the backtest results without having to write logic code. We may plot their logarithmic wealth: <pre><code>    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> </p>"},{"location":"simulator/simulator/#crypto-currencies-fees-and-customization","title":"Crypto, Currencies, Fees and Customization","text":"<p>The <code>Alpha</code> library backtesting example from the Backtesting section used daily data, but it is capable of performing backtest logic on finer granularities and on weekends/holidays. If the trading intervals are finer than daily periods, it should also be specified whether trading is around the clock (24 hours, as in currency and crypto) or RTH (6.5 hours standard). This is to adjust the internal accounting for volatility and performance metric computation. Currently, hourly and daily granularities are supported. </p> <p>We may specify parameters such as the execution fees, commission fees, swap/funding rates, granularity period, portfolio volatility, positional inertia, availability of weekend and around-the-clock trading and starting capital.</p> <p>We shall demonstrate with examples. To aid us in the data retrieval, we will use our <code>quantpylib.datapoller</code> module. Although we can use <code>str</code> alias <code>d</code>, <code>h</code> to indicate daily and hourly granularities, for clarity, we use <code>quantpylib.standards.Period</code>.</p> <p>We will use the no-code backtesting discussed in the previous section for brevity, but all the changes apply to both <code>Alpha</code> and <code>GeneticAlpha</code> instances. We will need the following imports: <pre><code>import pytz\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\nfrom quantpylib.standards import Period\nfrom quantpylib.datapoller.master import DataPoller\nfrom quantpylib.simulator.gene import GeneticAlpha\n</code></pre> We instantiate the data poller with just the <code>binance</code> client: <pre><code>keys = {\"binance\": {}}\ndatapoller = DataPoller(config_keys=keys)\ninterval = Period.HOURLY\n\nasync def main():\n    #...examples as before\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> Let's set up the data and alpha formulas, which we also used to backtest equities: <pre><code>    example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\"\n    example2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\"\n    example3=\"mac_50/100(close)\"\n\n    period_start = datetime(2010,10,2, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = [\"BTCUSDT\",\"ETHUSDT\",\"SOLUSDT\"]\n    ticker_dfs = await asyncio.gather(*[datapoller.crypto.get_trade_bars(\n        ticker=ticker,\n        start=period_start,\n        end=period_end,\n        granularity=interval,\n        granularity_multiplier=1,\n        src=\"binance\"\n    ) for ticker in tickers])\n    dfs = {ticker:df for ticker,df in zip(tickers,ticker_dfs)}\n</code></pre> Even though the Binance API allows default of 500 and maximum of 1000 candles per request, our <code>DataPoller</code> gracefully strings together multiple requests and paces out the requests to get us the required interval data. The specifics of these should be referred to in the <code>quantpylib.datapoller</code> module.</p> <p>Let us make this fit to the crypto market configuratons and time intervals. We first examine zero-cost performance, specify 24/7 trading and use <code>Period.HOURLY</code> interval. Instead of specifying start and end backtest dates, we can actually let the <code>Alpha</code> engine guess these parameters from the range of the dataframes provided in <code>dfs</code>, if we want the maximum possible range. Other than specifying the config arguments differently, all other code remains the same. <pre><code>    configs={\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"execrates\": [0] * len(tickers),\n        \"longswps\": [0] * len(tickers),\n        \"shortswps\": [0] * len(tickers),\n        \"granularity\": interval,\n        \"around_the_clock\":True,\n        \"weekend_trading\":True\n    }\n\n    alpha1 = GeneticAlpha(genome=example1,**configs)\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3 ,**configs, portfolio_vol=0.10)\n    df1 = await alpha1.run_simulation()\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> We see that <code>alpha1</code> and <code>alpha2</code> performed reasonably in the crypto markets too. </p> <p>However, for a more realistic modelling, we would need to model the costs of transacting. In practice, we are also unlikely to fully rebalance to the optimal portfolio due to transaction costs. Let us try to take these into consideration. First, a reasonable execution fee is <code>0.0003</code> (this sits slightly higher than the maker-fees for trading USDT perpetuals on Binance for Regular User status). For simplicity, we assume a <code>10%</code> APR funding rate for  perps. To restrict constant rebalancing, we rebalance each position only when held position sits at distance greater than <code>20%</code> from its optimal position. Let's run a new config: <pre><code>    configs={\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"execrates\": [0.0003] * len(tickers),\n        \"longswps\": [0.1] * len(tickers), #annualized\n        \"shortswps\": [-0.1] * len(tickers),\n        \"granularity\": interval,\n        \"around_the_clock\":True,\n        \"weekend_trading\":True,\n        \"positional_inertia\": 0.20,\n    }\n\n    alpha1 = GeneticAlpha(genome=example1,**configs)\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3 ,**configs)\n    df1 = await alpha1.run_simulation()\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> We see that with exception of the trend-following model, the other two alphas are abysmal under the consideration of costs. This is because the trend-following model has a signal that innately rebalances slower. To reduce costs, we need to employ one or more of (i) finding slower updating alpha forecasts, (ii) increase inertia to trade, (iii) improve the actual execution model, or (iv) trade on larger timeframes. This of course must be performed relative to the EV of the position rebalanced to. </p>  As of date, the starting capital specified does not affect the strategy returns. We are looking for contribution on incorporation of impact and reality modelling extensions in relation to transacted size, for a more advanced backtest approach and institutional size."},{"location":"simulator/simulator/#performance-metrics-and-hypothesis-tests","title":"Performance Metrics and Hypothesis Tests","text":"<p>Our batteries-included feature gives us an access to powerful statistical tools to evaluate our trading strategy with a simple function call. This is supported by any <code>BaseAlpha</code> instance, which is indeed sufficed by both <code>Alpha</code> and <code>GeneticAlpha</code> instances.</p> <p><pre><code>async def main():\n\n    '''\n    ...\n    '''\n    print(alpha1.get_performance_measures())\n    print(await alpha1.hypothesis_tests())\n\n    print(_alpha1.get_performance_measures())\n    print(await _alpha1.hypothesis_tests())\n</code></pre> We get access to a wide array of performance measures, including sharpe ratio, sortino ratio, cagr, rolling-cagr, drawdown, VaR and more. The full list should be referenced here. We also get access to monte-carlo permutation hypothesis tests for asset picking, asset timing and overall decision making skills in the trading strategy.</p>"},{"location":"simulator/simulator/#regression-analysis","title":"Regression Analysis","text":"<p>In the no-code backtesting, we used <code>quantpylib.simulator.gene.Gene</code> class functionalities for parsing mathematical/formulaic strings and evaluating them to perform backtest simulations. This parser-evaluator can also be leveraged to provide extremely simple interfaces for powering  regression analysis, as in common-practice in the R, S-like languages. Any regression model involving variables supported by the list-of-primitives can be used. <code>quantpylib.simulator.models</code> features an abstraction layer written on top of this <code>Gene</code> class and <code>statsmodels</code> to perform no-code regression analysis using simple string specifications.</p> <p>An example scenario for quantitative analysis is a momentum study on the impact of normalized  returns on forward one-period daily returns. <pre><code>forward_1(logret_1()) ~ div(logret_25(),volatility_25())\n</code></pre> Let us take the following setup: <pre><code>import pytz\nfrom datetime import datetime\n\nfrom quantpylib.standards import Period\nfrom quantpylib.datapoller.master import DataPoller\nfrom quantpylib.simulator.models import GeneticRegression\n\nkeys = {\"binance\":{}}\ndatapoller = DataPoller(config_keys=keys)\ninterval = Period.DAILY\n\nasync def main():\n    pass\n    #code here\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> We will use our datapoller and run regression tests on some of the 10-biggest coins, using daily intervals and taking data from 2010: <pre><code>    period_start = datetime(2010,1,1, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = [\"BTCUSDT\",\"ETHUSDT\",\"BNBUSDT\",\"SOLUSDT\",\"XRPUSDT\",\"DOGEUSDT\",\"ADAUSDT\",\"DOTUSDT\",\"LINKUSDT\",\"MATICUSDT\"]\n    ticker_dfs = await asyncio.gather(*[datapoller.crypto.get_trade_bars(\n        ticker=ticker,\n        start=period_start,\n        end=period_end,\n        granularity=interval,\n        src=\"binance\"\n    ) for ticker in tickers])\n    dfs = {ticker:df for ticker,df in zip(tickers,ticker_dfs)}\n    configs = {\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"granularity\":interval\n    }\n</code></pre> Since each of the regressors are valid formulas under the list-of-primitives,  we can specify a regression formula and pass it into <code>GeneticRegression</code>: <pre><code>    model = GeneticRegression(\n        formula=\"forward_1(logret_1()) ~ div(logret_25(),volatility_25())\",\n        **configs\n    )\n</code></pre> We will map the formula into blocks, each block being a variable in the regression model: <pre><code>print(model.blockmap) #{'b0': 'forward_1(logret_1())', 'b1': 'div(logret_25(),volatility_25())'}\nprint(model.smf) #b0~b1\nres = model.ols() #statsmodels.regression.linear_model.RegressionResults\nprint(res.summary()) \n</code></pre> The regression output is as follows: <pre><code>                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                     b0   R-squared:                       0.001\nModel:                            OLS   Adj. R-squared:                  0.001\nMethod:                 Least Squares   F-statistic:                     28.11\nDate:                Wed, 01 May 2024   Prob (F-statistic):           1.16e-07\nTime:                        16:48:36   Log-Likelihood:                 28193.\nNo. Observations:               19648   AIC:                        -5.638e+04\nDf Residuals:                   19646   BIC:                        -5.637e+04\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      0.0011      0.000      2.567      0.010       0.000       0.002\nb1             0.0004   7.73e-05      5.301      0.000       0.000       0.001\n==============================================================================\nOmnibus:                     8766.454   Durbin-Watson:                   1.010\nProb(Omnibus):                  0.000   Jarque-Bera (JB):          1610674.284\nSkew:                           1.041   Prob(JB):                         0.00\nKurtosis:                      47.307   Cond. No.                         5.37\n==============================================================================\n</code></pre> The regression results suggest that twenty-five day volatility adjusted returns is statistically significant predictor for forward returns. We may obtain graphs such as fit, confidence intervals, leverage plots, influence plots, PRP and CCPR. Here are some fits:</p> <p></p> <p>and a leverage plot:</p> <p></p> <p>We see that the although we had strong outliers in the standardized residuals, those with extreme residuals tended to have lower leverage values w.r.t the regressor variable hull. We had 19648 observations for the regression, hence the influence plots and other diagnostics may be difficult to interpret. Also, the leverage values indicate how much the model fit depends on these outlier points, but we would like to see for ourself how the models perform when extremes are smoothed/muted out.</p> <p>We also want to create more interpretive analysis and plots. The <code>ols</code> method takes in the number of bins, the block identifier to bin by, bin-method and aggregating method. By default, the binning is done on the response variable axis <code>b0</code>, and binned by equal observation-cardinality intervals. The aggregator defaults to the 0.05-quantile-winsorized-means on both tails, to mute tails common in market contexts. </p> <p>For our sceneario, let us take 100 bins over the <code>b1</code> axis, which is our normalized returns, and take the remaining default options. <pre><code>    res = model.ols(bins=100,bin_block=\"b1\")\n    print(res.summary())\n    model.plot()\n</code></pre> This is our regression summary: <pre><code>                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                     b0   R-squared:                       0.184\nModel:                            OLS   Adj. R-squared:                  0.176\nMethod:                 Least Squares   F-statistic:                     22.11\nDate:                Wed, 01 May 2024   Prob (F-statistic):           8.45e-06\nTime:                        18:03:49   Log-Likelihood:                 418.85\nNo. Observations:                 100   AIC:                            -833.7\nDf Residuals:                      98   BIC:                            -828.5\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      0.0008      0.000      2.259      0.026       0.000       0.002\nb1             0.0003   6.98e-05      4.702      0.000       0.000       0.000\n==============================================================================\nOmnibus:                        4.233   Durbin-Watson:                   1.528\nProb(Omnibus):                  0.120   Jarque-Bera (JB):                4.101\nSkew:                           0.444   Prob(JB):                        0.129\nKurtosis:                       2.559   Cond. No.                         5.36\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n</code></pre> and we get much more interpretive plots:  </p> <p>and all regression studies suggest that momentum exists in cryptocurrency returns over daily timescales. Of course, since the data has been transformed, the interpretation of the regression results and analysis needs to be adjusted in relation to the binning and aggregation techniques employed.</p> <p>The library also supports methods to study multivariable regression, as in the <code>statsmodels</code> package, as well as convenience methods to obtain diagnostics for common issues such as multicollinearity concerns with statistics like condition number and variance-inflation-factors.</p>"},{"location":"simulator/simulator/#simulatoralpha","title":"simulator.alpha","text":""},{"location":"simulator/simulator/#simulatorgene","title":"simulator.gene","text":""},{"location":"simulator/simulator/#simulatormodels","title":"simulator.models","text":""},{"location":"simulator/simulator/#simulatoroperators","title":"simulator.operators","text":""},{"location":"simulator/simulator/#simulatorperformance","title":"simulator.performance","text":""},{"location":"standards/intervals/","title":"quantpylib.standards.intervals","text":"<p>Repo standards for time period intervals.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration representing different time periods for supported data granularity.</p> <p>Attributes:</p> Name Type Description <code>SECOND</code> <p>Represents a second. Value <code>s</code>.</p> <code>MINUTE</code> <p>Represents a minute. Value <code>m</code>.</p> <code>HOURLY</code> <p>Represents an hour. Value <code>h</code>.</p> <code>DAILY</code> <p>Represents a day. Value <code>d</code>.</p> <code>WEEKLY</code> <p>Represents a week. Value <code>w</code>.</p> <code>MONTHLY</code> <p>Represents a month. Value <code>M</code>.</p> <code>YEARLY</code> <p>Represents a year. Value <code>y</code>.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.get_span","title":"<code>get_span(granularity, granularity_multiplier, period_start=None, period_end=None, periods=None)</code>","text":"<p>Get the time span based on the specified granularity and parameters. granularity, granularity_multipler and periods determine the span duration, if provided.</p> <p>Parameters:</p> Name Type Description Default <code>granularity</code> <code>Period</code> <p>The granularity of time period.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The multiplier for the granularity.</p> required <code>period_start</code> <code>datetime</code> <p>The start of the time period. Defaults to None.</p> <code>None</code> <code>period_end</code> <code>datetime</code> <p>The end of the time period. Defaults to None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the (start,end) of timespan.</p> <p>Raises:</p> Type Description <code>InvalidPeriodConfig</code> <p>If the period configuration is invalid.</p> <code>AssertionError</code> <p>If the provided parameters are invalid.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.map_granularity_to_relativedelta","title":"<code>map_granularity_to_relativedelta(granularity, periods)</code>","text":"<p>Map granularity and number of periods to <code>dateutil.relativedelta.relativedelta</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>granularity</code> <code>Period</code> <p>The granularity of time period.</p> required <code>periods</code> <code>int</code> <p>The number of periods.</p> required <p>Returns:</p> Name Type Description <code>relativedelta</code> <p>Relative delta representing the time period.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the granularity is not a supported type.</p>"},{"location":"standards/markets/","title":"quantpylib.standards.markets","text":"<p>Repo standards relating to markets.</p> <p>The (standard) data types recommended for each information type.</p>"},{"location":"standards/markets/#trading-system-constants","title":"Trading System Constants","text":"<p>This module defines various constants used throughout the trading system. These constants are used for defining fields in transaction records, account details, order types, and more.</p>"},{"location":"standards/markets/#general-constants","title":"General Constants","text":"<ul> <li><code>TIMESTAMP</code> (int): \"timestamp\"</li> <li><code>TICKER</code> (str): \"ticker\"</li> <li><code>AMOUNT</code> (Decimal): \"amount\"</li> <li><code>PRICE</code> (float): \"price\"</li> <li><code>ENTRY</code> (Decimal): \"entry\"</li> <li><code>LEVERAGE</code> (float): \"leverage\"</li> <li><code>LIQUIDATION</code> (float): \"liquidation\"</li> <li><code>MARGIN</code> (float): \"margin\"</li> <li><code>VALUE</code> (Decimal): \"value\"</li> <li><code>REALIZED_PNL</code> (float): \"realized_pnl\"</li> <li><code>UNREALIZED_PNL</code> (float): \"unrealized_pnl\"</li> </ul>"},{"location":"standards/markets/#account-constants","title":"Account Constants","text":"<ul> <li><code>ACCOUNT_EQUITY</code> (float): \"equity_total\"</li> <li><code>ACCOUNT_WITHDRAWABLE</code> (float): \"equity_withdrawable\"</li> <li><code>ACCOUNT_NOTIONAL_POS</code> (float): \"notional_position\"</li> <li><code>MARGIN_MAINTENANCE</code> (float): \"margin_maintenance\"</li> <li><code>MARGIN_TOTAL</code> (float): \"margin_total\"</li> </ul>"},{"location":"standards/markets/#order-constants","title":"Order Constants","text":"<ul> <li><code>LIMIT_PRICE</code> (float): \"limit_price\"</li> <li><code>ORDER_ID</code> (str): \"order_id\"</li> <li><code>ORDER_TAG</code> (str): \"order_tag\"</li> <li><code>ORDER_TOFILL</code> (Decimal): \"amount_left\"</li> <li><code>ORDER_AMOUNT</code> (Decimal): \"amount_total\"</li> </ul>"},{"location":"standards/markets/#order-types","title":"Order Types","text":"<ul> <li><code>ORDER_TYPE</code> (str): \"order_type\"</li> <li><code>ORDER_TYPE_MARKET</code> (str): \"market\"</li> <li><code>ORDER_TYPE_LIMIT</code> (str): \"limit\"</li> <li><code>ORDER_TYPE_STOP_MARKET</code> (str): \"stop_market\"</li> <li><code>ORDER_TYPE_STOP_LIMIT</code> (str): \"stop_limit\"</li> <li><code>ORDER_TYPE_TWAP</code> (str): \"twap\"</li> </ul>"},{"location":"standards/markets/#price-match-types","title":"Price Match Types","text":"<ul> <li><code>PRICE_MATCH_OPPONENT_1</code> (str): \"OPPONENT\"</li> <li><code>PRICE_MATCH_OPPONENT_5</code> (str): \"OPPONENT_5\"</li> <li><code>PRICE_MATCH_OPPONENT_10</code> (str): \"OPPONENT_10\"</li> <li><code>PRICE_MATCH_OPPONENT_20</code> (str): \"OPPONENT_20\"</li> <li><code>PRICE_MATCH_QUEUE_1</code> (str): \"QUEUE\"</li> <li><code>PRICE_MATCH_QUEUE_5</code> (str): \"QUEUE_5\"</li> <li><code>PRICE_MATCH_QUEUE_10</code> (str): \"QUEUE_10\"</li> <li><code>PRICE_MATCH_QUEUE_20</code> (str): \"QUEUE_20\"</li> </ul>"},{"location":"standards/markets/#time-in-force-constants","title":"Time In Force Constants","text":"<ul> <li><code>TIME_IN_FORCE</code> (str): \"tif\"</li> <li><code>TIME_IN_FORCE_GTC</code> (str): 'GTC'</li> <li><code>TIME_IN_FORCE_IOC</code> (str): 'IOC'</li> <li><code>TIME_IN_FORCE_FOK</code> (str): 'FOK'</li> <li><code>TIME_IN_FORCE_GTD</code> (str): 'GTD'</li> <li><code>TIME_IN_FORCE_MOC</code> (str): 'MOC'</li> <li><code>TIME_IN_FORCE_MOO</code> (str): 'MOO'</li> <li><code>TIME_IN_FORCE_ALO</code> (str): \"ALO\"</li> </ul>"},{"location":"standards/markets/#contract-constants","title":"Contract Constants","text":"<ul> <li><code>SYMBOL_MIN_QTY</code> (Decimal): \"min_qty\"</li> <li><code>SYMBOL_PRICE_PRECISION</code> (int): \"price_precision\"</li> <li><code>SYMBOL_QUOTE_PRECISION</code> (int): \"quote_precision\"</li> <li><code>SYMBOL_QUANTITY_PRECISION</code> (int): \"quantity_precision\"</li> <li><code>SYMBOL_MIN_NOTIONAL</code> (float): \"min_notional\"</li> </ul>"},{"location":"standards/standards/","title":"quantpylib.standards","text":"<p>Repo standards and constants.</p>"},{"location":"throttler/aiohttp/","title":"quantpylib.throttler.aiohttp","text":""},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.NetworkException","title":"<code>NetworkException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception class for network errors, capturing the status code, error message, function name, and class name.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>str</code> <p>The HTTP status code of the error. Defaults to an empty string.</p> <code>''</code> <code>message</code> <code>str</code> <p>The error message. Defaults to 'Network error occurred'.</p> <code>'Network error occurred'</code> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>str</code> <p>The HTTP status code of the error.</p> <code>message</code> <code>str</code> <p>The error message.</p> <code>function_name</code> <code>str</code> <p>The name of the function where the error occurred.</p> <code>class_name</code> <code>str</code> <p>The name of the class where the error occurred.</p> <code>descriptive_message</code> <code>str</code> <p>The complete error message including function and class name.</p>"},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.asession_requests_get","title":"<code>asession_requests_get(urls, asemaphore=None, costs=None, refunds_in=None)</code>  <code>async</code>","text":"<p>Perform asynchronous HTTP GET requests.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>A list of URLs to request.</p> required <code>asemaphore</code> <code>AsyncRateSemaphore</code> <p>An asynchronous semaphore to limit concurrent requests. Defaults to None.</p> <code>None</code> <code>costs</code> <code>list</code> <p>A list of costs for each request in terms of semaphore credits. Defaults to None.</p> <code>None</code> <code>refunds_in</code> <code>list</code> <p>A list of refund times for each request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of responses, with exceptions if any occurred.</p> <p>Raises:</p> Type Description <code>NetworkException</code> <p>If a request fails with a non-200 status code.</p>"},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.asession_requests_post","title":"<code>asession_requests_post(urls, payloads, asemaphore=None, costs=None, refunds_in=None)</code>  <code>async</code>","text":"<p>Perform asynchronous HTTP POST requests.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>A list of URLs to request.</p> required <code>payloads</code> <code>list</code> <p>A list of payloads to send in the POST requests.</p> required <code>asemaphore</code> <code>AsyncRateSemaphore</code> <p>An asynchronous semaphore to limit concurrent requests. Defaults to None.</p> <code>None</code> <code>costs</code> <code>list</code> <p>A list of costs for each request in terms of semaphore credits. Defaults to None.</p> <code>None</code> <code>refunds_in</code> <code>list</code> <p>A list of refund times for each request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of responses, with exceptions if any occurred.</p> <p>Raises:</p> Type Description <code>NetworkException</code> <p>If a request fails with a non-200 status code.</p>"},{"location":"throttler/aiosonic/","title":"quantpylib.throttler.aiosonic","text":""},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>An asynchronous HTTP aiosonic client for fast network requests and (de)serialization  of data packets. Automatic retries and error handling.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for all requests. Defaults to an empty string.</p> <code>''</code> <code>json_decoder</code> <code>callable</code> <p>The JSON decoder function to use. Defaults to <code>orjson.loads</code>.</p> <code>loads</code>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Clean up the HTTP client session, ensuring proper resource deallocation.</p> <p>Returns:</p> Type Description <p>None</p>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.handler","title":"<code>handler(response)</code>  <code>async</code>","text":"<p>Handle the HTTP response, returning the JSON-decoded content or raising an HTTPException on error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>HTTPResponse</code> <p>The HTTP response object to handle.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON-decoded response if the status code is less than 400.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.request","title":"<code>request(url='', endpoint='', method='GET', headers={'content-type': 'application/json'}, params=None, data=None, retries=2)</code>  <code>async</code>","text":"<p>Make an HTTP request and handle retries on failure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The full URL for the request. If not provided, <code>base_url</code> + <code>endpoint</code> is used. Defaults to an empty string.</p> <code>''</code> <code>endpoint</code> <code>str</code> <p>The endpoint to append to the base URL. Defaults to an empty string.</p> <code>''</code> <code>method</code> <code>str</code> <p>The HTTP method to use. Defaults to 'GET'.</p> <code>'GET'</code> <code>headers</code> <code>dict</code> <p>The headers to include in the request. Defaults to {\"content-type\": \"application/json\"}.</p> <code>{'content-type': 'application/json'}</code> <code>params</code> <code>dict</code> <p>The URL parameters to include in the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict or str</code> <p>The data to include in the request body. Defaults to None.</p> <code>None</code> <code>retries</code> <code>int</code> <p>The number of retries if the request fails. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The parsed JSON response if the request is successful.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPException","title":"<code>HTTPException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception class for HTTP errors, capturing the status code, error message, and response headers.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>The HTTP status code of the error.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>headers</code> <code>dict</code> <p>The response headers associated with the error.</p> required"},{"location":"throttler/decorators/","title":"quantpylib.throttler.decorators","text":"<p>Examples for both decorator usage, and synchronous, asynchronous semaphores are given here.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.aconsume_credits","title":"<code>aconsume_credits(_func=None, *, costs, refund_in, attrname='rate_semaphore', timeout=0, verbose=False)</code>","text":"<p>Decorator to wrap an asynchronous instance-level coroutine as an asynchronous transaction within a rate-limited semaphore. The return value is the return value of the decorated coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>coroutine</code> <p>The asynchronous coroutine to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the AsyncRateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>timeout</code> <code>float</code> <p>The maximum time in seconds to wait for the transaction to complete. Defaults to 0, which waits indefinitely.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>False</code> <p>Returns:</p> Type Description <code>any</code> <p>The return value of the decorated coroutine.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p> <code>TimeoutError</code> <p>If wrapped transaction takes longer than the specified timeout.</p> Notes <p>For a timed-out transaction that does not get a chance to run due to it sitting  behind other transactions that are opportunistically processed,  a <code>RuntimeWarning: Enable tracemalloc to get the object allocation traceback</code>  may be seen together with the <code>asyncio.TimeoutError</code>. This is because the transaction  contains the coroutine, and the transact is wrapped in an asyncio <code>task</code>.  If it is unable to enter the semaphore by timeout,  the coroutine is never awaited and complains when garbage collected.  If the timeout occurs after the coroutine has acquired the semaphore,  this warning will not be seen but the <code>asyncio.TimeoutError</code> will still  be thrown.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.consume_credits","title":"<code>consume_credits(_func=None, *, costs, refund_in, attrname='rate_semaphore', verbose=False)</code>","text":"<p>Decorator to wrap an synchronous instance-level method as an synchronous transaction within a rate-limited semaphore. The return value is the return value of the decorated method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>callable</code> <p>The method to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the RateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>False</code> <p>Returns:</p> Type Description <code>any</code> <p>The return value of the decorated method.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.wrap_in_thread","title":"<code>wrap_in_thread(_func=None, *, costs, refund_in, attrname='rate_semaphore', daemon=False, verbose=True)</code>","text":"<p>Decorator to wrap a synchronous instance-level method into a transaction, and that transaction into a thread.  The return value is a thread, that is not yet alive, and can be activated by invoking the  <code>threading.Thread.start</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>callable</code> <p>The function to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the RateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>daemon</code> <code>bool</code> <p>Whether the thread should be a daemon thread. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Thread</code> <p>The thread with the transaction as target function, where the transaction wraps the decorated function. Not yet alive.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p>"},{"location":"throttler/rate_semaphore/","title":"quantpylib.throttler.rate_semaphore","text":"<p><code>quantpylib.throttler.rate_semaphore</code> is our core rate-limiting and throttling module, and exposes two synchronization tools, the  <code>quantpylib.throttler.rate_semaphore.AsyncRateSemaphore</code> and <code>quantpylib.throttler.rate_semaphore.RateSemaphore</code> classes.</p> <p>Instead of having to write server-dependent code on rate-limiting based on error messages and response headers (say, of a HTTP 429 response), the rate-semaphores make rate-limiting on the client side seamless and easy  by wrapping native Python objects and synchronization primitives. Any Python  function can be rate-limited (with <code>RateSemaphore</code>) and any Python coroutine  can be rate-limited (with <code>AsyncRateSemaphore</code>) by submitting transactions to the semaphores through the <code>transact</code> method. The module is flexible enough to handle both fixed-cost endpoints (specs such as '20 API requests/min') or  variable-cost endpoints (specs such as `5 API credits/getTick', '15 API credits/getOHLCV' with '100 credits/min per client').</p> <p>Users would likely only have to interact with the <code>transact</code> method in both classes to use the synchronization features. Additionally, users may opt to decorate request-functions with our <code>quantpylib.throttler.decorators</code> on instance methods that makes interacting with the semaphores a one-liner.</p> <p>Examples for both decorator usage, and synchronous, asynchronous semaphores are given here.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore","title":"<code>AsyncRateSemaphore</code>","text":"<p>An asynchronous semaphore implementation that limits access to coroutines (known as transactions) based on available credits, and manages credit-debit accounting of a common resource pool. Coroutines to be executed are submitted to the <code>AsyncRateSemaphore.transact</code>  method along with the number of credits it consumes and the time it takes for those credits to be refunded to the resource pool.  Can be used to throttle asynchronous work such as non-blocking API requests or database operations. In most cases, users would only need to interact with the <code>AsyncRateSemaphore.transact</code> method.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.__init__","title":"<code>__init__(credits=1, greedy_entry=False, greedy_exit=True)</code>","text":"<p>Initialize the <code>AsyncRateSemaphore</code> with an initial number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>credits</code> <code>float</code> <p>The initial number of credits the semaphore starts with. Defaults to 1.</p> <code>1</code> <code>greedy_entry</code> <code>bool</code> <p>Determines whether to enforce a FIFO or greedy policy for pending coroutines                             on semaphore entry. Defaults to False.</p> <code>False</code> <code>greedy_exit</code> <code>bool</code> <p>Determines whether to enforce a FIFO or greedy policy for waking up pending coroutines                             on credit refund. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credits</code> is less than 0.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.acquire","title":"<code>acquire(require_credits, refund_time)</code>  <code>async</code>","text":"<p>Acquire the semaphore, decrementing the resource pool by specified number of credits. If the existing resource pool is larger than credits required, decrement the credits and return immediately. If there is not enough credits on entry, do a non-blocking wait until enough resources are freed up. Additionally, if <code>greedy_entry=False</code>, then  the executing transaction will wait behind the earlier pending transactions regardless of the resource  pool availability.</p> <p>Parameters:</p> Name Type Description Default <code>require_credits</code> <code>float</code> <p>The number of credits required to enter the semaphore.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True when the credits were successfully acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.release","title":"<code>release(taken_credits)</code>","text":"<p>Refund the specified number of credits and wake up pending transactions that  are able to execute on the state of the resource pool. Additionally, if <code>greedy_exit=False</code>, then the number of pending transactions  woken up will respect the FIFO order until the resource pool is insufficient for the earliest transaction.</p> <p>Parameters:</p> Name Type Description Default <code>taken_credits</code> <code>float</code> <p>The number of credits to release.</p> required"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.transact","title":"<code>transact(coroutine, credits, refund_time, transaction_id=None, verbose=False)</code>  <code>async</code>","text":"<p>Execute an asynchronous coroutine object using the semaphore for synchronization, utilizing the <code>AsyncRateSemaphore.acquire</code> and <code>AsyncRateSemaphore.release</code> methods for proper synchronization. The refund mechanism is scheduled on the running event loop and the transact method returns without waiting for credits to be refunded. Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> <p>Parameters:</p> Name Type Description Default <code>coroutine</code> <code>coroutine function</code> <p>The coroutine to execute as part of the transaction.</p> required <code>credits</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>transaction_id</code> <code>str</code> <p>Identifier for the transaction. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the executed coroutine.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the coroutine raises any exception.</p> Notes <p>The argument <code>coroutine</code> should NOT be a <code>asyncio.Task</code> object, since any <code>await</code> statements will trigger  its execution on the event loop before the semaphore is acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore","title":"<code>RateSemaphore</code>","text":"<p>A semaphore implementation that limits the access to method/requests (known as transactions) based on available credits, and manages credit-debit accounting of a common resource pool. Functions to be executed are submitted to the <code>RateSemaphore.transact</code>  method along with the number of credits it consumes and the time it takes for those credits to be refunded to the resource pool. Can be used to throttle API requests, database operations and so on. In most cases, the user would only need to interact with the  <code>RateSemaphore.transact</code> method.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.__init__","title":"<code>__init__(credits=1)</code>","text":"<p>Initialize the <code>RateSemaphore</code> with an initial number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>credits</code> <code>float</code> <p>The initial number of credits the semaphore starts with. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credits</code> is less than 0.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.acquire","title":"<code>acquire(require_credits)</code>","text":"<p>Acquire the semaphore, decrementing the resource pool by specified number of credits. If the existing resource pool is larger than credits required, decrement the credits and return immediately. If there is not enough credits on entry, block, wait until  some other thread has called release() until enough resources are freed up. This is done with proper interlocking so that if multiple acquire() calls are blocked,  release() will wake exactly one of them up. The implementation may pick one at random,  so the order in which blocked threads are awakened should not be relied  on and is OS-scheduler dependent.</p> <p>Parameters:</p> Name Type Description Default <code>require_credits</code> <code>float</code> <p>The number of credits required to enter the semaphore.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True when the credits were successfully acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.release","title":"<code>release(taken_credits)</code>","text":"<p>Refund the specified number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>taken_credits</code> <code>float</code> <p>The number of credits to release.</p> required"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.transact","title":"<code>transact(lambda_func, credits, refund_time, transaction_id=None, verbose=False)</code>","text":"<p>Execute a parameter-less function using the semaphore for synchronization, using the <code>RateSemaphore.acquire</code> and <code>RateSemaphore.release</code> methods for proper synchronization. The refund mechanism is scheduled in a worker  thread and the transact method returns without waiting for credits to be refunded. Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> <p>Parameters:</p> Name Type Description Default <code>lambda_func</code> <code>callable</code> <p>The function to execute as part of the transaction. Should not take in any parameters.</p> required <code>credits</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>transaction_id</code> <code>str</code> <p>Identifier for the transaction. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the transaction function.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the transaction function raises any exception.</p> Notes <p>Any function <code>func</code> that takes in <code>*args</code>, <code>**kwargs</code> can easily be used with  the semaphore by passing in <code>lambda_func = lambda : func(*args,**kwargs)</code>.</p>"},{"location":"throttler/throttler/","title":"throttler","text":"<p>This page describes how you may use our <code>quantpylib.throttler</code> module and the functionalities exposed by our APIs. This module contains classes meant for synchronizing, throttling and handling tasks such as network requests efficiently.</p> <p><code>quantpylib.throttler.aiosonic</code> features a HTTP client written on top of <code>aiosonic</code> and <code>orjson</code>, acting as an asynchronous HTTP library optimizing the speed of HTTP requests and handling of data packets.</p> <p><code>quantpylib.throttler.rate_semaphore</code> features both synchronous and asynchronous support for rate-limiting access to function calls via a credit-based semaphore synchronization tool. A simple but common use would be to maximise throughput of API requests to an external server that places rate-limits on the number of API requests per minute/hour with request credits charged against a resource pool. This is made available through the <code>RateSemaphore</code> and <code>AsyncRateSemaphore</code> classes - and can be seen as an extension of the synchronization  primitives <code>threading.Semaphore</code> and <code>asyncio.locks.Semaphore</code> in the Python standard library respectively. The <code>quantpylib.throttler.decorators</code> module provides decorators for instance methods that wraps threads and coroutines to provide seamless integration with the synchronization features.</p> <p><code>quantpylib.throttler.aiohttp</code> features utility functions to batch asynchronous network requests using <code>aiohttp</code> client sessions and optionally, semaphores.</p> <p>A high-level walkthrough of the individual quant packages are presented in this page. Comprehensive documentation may be found in the respective pages. To follow along, make sure you have installed the necessary dependencies. Code example scripts are also provided in the repo.</p>"},{"location":"throttler/throttler/#examples","title":"Examples","text":""},{"location":"throttler/throttler/#aiosonic-client","title":"Aiosonic Client","text":"<p>The module is an efficiency-optimized HTTP request library. The usage is extremely simple. Let's import some HTTP clients for comparison: <pre><code>import asyncio, aiohttp, requests\nfrom quantpylib.throttler.aiosonic import HTTPClient\nfrom quantpylib.utilities.general import stopwatch\n</code></pre> It is simple to create our <code>HTTPClient</code>. Let's set up some parameters for request: <pre><code>url = \"https://api.hyperliquid.xyz\"\nhttp_client = HTTPClient(base_url=url)\n\nrequest = {\n    \"endpoint\":\"/info\",\n    \"method\":\"POST\",\n    \"data\":{\"type\":\"meta\"}\n}\n</code></pre> We want to poll for perpeutals metadata on hyperliquid server. It is as simple as: <pre><code>async def main():\n    print(await http_client.request(**request))\n</code></pre> The client knows to take base url and endpoint provided to send a POST request to the hyperliquid server. The data payload  can be sent as dictionary or string - if sent as dictionary the payload is serialized using the efficient <code>orjson</code> package, as is deserialization of the returned data packet. Of course, all methods such as GET, POST, PUT and DELETE are supported. Let's compare how this fares against other HTTP clients, using the timer from <code>quantpylib.utilities.general</code>. <pre><code>async def _aiohttp_request(session,url,payload):\n    async with session.post(url, json=payload, headers={\"Content-Type\": \"application/json\"}) as response:\n        return await response.json()\n\nasync def main():\n    print(await http_client.request(**request))\n    await timers()\n\nasync def timers():\n    async with aiohttp.ClientSession() as session:\n        for i in range(30):        \n            print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')\n            await stopwatch(units=\"ms\")(http_client.request)(**request),\n            stopwatch(units=\"ms\")(requests.post)(\n                url + request[\"endpoint\"], \n                json=request[\"data\"], \n                headers={\"content-type\": \"application/json\"}\n            ).json()   \n            await stopwatch(units=\"ms\")(_aiohttp_request)(\n                session=session,\n                url=url + request[\"endpoint\"],\n                payload=request[\"data\"]\n            )\n            print('&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;')\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> An example of the timing results look like this: <pre><code>...\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::69ms\npost::225ms\n_aiohttp_request::69ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::75ms\npost::221ms\n_aiohttp_request::87ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::67ms\npost::230ms\n_aiohttp_request::82ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::77ms\npost::226ms\n_aiohttp_request::67ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n...\n</code></pre> It is clear that the blocking, no-cache <code>requests.post</code> method is least performant. Both our requests  using the <code>throttler</code> client and <code>aiohttp</code> client are comparative due to cacheing and maintenance of  the handshake - but the <code>throttler</code> library should edge out  small performance gains due to efficient (de)serialization of messages. This is important if we are working with  large packets. The network latency dominates in most cases, however. It is clear which library is easiest to use.</p>"},{"location":"throttler/throttler/#rate-semaphore","title":"Rate Semaphore","text":"<p>The module is flexible enough to handle both fixed-cost endpoints (specs such as '20 API requests/min') or  variable-cost endpoints (specs such as `5 API credits/getTick', '15 API credits/getOHLCV' with '100 credits/min per client').</p> <p>Suppose we have a financial API endpoint that has rate limits as such:</p> Period Credits Awarded / app 10 seconds 40 <p>The API gives us 40 credits to use every 10 seconds (capped at 40 credits max). Different endpoints can have variable credit costs, depending on the server load. </p> <p>Suppose we have the following endpoints and their respective costs:</p> Endpoint Cost (credits / req) getTick 20 getOHLCV 5..30 getPrice 12.5 ... ... <p>Both synchronous and asynchronous semaphores expose their synchronization features through the <code>semaphore.transact(...)</code> method, which have the same function signature, except  that the first parameter to a synchronous transaction is a parameter-less function, and the first parameter to the asynchronous transaction is a coroutine. Their detailed documentations are defined here.</p> <p>For the demonstration, we require the following imports: <pre><code>import time\nimport random\nimport asyncio\nimport threading\n\nfrom datetime import datetime\nfrom quantpylib.throttler.decorators import wrap_in_thread, aconsume_credits\nfrom quantpylib.throttler.rate_semaphore import RateSemaphore,AsyncRateSemaphore\n</code></pre></p>"},{"location":"throttler/throttler/#synchronous-example","title":"Synchronous Example","text":"<p>Let's begin with the example for the synchronous semaphore, given by the <code>RateSemaphore</code> class. Our objective is to maximise the throughput to a bunch of blocking requests that consume credits on some external server. To simulate blocking requests, such as a <code>requests.get</code> method, we use the <code>time.sleep</code> method. Note that this generalizes to any blocking method. <pre><code>def getTick(work, id):\n    print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n    time.sleep(work)\n    print(f\"{datetime.now()}:: getTick processed {id}\")\n    return True\n\ndef getOHLCV(work, id):\n    print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n    time.sleep(work)\n    print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n    return True\n</code></pre></p> <p>Since we want to maximise throughput, and the function calls block the main thread, we want to create the requests in multiple threads. But since sending all of these requests simultaneously in different threads would overload the market data server (giving us errors/downgraded/blacklisted), we would wrap them in rate-limited transactions and submit them to the semaphore. Let's create some script to run some requests through the semaphore with the <code>transact</code> method : <pre><code>def sync_example():\n    print(\"-----------------------sync with thread-----------------------\")\n    sem = RateSemaphore(40)\n    tick_req = lambda x: getTick(random.randint(1, 5), x)\n    ohlcv_req = lambda x: getOHLCV(random.randint(1, 5), x)\n\n    threads = [\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: tick_req(1), \n            \"credits\":20, \n            \"refund_time\":10, \n            \"transaction_id\":1, #optional\n            \"verbose\":True #optional\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: ohlcv_req(2), \n            \"credits\":30, \n            \"refund_time\":10, \n            \"transaction_id\":2, #optional\n            \"verbose\":True #optional\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: ohlcv_req(3), \n            \"credits\":5, \n            \"refund_time\":10, \n            \"transaction_id\":3, \n            \"verbose\":True\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: tick_req(4), \n            \"credits\":20, \n            \"refund_time\":10, \n            \"transaction_id\":4, \n            \"verbose\":True\n        }),\n    ]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n\nif __name__ == \"__main__\":\n    sync_example()\n</code></pre> We set the verbosity flag to give us information on when the semaphore executed the transactions, so let us observe the printed information log: <pre><code>-----------------------sync with thread-----------------------\n2024-03-28 19:16:27.105953:: TXN 1 acquiring CreditSemaphore\n2024-03-28 19:16:27.106051:: TXN 2 acquiring CreditSemaphore\n2024-03-28 19:16:27.106083:: TXN 1 entered CreditSemaphore...\n2024-03-28 19:16:27.106161:: TXN 3 acquiring CreditSemaphore\n2024-03-28 19:16:27.106303:: TXN 4 acquiring CreditSemaphore\n2024-03-28 19:16:27.106367:: TXN 3 entered CreditSemaphore...\n2024-03-28 19:16:27.106426:: getOHLCV processing 3 takes 4 seconds\n2024-03-28 19:16:27.106449:: getTick processing 1 takes 5 seconds\n2024-03-28 19:16:31.106689:: getOHLCV processed 3\n2024-03-28 19:16:31.106877:: TXN 3 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:32.107982:: getTick processed 1\n2024-03-28 19:16:32.108390:: TXN 1 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:41.109162:: TXN 4 entered CreditSemaphore...\n2024-03-28 19:16:41.109260:: getTick processing 4 takes 2 seconds\n2024-03-28 19:16:43.110862:: getTick processed 4\n2024-03-28 19:16:43.111243:: TXN 4 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:53.113011:: TXN 2 entered CreditSemaphore...\n2024-03-28 19:16:53.113060:: getOHLCV processing 2 takes 3 seconds\n2024-03-28 19:16:56.115643:: getOHLCV processed 2\n2024-03-28 19:16:56.115815:: TXN 2 exits CreditSemaphore, schedule refund in 10...\n</code></pre> It is not difficult to reason with the output. For instance, transactions 1 and 3 entered the semaphore first, while 2, 4 was placed on hold, leaving 40 - 20 - 5 = 15 credits. No other transaction can enter the semaphore. Transaction 3 processes and completes at 31 seconds,  but the credit is only refunded 10 seconds later. We can see that at 41 seconds, the (5) credits from transaction 3 is refunded, giving us 15 + 5 = 20 credits, enough for transaction 4 to enter the semaphore but not 2. The rest of printed log statements are easy to rationalize.</p>"},{"location":"throttler/throttler/#easy-with-decorators","title":"Easy with Decorators","text":"<p>The example given is nice but somewhat unwiedly due to having to wrap the method/function of interest first in a semaphore  transaction, then followed by a <code>threading.Thread</code> object. In many software applications, we have a data-service layer with a poller object/SDK for API calls made to  external servers. A simulated example looks something like this:</p> <p><pre><code>class _Throttler():\n    def __init__(self):\n        self.rate_semaphore=RateSemaphore(31)\n\n    @wrap_in_thread(costs=20,refund_in=10)#,attrname=\"rate_semaphore\",verbose=True (optional-defaults)\n    def _getTick(self, work, id):\n        print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n        time.sleep(work)\n        print(f\"{datetime.now()}:: getTick processed {id}\")\n        return True\n\n    @wrap_in_thread(costs=10,refund_in=10,attrname=\"rate_semaphore\",verbose=True)\n    def _getOHLCV(self, work, id):\n        print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n        time.sleep(work)\n        print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n        return True\n</code></pre> The data-access object is given one or more <code>RateSemaphore</code>  objects corresponding to a unique credit/resource pool. For each  method that makes a resource-consuming request, we can decorate the function using <code>wrap_in_thread</code> with the costs and refund timers as parameters. The decorated function calls then directly return <code>threading.Thread</code> instances wrapping transactions that contain the function request, which can be activated using the <code>threading.Thread.start</code> method. <pre><code>def sync_example():\n    print(\"-----------------------sync with thread-----------------------\")\n    #... previous example\n\n    print(\"-----------------------sync with decorator-----------------------\")\n    throttler = _Throttler()\n    threads = [\n        throttler._getTick(3, 1),\n        throttler._getOHLCV(1, 2),\n        throttler._getTick(3, 3),\n        throttler._getOHLCV(1, 4),\n    ]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n</code></pre> The behavior of the semaphore is similar to the example explored in the previous example.  The printed log statements are hence presented without commentary, but may be rationalized easily. <pre><code>----------------------sync with decorator-----------------------\n2024-03-28 19:16:56.116058:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116154:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116220:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:16:56.116302:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116555:: getTick processing 1 takes 3 seconds\n2024-03-28 19:16:56.116366:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:16:56.116515:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116691:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:16:57.120664:: getOHLCV processed 2\n2024-03-28 19:16:57.120879:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:59.117150:: getTick processed 1\n2024-03-28 19:16:59.117323:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:07.123469:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:07.123532:: getOHLCV processing 4 takes 1 seconds\n2024-03-28 19:17:08.125678:: getOHLCV processed 4\n2024-03-28 19:17:08.126219:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:09.118384:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:09.118482:: getTick processing 3 takes 3 seconds\n2024-03-28 19:17:12.119387:: getTick processed 3\n2024-03-28 19:17:12.119741:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n</code></pre></p>"},{"location":"throttler/throttler/#asynchronous-example","title":"Asynchronous Example","text":"<p>We now move onto the asynchronous semaphore, given by the <code>AsyncRateSemaphore</code> class. Our objective is to maximise the throughput to a bunch of non-blocking requests that consume credits on some external server. To simulate non-blocking requests, such as an  <code>async with session.get</code> method of an <code>aiohttp.ClientSession</code> object or asynchronous database requests, we use the  <code>asyncio.sleep</code> method. Note that this generalizes to any non-blocking coroutine.</p> <pre><code>async def agetTick(work, id):\n    print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n    await asyncio.sleep(work)\n    print(f\"{datetime.now()}:: getTick processed {id}\")\n    return True\n\nasync def agetOHLCV(work, id):\n    print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n    await asyncio.sleep(work)\n    print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n    return True\n</code></pre> <p>Since we want to maximise throughput, and the function calls are coroutines that do not block  the main thread, we want to create the requests concurrently and place them on the event loop. But since sending all of these requests simultaneously in different coroutines would overload the market data server (giving us errors/downgraded/blacklisted), we would wrap them in rate-limited transactions and submit them to the semaphore. Let's create some script to run some request transactions through the semaphore:</p> <p><pre><code>async def async_example():\n    print(\"-----------------------async with transactions-----------------------\")\n    sem = AsyncRateSemaphore(40, greedy_entry=True, greedy_exit=True)\n\n    tick_req = lambda x: agetTick(random.randint(1, 5), x)\n    ohlcv_req = lambda x: agetOHLCV(random.randint(1, 5), x)\n\n    transactions = [\n        sem.transact(coroutine=tick_req(1), credits=20, refund_time=10, transaction_id=1, verbose=True),\n        sem.transact(coroutine=ohlcv_req(2), credits=30, refund_time=10, transaction_id=2, verbose=True),\n        sem.transact(coroutine=ohlcv_req(3), credits=5, refund_time=10, transaction_id=3, verbose=True),\n        sem.transact(coroutine=tick_req(4), credits=20, refund_time=10, transaction_id=4, verbose=True),\n    ]\n    await asyncio.gather(*transactions)\n\nif __name__ == \"__main__\":\n    sync_example() #previous example\n    asyncio.run(async_example())\n</code></pre> We set the verbosity flag to give us information on when the semaphore executed the transactions, so let us observe the printed information log: <pre><code>-----------------------async with transactions-----------------------\n2024-03-28 19:17:12.120864:: TXN 1 acquiring CreditSemaphore\n2024-03-28 19:17:12.120915:: TXN 1 entered CreditSemaphore...\n2024-03-28 19:17:12.120927:: getTick processing 1 takes 4 seconds\n2024-03-28 19:17:12.120964:: TXN 2 acquiring CreditSemaphore\n2024-03-28 19:17:12.120988:: TXN 3 acquiring CreditSemaphore\n2024-03-28 19:17:12.121006:: TXN 3 entered CreditSemaphore...\n2024-03-28 19:17:12.121016:: getOHLCV processing 3 takes 5 seconds\n2024-03-28 19:17:12.121044:: TXN 4 acquiring CreditSemaphore\n2024-03-28 19:17:16.121665:: getTick processed 1\n2024-03-28 19:17:16.121740:: TXN 1 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:17.122353:: getOHLCV processed 3\n2024-03-28 19:17:17.122462:: TXN 3 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:26.123119:: TXN 2 entered CreditSemaphore...\n2024-03-28 19:17:26.123192:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:17:27.123519:: getOHLCV processed 2\n2024-03-28 19:17:27.123633:: TXN 2 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:37.124999:: TXN 4 entered CreditSemaphore...\n2024-03-28 19:17:37.125077:: getTick processing 4 takes 3 seconds\n2024-03-28 19:17:40.126377:: getTick processed 4\n2024-03-28 19:17:40.126493:: TXN 4 exits CreditSemaphore, schedule refund in 10...\n</code></pre> It is not difficult to reason with the output. For instance, transactions 1 and 3 entered the semaphore first, while 2, 4 was placed on hold, leaving 40 - 20 - 5 = 15 credits. No other transaction can enter the semaphore. Transaction 1 processes and completes at 16 seconds,  but the credit is only refunded 10 seconds later. We can see that at 26 seconds, the (20) credits from transaction 1 is refunded, giving us 15 + 20 = 35 credits, enough for transaction 2 to enter the semaphore but not both 2 and 4. 2 is admitted first, and the rest of printed log statements are easy to rationalize.</p>"},{"location":"throttler/throttler/#easy-with-decorators_1","title":"Easy with Decorators","text":"<p>The example given is nice but somewhat unwiedly due to having to wrap the method/function of interest in semaphore transactions. We would like to hide  the throttling intricacies at the caller level, such that a user of said data-access layer  or SDKs do not need to be aware of the presence of a semaphore. For instance: <pre><code>class _Throttler():\n    def __init__(self):\n        #... previous example\n        self.arate_semaphore=AsyncRateSemaphore(31)\n\n    #... previous example\n\n    @aconsume_credits(costs=20,refund_in=10,attrname=\"arate_semaphore\") #we want the asynchronous semaphore, and since the default name is not rate_semaphore, we pass in attrname\n    async def _agetTick(self, work, id):\n        print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n        await asyncio.sleep(work)\n        print(f\"{datetime.now()}:: getTick processed {id}\")\n        return True\n\n    @aconsume_credits(costs=10,refund_in=10,attrname=\"arate_semaphore\",verbose=True)\n    async def _agetOHLCV(self, work, id):\n        print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n        await asyncio.sleep(work)\n        print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n        return True\n</code></pre> The data-access object is given one or more <code>AsyncRateSemaphore</code> objects corresponding to a unique credit/resource pool. For each  method that makes a resource-consuming request, we can decorate the function using <code>aconsume_credits</code> with the costs and refund timers as parameters. The decorated function calls then are submitted through the object attribute's asynchronous semaphore instance. <pre><code>async def async_example():\n    print(\"-----------------------async with transactions-----------------------\")\n    #... previous example\n\n    print(\"-----------------------async with decorator-----------------------\")\n    throttler = _Throttler()\n    transactions = [\n        throttler._agetTick(3, 1),\n        throttler._agetOHLCV(1, 2),\n        throttler._agetTick(3, 3),\n        throttler._agetOHLCV(1, 4),\n    ]\n    await asyncio.gather(*transactions)\n</code></pre> The behavior of the semaphore is similar to the example explored in the previous example.  The printed log statements are hence presented without commentary, but may be rationalized easily. <pre><code>-----------------------async with decorator-----------------------\n2024-03-28 19:17:40.126936:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127015:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:40.127044:: getTick processing 1 takes 3 seconds\n2024-03-28 19:17:40.127110:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127149:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:40.127170:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:17:40.127217:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127266:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:41.127912:: getOHLCV processed 2\n2024-03-28 19:17:41.128021:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:43.127485:: getTick processed 1\n2024-03-28 19:17:43.127539:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:51.129270:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:51.129314:: getOHLCV processing 4 takes 1 seconds\n2024-03-28 19:17:52.130482:: getOHLCV processed 4\n2024-03-28 19:17:52.130534:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:53.128193:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:53.128281:: getTick processing 3 takes 3 seconds\n2024-03-28 19:17:56.129573:: getTick processed 3\n2024-03-28 19:17:56.129683:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n</code></pre></p>"},{"location":"throttler/throttler/#notes-on-behavior","title":"Notes on Behavior","text":"<ul> <li> <p> Entry Behavior  </p> <ol> <li><code>AsyncRateSemaphore</code> acquires the semaphore if there are enough resources, but if <code>greedy_entry=False</code>, then the submitted transaction will wait behind the earlier pending transactions regardless of the resource pool availability. Otherwise, any submitted transaction that can run immediately will run without consideration for existing waiters.</li> <li><code>RateSemaphore</code> acquires the semaphore immediately if there are enough resources, and  otherwise waits. The order in which blocked threads are awakened should not be relied on and is OS-scheduler dependent.</li> </ol> </li> <li> <p> Exit Behavior   Requests submitted to both semaphore types exit from their respective <code>transact</code> method without waiting for the credits to be refunded. The credits are scheduled to be refunded separately on a thread (for synchronous implementations) or the event loop (for asynchronous implementations). When the credit is refunded </p> <ol> <li> <p><code>AsyncRateSemaphore</code> wakes up pending transactions that are able to execute on the state of the resource pool. If <code>greedy_exit=False</code>, then the number of pending transactions woken up will respect the FIFO order until the resource pool is insufficient for the earliest transaction. Otherwise, when credits are refunded with &gt;=2 waiting transactions with arrival time <code>txn A</code> &lt; <code>txn B</code>. If the semaphore has not enough credits to execute <code>txn A</code>, it can first run <code>txn B</code>. This helps to maximise throughput.</p> </li> <li> <p><code>RateSemaphore</code> wakes up pending transactions that are able to execute on the state of the resource pool. The order in which blocked threads are awakened should not be relied on and is OS-scheduler dependent.</p> </li> </ol> </li> <li> <p> Exception Behavior   Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> </li> </ul>  Note that non-greedy entry and greedy exit can cause resource-expensive transactions to sit behind cheaper transactions which are constantly being submitted to the semaphore at a fast rate, preventing the expensive transaction from acquiring the semaphore."},{"location":"throttler/throttler/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Wrap unstable networks and expensive requests in a timeout transaction. This is to prevent the coroutine from 'await'-ing forever and hogging the semaphore.</p> </li> <li> <p>Since the transactions wrap native Python functions and coroutines, it does not know when the code actually performs the credit-costing request. The <code>transact</code> functions should be closest to the costful logic as possible. It should not perform heavy compute or multiple requests so that the credits can refunded as quickly as possible for other transactions. </p> </li> </ul>"},{"location":"throttler/throttler/#throttlerratesemaphore","title":"throttler.rate_semaphore","text":""},{"location":"throttler/throttler/#throttlerratedecorator","title":"throttler.decorators","text":""},{"location":"wrappers/binance/","title":"quantpylib.wrappers.binance","text":""},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance","title":"<code>Binance</code>","text":""},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to account fill updates - in Binance, this just calls  the <code>order_updates_subscribe</code> method.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe to account fill updates - in Binance, this just calls  the <code>order_updates_unsubscribe</code> method.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up open sessions with Binance server</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.contract_specifications","title":"<code>contract_specifications(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_all_mids","title":"<code>get_all_mids(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_perps_data","title":"<code>get_perps_data(in_decimal=True)</code>  <code>async</code>","text":"<p>Retrieve perpetuals data.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing symbol to perp data with the following perp data structure:</p> <ul> <li>\"baseAsset\" <code>str</code> :             The base asset symbol.</li> <li>\"fr\" <code>float</code> :                  Funding rate.</li> <li>\"frint\" <code>float</code>,                Floating point representation of the funding rate.</li> <li>\"marginAsset\" <code>str</code>,            The margin asset symbol.</li> <li>\"markPrice\" <code>float</code>,            The mark price.</li> <li>\"minQty\" <code>Decimal</code>,             The minimum quantity.</li> <li>\"min_notional\" <code>float</code>,         The minimum notional value.</li> <li>\"next_funding\" <code>int</code>,           Unix timestamp of the next funding, milliseconds.</li> <li>\"pricePrecision\" <code>Decimal</code>,     The price precision.</li> <li>\"quantityPrecision\" <code>Decimal</code>,  The quantity precision.</li> <li>\"quoteAsset\" <code>str</code>,             The quote asset symbol.</li> <li>\"stepSize\" <code>Decimal</code>,           The step size.</li> <li>\"symbol\" <code>str</code>,                 The symbol.</li> <li>\"timestamp\" <code>int</code>,              Unix timestamp of the data retrieval, milliseconds.</li> <li>\"exchange\" <code>str</code>                The exchange code , \"binance\"</li> </ul>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, kline_close=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the exchange client.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_get","title":"<code>l2_book_get(ticker, depth=1000, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve L2 Order Book data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of order book data to retrieve. Defaults to 1000.</p> <code>1000</code> <code>standardize_schema</code> <code>bool</code> <p>Whether to standardize the schema of the retrieved data. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the order book data.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=20, buffer_size=100, as_dict=True, on_update=None, refresh_sec=300, speed_ms=500, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of order book data to retrieve. Defaults to 20.</p> <code>20</code> <code>buffer_size</code> <code>int</code> <p>The size of the buffer to store order book history. Defaults to 100.</p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for the order book updates. Defaults to None.</p> <code>None</code> <code>refresh_sec</code> <code>int</code> <p>The time interval in seconds to refresh the order book snapshot. Defaults to 300.</p> <code>300</code> <code>speed_ms</code> <code>int</code> <p>The speed of stream update. Allowed values are <code>[None,100,250,500]</code>. Defaults to 500.</p> <code>500</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the local mirror copy of the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>bool</code> <p>Whether to return the order book data as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, depth=5, speed_ms=None, fut_type=FuturesType.USD_M, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>depth</code> <code>Optional[int]</code> <p>Depth of order book data received. Defaults to 5.</p> <code>5</code> <code>speed_ms</code> <code>Optional[int]</code> <p>Speed of stream update. Allowed values are <code>[None,100,250,500]</code>.</p> <code>None</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_subscriptions","title":"<code>l2_book_subscriptions(fut_type=FuturesType.USD_M, **kwargs)</code>","text":"<p>Retrieve the list of perpetuals with open subscription.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, fut_type=FuturesType.USD_M, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.limit_order","title":"<code>limit_order(ticker, amount, price=None, price_match=None, tif=markets.TIME_IN_FORCE_GTC, reduce_only=False, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Submit limit order. If both price and price_match is specified, then the price_match is prioritized.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long/short.</p> required <code>price</code> <code>Optional[float]</code> <p>The price at which to execute the order. Defaults to None.</p> <code>None</code> <code>price_match</code> <code>Optional[str]</code> <p>The price matching rule at which to execute the order. Defaults to None. Allowed values are <code>[OPPONENT,OPPONENT_5,OPPONENT_10,OPPONENT_20,QUEUE,QUEUE_5,QUEUE_10]</code> </p> <code>None</code> <code>tif</code> <code>str</code> <p>The time in force. Defaults to \"GTC\". Allowed values are <code>[GTC,IOC,FOK,GTX,GTD]</code>.</p> <code>TIME_IN_FORCE_GTC</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should reduce an existing position only. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.market_order","title":"<code>market_order(ticker, amount, reduce_only=False, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Submit market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>reduce_only</code> <code>bool</code> <p>Whether the order should reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_query","title":"<code>order_query(ticker, oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <code>oid</code> <code>(str, int)</code> <p>Order ID in exchange</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order updates.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order updates.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_get","title":"<code>orders_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_get","title":"<code>positions_get()</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> required"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generate a random string (cloid) consisting of hexadecimal characters.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A random hexadecimal string with a total length of 32 characters,  including the optional 'start' and 'end' strings.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>(ts,price,sz,dir)</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/","title":"quantpylib.wrappers.bybit","text":""},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit","title":"<code>Bybit</code>","text":""},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.__init__","title":"<code>__init__(key='', secret='', key_self_generated=False)</code>","text":"<p>Initializes the Bybit instance.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>API key for authentication. Defaults to empty string.</p> <code>''</code> <code>secret</code> <code>str</code> <p>API secret for authentication. Defaults to empty string.</p> <code>''</code> <code>key_self_generated</code> <code>bool</code> <p>Flag to indicate if RSA authentication is used. Defaults to False.</p> <code>False</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to account fill updates - in Bybit, this just calls  the <code>order_updates_subscribe</code> method.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe to account fill updates - in Bybit, this just calls  the <code>order_updates_unsubscribe</code> method.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_info","title":"<code>account_info()</code>  <code>async</code>","text":"<p>Retrieves general account information.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The account information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Not supported by Bybit.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Not supported by Bybit.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.batch_orders_cancel","title":"<code>batch_orders_cancel(category='linear', cancel_wires=[])</code>  <code>async</code>","text":"<p>Cancels multiple orders in a single batch request.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>cancel_wires</code> <code>list</code> <p>A list of cancel wire dictionaries to be canceled.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the batch order cancellation.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.batch_orders_create","title":"<code>batch_orders_create(category='linear', order_wires=[])</code>  <code>async</code>","text":"<p>Creates multiple orders in a single batch request.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>order_wires</code> <code>list</code> <p>A list of order wire dictionaries to be created.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the batch order creation.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for further customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the cancel to the exchange, else returns the cancel order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up the client sessions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.contract_specifications","title":"<code>contract_specifications(include_prelists=False, contract_type='LinearPerpetual')</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>include_prelists</code> <code>bool</code> <p>Specifies whether to include prelistings.</p> <code>False</code> <code>contract_type</code> <code>str</code> <p>Type of contracts to retrieve. Defaults to <code>LinearPerpetual</code>.</p> <code>'LinearPerpetual'</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.funding_history","title":"<code>funding_history(ticker, category='linear', startTime=None, endTime=None, limit=None)</code>  <code>async</code>","text":"<p>Retrieves the funding rate history for a given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading ticker symbol (e.g., 'BTCUSDT').</p> required <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>startTime</code> <code>int</code> <p>The start time for the funding history in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>endTime</code> <code>int</code> <p>The end time for the funding history in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of records to retrieve. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The funding rate history data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_all_mids","title":"<code>get_all_mids(ticker=None, category='linear', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the contract. Defaults to 'linear'.</p> <code>'linear'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_lot_precision","title":"<code>get_lot_precision(ticker)</code>","text":"<p>Retrieves the lot size precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for lot size precision.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_order_wire","title":"<code>get_order_wire(symbol, amount, orderType, price=None, timeInForce='GTC', reduceOnly=False, orderLinkId=None, **kwargs)</code>","text":"<p>Creates the wire for placing an order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade.</p> required <code>orderType</code> <code>str</code> <p>The type of order (e.g., 'Limit', 'Market').</p> required <code>price</code> <code>float</code> <p>The price for the order. Defaults to None.</p> <code>None</code> <code>timeInForce</code> <code>str</code> <p>The time-in-force for the order (e.g., 'GTC', 'FOK'). Defaults to \"GTC\".</p> <code>'GTC'</code> <code>reduceOnly</code> <code>bool</code> <p>Whether the order is reduce-only. Defaults to False.</p> <code>False</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the order.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order wire data.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_perps_data","title":"<code>get_perps_data(in_decimal=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve perpetuals data.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing symbol to perp data with the following perp data structure:</p> <ul> <li>\"baseAsset\" <code>str</code> :             The base asset symbol.</li> <li>\"fr\" <code>float</code> :                  Funding rate. #</li> <li>\"frint\" <code>int</code>,                  Funding rate interval.</li> <li>\"markPrice\" <code>float</code>,            The mark price. #</li> <li>\"min_notional\" <code>float</code>,         The minimum notional value.</li> <li>\"next_funding\" <code>int</code>,           Unix timestamp of the next funding, milliseconds. #</li> <li>\"pricePrecision\" <code>Decimal</code>,     The price precision.</li> <li>\"quantityPrecision\" <code>Decimal</code>,  The quantity precision.</li> <li>\"quoteAsset\" <code>str</code>,             The quote asset symbol.</li> <li>\"stepSize\" <code>Decimal</code>,           The step size.</li> <li>\"symbol\" <code>str</code>,                 The symbol.</li> <li>\"timestamp\" <code>int</code>,              Unix timestamp of the data retrieval, milliseconds.</li> <li>\"exchange\" <code>str</code>                The exchange code , \"bybit\"</li> </ul>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_price_precision","title":"<code>get_price_precision(ticker)</code>","text":"<p>Retrieves the price precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for price precision.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.index_kline","title":"<code>index_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves index price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The index price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the client by fetching contract specifications and setting up precision mappings.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.instruments_info","title":"<code>instruments_info(category='linear', status='Trading', basecoin=None, symbol=None, limit=1000, cursor='')</code>  <code>async</code>","text":"<p>Retrieves information about trading instruments.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>status</code> <code>str</code> <p>The status of the instrument (e.g., 'Trading'). Defaults to \"Trading\".</p> <code>'Trading'</code> <code>basecoin</code> <code>str</code> <p>The base coin (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of instruments to retrieve. Defaults to 1000.</p> <code>1000</code> <code>cursor</code> <code>str</code> <p>The cursor for pagination. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about trading instruments from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.kline","title":"<code>kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves kline (candlestick) data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., 'D', 'M'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_get","title":"<code>l2_book_get(ticker, depth=25, category='linear', standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the L2 Order Book for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order book. Defaults to 25.</p> <code>25</code> <code>category</code> <code>str</code> <p>Category of the contract. Defaults to 'linear'.</p> <code>'linear'</code> <code>standardize_schema</code> <code>bool</code> <p>If True, returns the order book in a standardized schema. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=50, stream_depth=50, buffer_size=100, as_dict=True, on_update=None, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code></p> <code>50</code> <code>stream_depth</code> <code>int</code> <p>Depth of the l2 stream used to maintain internal order book.</p> <code>50</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code></p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, depth=200, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream updates. Defaults to 200.</p> <code>200</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, depth=200, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream update subscribed. Defaults to 200.</p> <code>200</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.limit_order","title":"<code>limit_order(ticker, amount, price, tif='GTC', reduce_only=False, cloid=None, round_price=False, round_size=False, category='linear', submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>Contract categroy. Defaults to <code>linear</code>.</p> <code>'linear'</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.mark_kline","title":"<code>mark_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves mark price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The mark price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.market_order","title":"<code>market_order(ticker, amount, tif='GTC', reduce_only=False, cloid=None, round_size=False, category='linear', submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>tif</code> <code>str</code> <p>Time in force. Defaults to <code>GTC</code>. Valid values are <code>GTC</code>, <code>IOC</code>, <code>FOK</code>.</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>Contract categroy. Defaults to <code>linear</code>.</p> <code>'linear'</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement. This typically includes a confirmation of the placed order, or an error message if the order could not be placed.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_cancel","title":"<code>order_cancel(symbol, orderId=None, orderLinkId=None, category='linear', orderFilter=None, submit=True)</code>  <code>async</code>","text":"<p>Cancels an existing order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>orderId</code> <code>str</code> <p>The order ID to cancel. Defaults to None.</p> <code>None</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID to cancel. Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>orderFilter</code> <code>str</code> <p>The order filter to apply. Defaults to None.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the cancellation to the exchange. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange if <code>submit</code> is True, otherwise the cancellation payload.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_create","title":"<code>order_create(symbol, amount, orderType, price=None, timeInForce='GTC', reduceOnly=False, category='linear', orderLinkId=None, submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Creates a new order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade.</p> required <code>orderType</code> <code>str</code> <p>The type of order (e.g., 'Limit', 'Market').</p> required <code>price</code> <code>float</code> <p>The price for the order. Defaults to None.</p> <code>None</code> <code>timeInForce</code> <code>str</code> <p>The time-in-force for the order (e.g., 'GTC', 'FOK'). Defaults to \"GTC\".</p> <code>'GTC'</code> <code>reduceOnly</code> <code>bool</code> <p>Whether the order is reduce-only. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID. Defaults to None.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the order.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange if <code>submit</code> is True, otherwise the order wire.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_history","title":"<code>order_history(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves the order history for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order history from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_query","title":"<code>order_query(oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>str</code> <p>Order ID in exchange</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orderbook_depth","title":"<code>orderbook_depth(symbol, category='linear', limit=25)</code>  <code>async</code>","text":"<p>Retrieves the order book depth for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>limit</code> <code>int</code> <p>The number of order book levels to retrieve. Defaults to None.</p> <code>25</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order book depth data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_cancel_all","title":"<code>orders_cancel_all(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancels all open orders for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the cancellation request.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_get","title":"<code>orders_get(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Get open order details.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>optional</code> <p>Retrieve orders for ticker only.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open orders.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_get_realtime","title":"<code>orders_get_realtime(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves real-time information about orders.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The real-time order information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_peek","title":"<code>orders_peek()</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> required"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_get","title":"<code>positions_get(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Get open position details.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>optional</code> <p>Retrieve position for ticker only.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open positions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_info","title":"<code>positions_info(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves information about open positions.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The position information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.premium_index_kline","title":"<code>premium_index_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves premium index price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The premium index price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generates a random client order ID (CLOID).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A randomly generated CLOID.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.server_time","title":"<code>server_time()</code>  <code>async</code>","text":"<p>Retrieves the current server time from the exchange.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The server time data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.signed_payload","title":"<code>signed_payload(payload=None, params=None, recv_window=5000)</code>","text":"<p>Signs the payload or query parameters for an authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The payload to be signed. Defaults to None.</p> <code>None</code> <code>params</code> <code>dict</code> <p>The query parameters to be signed. Defaults to None.</p> <code>None</code> <code>recv_window</code> <code>int</code> <p>The receive window for the request. Defaults to 5000.</p> <code>5000</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the request headers and the signed payload as a JSON string.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.ticker_subscribe","title":"<code>ticker_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to Ticker stream. Args:     ticker (str): Ticker symbol.     handler (coroutine): A coroutine handler for the message received.     **kwargs: Exchange wrapper specific keyword arguments.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.tickers_summary","title":"<code>tickers_summary(symbol=None, category='linear', baseCoin=None, expDate=None)</code>  <code>async</code>","text":"<p>Retrieves a summary of tickers for a given symbol or base coin.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>baseCoin</code> <code>str</code> <p>The base coin (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <code>expDate</code> <code>str</code> <p>The expiration date for futures contracts. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The ticker summary data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from the trade stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.typed_payload","title":"<code>typed_payload(payload)</code>","text":"<p>Converts the payload's parameters to their correct data types.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The payload containing the request parameters.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The payload with corrected data types.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.wallet_balance","title":"<code>wallet_balance(accountType='UNIFIED', coin=None)</code>  <code>async</code>","text":"<p>Retrieves the wallet balance for the specified account type.</p> <p>Parameters:</p> Name Type Description Default <code>accountType</code> <code>str</code> <p>The account type (e.g., 'UNIFIED'). Defaults to 'UNIFIED'.</p> <code>'UNIFIED'</code> <code>coin</code> <code>str</code> <p>The specific coin to retrieve the balance for (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The wallet balance information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.generate_signature","title":"<code>generate_signature(is_rsa, secret, param_str)</code>","text":"<p>Generates a cryptographic signature using either HMAC or RSA based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>is_rsa</code> <code>bool</code> <p>If True, uses RSA for signature generation.  If False, uses HMAC for signature generation.</p> required <code>secret</code> <code>str</code> <p>The secret key used for generating the signature.  For HMAC, this is a shared secret key.  For RSA, this is the private RSA key in PEM format.</p> required <code>param_str</code> <code>str</code> <p>The string of parameters to be signed.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The generated signature in hexadecimal format (for HMAC) or Base64-encoded string (for RSA).</p>"},{"location":"wrappers/eodhd/","title":"quantpylib.wrappers.eodhd","text":""},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd","title":"<code>Eodhd</code>","text":""},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.__init__","title":"<code>__init__(eod_key, **kwargs)</code>","text":"<p>Initialize the Eodhd instance with the API key.</p> <p>Parameters:</p> Name Type Description Default <code>eod_key</code> <code>str</code> <p>API key for accessing the Eodhd API.</p> required"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.check_exchange_open","title":"<code>check_exchange_open(exchange, **kwargs)</code>","text":"<p>Check if a specific exchange is open.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the exchange is open, False otherwise.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_delisted_tickers_in_exchange","title":"<code>get_delisted_tickers_in_exchange(exchange, **kwargs)</code>","text":"<p>Get the list of delisted tickers for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of delisted tickers for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_holidays","title":"<code>get_exchange_holidays(exchange, **kwargs)</code>","text":"<p>Get the list of holidays for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of holidays for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_hours","title":"<code>get_exchange_hours(exchange, **kwargs)</code>","text":"<p>Get the trading hours for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Trading hours for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_tz","title":"<code>get_exchange_tz(exchange, **kwargs)</code>","text":"<p>Get the timezone for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Timezone of the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_supported_exchanges","title":"<code>get_supported_exchanges(**kwargs)</code>","text":"<p>Get the list of supported exchanges.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of supported exchanges.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_dividends","title":"<code>get_ticker_dividends(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve dividend data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing dividend data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_earnings_history","title":"<code>get_ticker_earnings_history(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve earnings history data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing earnings history data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_earnings_trend","title":"<code>get_ticker_earnings_trend(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve earnings trend data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing earnings trend data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_financials","title":"<code>get_ticker_financials(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve financial statements data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing financial statements data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, exchange='US', **kwargs)</code>","text":"<p>Get fundamental data for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Fundamental data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_historical_mcap","title":"<code>get_ticker_historical_mcap(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve historical market capitalization data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing historical market capitalization data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_insider_txn","title":"<code>get_ticker_insider_txn(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve insider transaction data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing insider transaction data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve metadata for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata information for the ticker.</p> Notes <p>If the exchange is \"CC\", the metadata will be retrieved using the 'get_ticker_fundamentals' function.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_shares_stats","title":"<code>get_ticker_shares_stats(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve shares statistics for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing shares statistics for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_splits","title":"<code>get_ticker_splits(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve split data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing split data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_stat_snapshot","title":"<code>get_ticker_stat_snapshot(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve a snapshot of various statistics for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Snapshot of various statistics for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(exchange, **kwargs)</code>","text":"<p>Get the list of tickers for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of tickers for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, exchange='US', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_trade_ticks","title":"<code>get_trade_ticks(ticker, start, end, exchange='US', **kwargs)</code>","text":"<p>Retrieve ticker ticks data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the ticker ticks data.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>endpoint</code> <p>Endpoint for streaming. Valid values are: <code>[\"us\", \"us-quote\", \"forex\", \"crypto\"]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>endpoint</code> <p>Endpoint for streaming. Valid values are: <code>[\"us\", \"us-quote\", \"forex\", \"crypto\"]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.query_engine","title":"<code>query_engine(query, **kwargs)</code>","text":"<p>Perform a query using the Eodhd search engine.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the results of the query.</p>"},{"location":"wrappers/hyperliquid/","title":"quantpylib.wrappers.hyperliquid","text":"<p><code>quantpylib.simulator.hyperliquid</code> module is our official Hyperliquid wrapper SDK implementing the endpoints for perpetuals and spot trading. The library supports a fully asynchronous endpoint for efficiency and lightweight  concurrency. The websocket manager handles reconnections and resubsriptions under network errors and upgrades.</p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions.</p>"},{"location":"wrappers/hyperliquid/#examples","title":"Examples","text":"<p>We would demonstrate some endpoints. Refer to full documentation for details. For demonstrations, let us first make some imports we would like to use <pre><code>import os \nimport time\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.standards import Period\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def print_handler(msg): print(msg)\n\nasync def main():\n    hyp = Hyperliquid(\n        key=os.getenv(\"HYP_DEMO\"), #should be your vault address, if trading for a vault\n        secret=os.getenv(\"HYP_KEY\"), #secret key\n    )\n    await hyp.init_client()\n    #...examples go here\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#navigating-assets","title":"Navigating Assets","text":"<p>Note that perpeutals and their asset identifiers are the same. That is, <code>SOL</code> has the identifier <code>SOL</code> - this is not true of spot pairs. In most of the endpoints, the canonical name is not recognised, and their recognised identifier  shall be given the moniker <code>accredited_name</code>. We may convert between the two: <pre><code>hyp.get_accredited_name(\"JEFF/USDC\")\nhyp.get_canonical_name(\"@3\")\n</code></pre></p> <p>Most of our endpoints that may benefit from this  conversion automatically allows this with the flag <code>is_canonical</code> and <code>as_canonical</code> to interact and parse hpl server requests and responses respectively. </p>"},{"location":"wrappers/hyperliquid/#account","title":"Account","text":"<p>We may get account balances, subscribe to fill events, get rate limits easily <pre><code>bal = await hyp.account_balance()\nawait hyp.account_fill_subscribe(handler=print_handler)\nlimits = await hyp.account_rate_limits()\n</code></pre> We can get perpeutals contract specs: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=True)\n</code></pre> or spot contract specs: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=False)\n</code></pre> which gives: <pre><code>{'@1': {'price_precision': 6, 'quote_precision': 8, 'quantity_precision': 2, 'min_notional': 10.0}, '@2': {'price_precision': 8, 'quote_precision': 8, 'quantity_precision': 0, 'min_notional': 10.0}, ... }\n</code></pre> The spot endpoints by default assume <code>accredited_name</code> as identifiers, but we can request: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=False,as_canonical=True)\n</code></pre> and get instead: <pre><code>{'HFUN/USDC': {'price_precision': 6, 'quote_precision': 8, 'quantity_precision': 2, 'min_notional': 10.0}, 'LICK/USDC': {'price_precision': 8, 'quote_precision': 8, 'quantity_precision': 0, 'min_notional': 10.0}, ... }\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#positions","title":"Positions","text":"<p>We can get account perp-positions or spot-positions/balances: <pre><code>pos = await hyp.positions_get()\npos = await hyp.positions_get(is_perpetuals=False)\nprint(pos)\n</code></pre> which gives something like: <pre><code>{'USDC': {'ticker': 'USDC', 'amount': Decimal('12412.04185909'), 'entry': 1, 'value': Decimal('12412.04185909'), 'unrealized_pnl': 0}, 'PURR': {'ticker': 'PURR', 'amount': Decimal('12345.24577'), 'entry': Decimal('0.123456'), 'value': Decimal('7890.1234'), 'unrealized_pnl': Decimal('347.25542313685')}, ... }\n</code></pre> or force it to look like usdc-positions: <pre><code>pos = await hyp.positions_get(is_perpetuals=False,as_usdc_pair=True)\n</code></pre> <pre><code>{'PURR/USDC': {'ticker': 'PURR/USDC', 'amount': Decimal('dadas.gsdg'), 'entry': Decimal('0.dasdas'), 'value': Decimal('gdfsf.das'), 'unrealized_pnl': Decimal('sa.242113')}, 'HFUN/USDC': {'ticker': 'HFUN/USDC', 'amount': Decimal('3.1415926535'), 'entry': Decimal('dasd.dfasdf'), 'value': Decimal('DAD.ASF'), 'unrealized_pnl': Decimal('245.32242')}, ...}\n</code></pre> This gives us a snapshot of our positions from a HTTP-request, but we can also keep a local copy of the position state using: <pre><code>await hyp.positions_mirror()\nawait hyp.positions_mirror(on_update=print_handler)\n</code></pre> the <code>on_update</code> is optional, and the alive, local copy of positions can be retrieved here: <pre><code>pos = hyp.positions_peek()\n</code></pre> This is handled internally by the websocket subscriptions made available. All <code>get-mirror-peek</code> trio's work similarly. <code>get</code> is the HTTP request-response, <code>mirror</code> is the mirror-copy maintained using socket subscriptions and <code>peek</code> requires a <code>mirror</code> request and just echoes the internal copy.</p>"},{"location":"wrappers/hyperliquid/#orders","title":"Orders","text":"<p>Of course you can make orders: <pre><code>ord = await hyp.limit_order(ticker=\"SOL\",amount=-1,price=1000)\nord = await hyp.limit_order(ticker=\"@1\",amount=10,price=5)\nord = await hyp.limit_order(ticker=\"HFUN/USDC\",is_canonical=True,amount=10,price=5)\n</code></pre> We also give options to submit parent-child orders involving tp-sl triggers, as in their web-interface: <pre><code>ord = await hyp.limit_order(ticker=\"SOL\",amount=-1,price=1000,tp=400,sl=1200)\n</code></pre> And the market-order: <pre><code>ord = await hyp.market_order(ticker=\"SOL\",amount=-1)\n</code></pre></p> <p>Order states can be <code>get-mirror-peek</code>-ed: <pre><code>print(await hyp.orders_get(as_canonical=False))\nawait hyp.orders_mirror(as_canonical=False, on_update=print_handler)\nawait asyncio.sleep(10)\nhyp.orders_peek()\n</code></pre></p> <p>or simply subscribed to for custom handling: <pre><code>await hyp.order_updates_subscribe(handler=print_handler)\n</code></pre></p> <p>Of course you can cancel the orders (by ticker and id, all for some ticker, or all tickers): <pre><code>await hyp.cancel_open_orders(ticker=\"SOL\",is_canonical=False)\nawait hyp.cancel_order(\"JEFF/USDC\", oid=1234, is_canonical=True)\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#data","title":"Data","text":"<p>You can of course retrieve data. You can get all mids as snapshot or as subscription: <pre><code>mids = await hyp.all_mids()\nawait hyp.all_mids_subscribe(handler=print_handler)\n</code></pre> The subscriptions give response like this: <pre><code>{'@1': '22.253', '@10': '0.00043966', '@11': '0.00054', '@12': '0.00060734', '@13': '0.012098', '@14': '0.00057891', '@15': '0. ...\n'ARK': '0.361', 'ATOM': '5.7538', 'AVAX': '25.343', 'BADGER': '3.1786', 'BANANA': '48.7905', 'BCH': '419.195', 'BIGTIME': '0.094512', 'BLAST': '0.013506', 'BLUR': '0.17726', 'BLZ': '0.164115', 'BNB': '569.025', ... }\n</code></pre> but again you can ask for canonical schema: <pre><code>await hyp.all_mids_subscribe(handler=print_handler,as_canonical=True)\n</code></pre> <pre><code>{'HFUN/USDC': '22.236', 'GMEOW/USDC': '0.00043966', 'PEPE/USDC': '0.00054', 'XULIAN/USDC': '0.00060734', ... }\n</code></pre></p> <p>You can unsubscribe (you can do this for all websocket subscriptions): <pre><code>await hyp.all_mids_unsubscribe()\n</code></pre></p> <p>The l2-book also has a <code>get-mirror-peek</code> functionality, as well as the <code>subscribe</code> functionality. You probably get the hang of it: <pre><code>await hyp.l2_book_get(ticker=\"BTC\")\nawait hyp.l2_book_mirror(ticker=\"BTC\",on_update=print_handler)\nhyp.l2_book_peek()\nawait hyp.l2_book_subscribe(\"SOL\",handler=print_handler)\n</code></pre> In hpl cases, the subscription actually returns a book snapshot rather than incremental updates, so the mirror states and subscription  updates are similar. However, the <code>l2_book_mirror</code> has powerful add-ons: <pre><code>ob = await hyp.l2_book_mirror(\"SOL\",depth=20,buffer_size=1000,as_dict=False)\nawait asyncio.sleep(15)\nprint(ob.buffer_len()) #26\n</code></pre> By specifying <code>as_dict=False</code>, we get a instance of the <code>quantpylib.hft.lob.LOB</code> object. This object is 'live', in that  it is collecting a buffer of orderbook states in the background. There are utility functions we can call on <code>LOB</code> object instances, such as  <code>get_spread</code>, <code>get_vol</code>, <code>get_vamp</code> that are useful for market modelling.</p> <p>We have other endpoints, of course: <pre><code>candles = await hyp.candle_historical( #candles for `BTC` on `15m` intervals for the past hour\n    \"BTC\",\n    interval=\"15m\",\n    start=int(time.time()) * 1000 - 60 * 60 * 1000,\n    end=int(time.time()) * 1000\n)\ndf = await hyp.get_trade_bars( #OHLCV DF\n    ticker=\"BTC\",\n    start=datetime(2022,12,14),\n    end=datetime.now(),\n    granularity=Period.DAILY,\n    granularity_multiplier=1\n)\nprint(df)\n\nawait hyp.get_perps_data()\n</code></pre> A host of other endpoints such as user-funding,transactions, funding rates, transfers, account leverage updates and so on are supported...refer to docs.</p>"},{"location":"wrappers/hyperliquid/#documentation","title":"Documentation","text":""},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Channel","title":"<code>Channel</code>","text":"<p>Represents various socket subscription channels.</p> <p>Attributes:</p> Name Type Description <code>ALL_MIDS</code> <code>str</code> <p>The \"allMids\" channel.</p> <code>NOTIFICATION</code> <code>str</code> <p>The \"notification\" channel.</p> <code>WEBDATA</code> <code>str</code> <p>The \"webData2\" channel.</p> <code>CANDLE</code> <code>str</code> <p>The \"candle\" channel.</p> <code>L2BOOK</code> <code>str</code> <p>The \"l2Book\" channel.</p> <code>TRADES</code> <code>str</code> <p>The \"trades\" channel.</p> <code>ORDER_UPDATES</code> <code>str</code> <p>The \"orderUpdates\" channel.</p> <code>USER_EVENTS</code> <code>str</code> <p>The \"user\" channel for user events.</p> <code>USER_FILLS</code> <code>str</code> <p>The \"userFills\" channel.</p> <code>USER_FUNDINGS</code> <code>str</code> <p>The \"userFundings\" channel.</p> <code>USER_LEDGER_UPDATES</code> <code>str</code> <p>The \"userNonFundingLedgerUpdates\" channel.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid","title":"<code>Hyperliquid</code>","text":""},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.__init__","title":"<code>__init__(key='', secret='', **kwargs)</code>","text":"<p>Initializes the Hyperliquid instance.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The public or vault address.</p> <code>''</code> <code>secret</code> <code>str</code> <p>The secret key.</p> <code>''</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order fill events.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_rate_limits","title":"<code>account_rate_limits()</code>  <code>async</code>","text":"<p>Get the rate limits for the user's account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the current rate limits and usage statistics for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids","title":"<code>all_mids()</code>  <code>async</code>","text":"<p>Retrieve the mid-prices of all assets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the mid-prices of all assets available on the exchange.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, standardize_schema=True, as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to standard schema.</p> <code>True</code> <code>as_canonical</code> <code>(bool, False)</code> <p>If True, the mid prices are returned with canonical names.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid prices.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. If <code>is_canonical</code> is True, this should be the canonical name. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for further customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.candle_historical","title":"<code>candle_historical(ticker, interval, start, end)</code>  <code>async</code>","text":"<p>Retrieve historical candlestick data for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>interval</code> <code>str</code> <p>The time interval for each candlestick (e.g., '1m', '1h').</p> required <code>start</code> <code>int</code> <p>The start time for the data range in UNIX ms timestamp format.</p> required <code>end</code> <code>int</code> <p>The end time for the data range in UNIX ms timestamp format.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the historical candlestick data for the specified ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up open sessions with HPL server</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.contract_specifications","title":"<code>contract_specifications(is_perpetuals=True, as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>Specifies whether to fetch perpetual contracts. Defaults to True.</p> <code>True</code> <code>as_canonical</code> <code>bool</code> <p>If True, returns the contract specifications using canonical names. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_accredited_name","title":"<code>get_accredited_name(canonical)</code>","text":"<p>Retrieves the accredited name for a given canonical name. For perpetuals, this is an identity mapping. For spot, (for instance) JEFF/USDC maps to @4.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The accredited name associated with the canonical name.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_all_mids","title":"<code>get_all_mids(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_canonical_name","title":"<code>get_canonical_name(name, return_unmapped=False)</code>","text":"<p>Retrieves the canonical name for a given ticker. For perpetuals, this is an identity mapping. For spot, (for instance) @4 maps to JEFF/USDC.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ticker name.</p> required <code>return_unmapped</code> <code>bool</code> <p>If True, returns the name back to the caller if no mapping is found.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The canonical name associated with the ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_funding_rates","title":"<code>get_funding_rates(ticker, start, end, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve funding rates data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the funding rates data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_lot_precision","title":"<code>get_lot_precision(ticker, is_canonical=False)</code>","text":"<p>Get the lot precision for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places used for the asset's lot size precision.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_nonce","title":"<code>get_nonce()</code>","text":"<p>Get a unique nonce value using a nonce buffer to ensure no overlaps  between exchange requests.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A unique nonce value.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_perps_data","title":"<code>get_perps_data(in_decimal=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve perpetuals data.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing symbol to perp data with the following perp data structure:</p> <ul> <li>\"baseAsset\" <code>str</code> :             The base asset symbol.</li> <li>\"fr\" <code>float</code> :                  Funding rate.</li> <li>\"frint\" <code>int</code>,                  Funding rate interval.</li> <li>\"marginAsset\" <code>str</code>,            The margin asset symbol.</li> <li>\"markPrice\" <code>float</code>,            The mark price.</li> <li>\"minQty\" <code>Decimal</code>,             The minimum quantity.</li> <li>\"min_notional\" <code>float</code>,         The minimum notional value.</li> <li>\"next_funding\" <code>int</code>,           Unix timestamp of the next funding, milliseconds.</li> <li>\"pricePrecision\" <code>Decimal</code>,     The price precision.</li> <li>\"quantityPrecision\" <code>Decimal</code>,  The quantity precision.</li> <li>\"quoteAsset\" <code>str</code>,             The quote asset symbol.</li> <li>\"stepSize\" <code>Decimal</code>,           The step size.</li> <li>\"symbol\" <code>str</code>,                 The symbol.</li> <li>\"timestamp\" <code>int</code>,              Unix timestamp of the data retrieval, milliseconds.</li> <li>\"exchange\" <code>str</code>                The exchange code , \"hyperliquid\"</li> </ul>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_price_precision","title":"<code>get_price_precision(ticker, is_canonical=False)</code>","text":"<p>Get the price precision for a specified asset. Note that prices quoted  are less of price precision and 5 significant figures.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places used for the asset's price precision.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, kline_close=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>kline_close</code> <code>bool</code> <p>Timestamp candle by the candles' start or end timestamp. Defaults to <code>False</code>, which uses start time.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the exchange client with important metadata for mapping tickers to asset ids,  contract precision and mapping. Should be called upon object initialization.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_get","title":"<code>l2_book_get(ticker, nsigfig=None, depth=None, depth_cum=True)</code>  <code>async</code>","text":"<p>Retrieve L2 snapshot for a given coin.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>nsigfig</code> <code>int</code> <p>Number of significant figures requested. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code>.</p> <code>None</code> <code>depth_cum</code> <code>bool</code> <p>Flag indicating whether to return cumulative depth or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the L2 snapshot information.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=1000, buffer_size=100, as_dict=True, on_update=None, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code></p> <code>1000</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code></p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>is_canonical</code> <code>(bool, False)</code> <p>If the ticker passed in is a canonical name for the spot pairs.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, is_canonical=False, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>is_canonical</code> <code>(bool, False)</code> <p>If the ticker passed in is a canonical name for the spot pairs.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_snapshot","title":"<code>l2_snapshot(ticker, nsigfig=None)</code>  <code>async</code>","text":"<p>Get a Level 2 snapshot for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>nsigfig</code> <code>int</code> <p>Number of significant figures for the data. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the L2 order book snapshot for the specified ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.limit_order","title":"<code>limit_order(ticker, amount, price, tif='Gtc', reduce_only=False, cloid=None, tp=None, sl=None, trigger_market=True, round_price=False, round_size=False, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.market_order","title":"<code>market_order(ticker, amount, reduce_only=False, cloid=None, is_canonical=False, slippage_tolerance=0.05, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>slippage_tolerance</code> <code>float</code> <p>The maximum acceptable slippage, expressed as a percentage. Defaults to 0.05 (5%).</p> <code>0.05</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_cancel","title":"<code>order_cancel(ticker, oid, submit=True)</code>  <code>async</code>","text":"<p>Cancel a specific order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>oid</code> <code>int</code> <p>The order ID of the order to be canceled.</p> required <code>submit</code> <code>bool</code> <p>If True, the cancel action is submitted. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order cancellation request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_cancel_cloid","title":"<code>order_cancel_cloid(ticker, cloid, submit=True)</code>  <code>async</code>","text":"<p>Cancel an order using client order ID (Cloid).</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>cloid</code> <code>str</code> <p>The client order ID of the order to be canceled.</p> required <code>submit</code> <code>bool</code> <p>If True, the cancel action is submitted. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order cancellation request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_create","title":"<code>order_create(ticker, amount, price, tif='Gtc', reduce_only=False, cloid=None, tp=None, sl=None, trigger_market=True, grouping='na', round_price=False, round_size=False, submit=True, is_canonical=False)</code>  <code>async</code>","text":"<p>Create a new order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade. Positive for buy (long), negative for sell (short).</p> required <code>price</code> <code>float or Decimal</code> <p>The limit price for the order.</p> required <code>tif</code> <code>str</code> <p>Time in force for the order. Defaults to \"Gtc\" (Good 'til canceled).</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>If True, the order can only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for tracking. Defaults to None.</p> <code>None</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>grouping</code> <code>str</code> <p>Order grouping type. Defaults to \"na\".</p> <code>'na'</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>submit</code> <code>bool</code> <p>If True, the order is submitted immediately, otherwise the order schema is returned. Defaults to True.</p> <code>True</code> <code>is_canonical</code> <code>bool</code> <p>If True, the ticker is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order creation or the action object if <code>submit</code> is False.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_fills","title":"<code>order_fills()</code>  <code>async</code>","text":"<p>Get all filled orders.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all filled orders for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_fills_by_time","title":"<code>order_fills_by_time(start, end)</code>  <code>async</code>","text":"<p>Get filled orders within a specific time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The start time for the data range in UNIX timestamp format.</p> required <code>end</code> <code>int</code> <p>The end time for the data range in UNIX timestamp format.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all filled orders within the specified time range.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_market","title":"<code>order_market(ticker, amount, reduce_only=False, slippage_tolerance=0.05, cloid=None, is_canonical=False, round_size=False)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade. Positive for buy (long), negative for sell (short).</p> required <code>reduce_only</code> <code>bool</code> <p>If True, the order can only reduce an existing position. Defaults to False.</p> <code>False</code> <code>slippage_tolerance</code> <code>float</code> <p>The acceptable slippage percentage. Defaults to 0.05.</p> <code>0.05</code> <code>cloid</code> <code>str</code> <p>Client order ID for tracking. Defaults to None.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the ticker is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the market order submission.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_modify","title":"<code>order_modify(ticker, amount, price, oid=None, cloid=None, tif='Gtc', reduce_only=False, tp=None, sl=None, trigger_market=True, round_price=False, round_size=False, submit=True)</code>  <code>async</code>","text":"<p>Modify an existing order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive or negative quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The new price for the order.</p> required <code>oid</code> <code>int</code> <p>The order ID of the order to modify. Defaults to None.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>The client order ID of the order to modify. Defaults to None.</p> <code>None</code> <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>submit</code> <code>bool</code> <p>If True, the modification is submitted immediately, otherwise the order schema is returned. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order modification request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_query","title":"<code>order_query(oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(str, int)</code> <p>Order ID in exchange</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_status","title":"<code>order_status(id)</code>  <code>async</code>","text":"<p>Get the status of a specific order.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or str</code> <p>Unique identifier as order ID or client order ID.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the status and details of the specified order.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_cancel","title":"<code>orders_cancel(order_actions)</code>  <code>async</code>","text":"<p>Cancel multiple orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be canceled.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders cancellation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_cancel_cloid","title":"<code>orders_cancel_cloid(order_actions)</code>  <code>async</code>","text":"<p>Cancel multiple orders using client order IDs (Cloids).</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be canceled using Cloids.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders cancellation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_create","title":"<code>orders_create(order_actions, grouping='na')</code>  <code>async</code>","text":"<p>Create new orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the actions for creating orders.</p> required <code>grouping</code> <code>str</code> <p>The grouping type for the orders. Defaults to \"na\".</p> <code>'na'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders creation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_get","title":"<code>orders_get(as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>as_canonical</code> <code>bool</code> <p>If True, the method returns tickers in their canonical form. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of all open orders. Each key is the order ID (<code>oid</code>), with value dict: - markets.TICKER: The asset's ticker symbol, either in standard or canonical form. - markets.ORDER_ID: The unique identifier of the order. - markets.ORDER_CLOID: The client order ID. - markets.LIMIT_PRICE: The limit price of the order. - markets.ORDER_AMOUNT: The original size of the order. - markets.ORDER_FILLED_SIZE: The remaining size of the order yet to be filled. - markets.ORDER_STATUS: The status of the order. - markets.TIMESTAMP: The timestamp when the order was created.</p> Notes <p>See the Hyperliquid documentation for more details: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_mirror","title":"<code>orders_mirror(as_canonical=False, on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_canonical</code> <code>bool</code> <p>If True, the method returns tickers in their canonical form. Defaults to False.</p> <code>False</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_modify","title":"<code>orders_modify(order_actions)</code>  <code>async</code>","text":"<p>Modify multiple existing orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be modified.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders modification request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_open","title":"<code>orders_open()</code>  <code>async</code>","text":"<p>Get all open orders.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all open orders for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_open_frontend","title":"<code>orders_open_frontend()</code>  <code>async</code>","text":"<p>Get all open orders with additional frontend-specific information.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all open orders for the user's account, with extra information for frontend use.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_account","title":"<code>perpetuals_account()</code>  <code>async</code>","text":"<p>Retrieve account information related to perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing information about the user's account in relation to perpetual contracts, including positions, balances, and other relevant data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_contexts","title":"<code>perpetuals_contexts()</code>  <code>async</code>","text":"<p>Retrieve context information for perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing context information for perpetual contracts, which may include details about market conditions and other relevant data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_funding_historical","title":"<code>perpetuals_funding_historical(ticker, start=int(datetime.now(pytz.utc) - timedelta(days=14).timestamp() * 1000), end=None)</code>  <code>async</code>","text":"<p>Retrieve funding history for a given coin.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the coin.</p> required <code>start</code> <code>int</code> <p>The start time for the data range in milliseconds. Defaults to 14 days ago from the current time.</p> <code>int(timestamp() * 1000)</code> <code>end</code> <code>int</code> <p>The end time for the data range in milliseconds. Defaults to None.</p> <code>None</code> Notes <p>For more details, refer to the Hyperliquid API documentation: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-historical-funding-rates</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_metadata","title":"<code>perpetuals_metadata()</code>  <code>async</code>","text":"<p>Retrieve metadata for all perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing metadata for all perpetual contracts, including information about contract specifications and trading rules.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_user_funding","title":"<code>perpetuals_user_funding()</code>  <code>async</code>","text":"<p>Retrieve the user's funding payment history for perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the user's funding payment history, detailing the amounts paid or received as funding fees over time.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_get","title":"<code>positions_get(is_perpetuals=True, as_usdc_pair=False, **kwargs)</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>If True, retrieves positions for perpetual contracts. If False, retrieves spot balances. Defaults to True.</p> <code>True</code> <code>as_usdc_pair</code> <code>bool</code> <p>If True, returns spot balances as USDC pairs, otherwise as token balances. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open positions.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_mirror","title":"<code>positions_mirror(is_perpetuals=True, on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>If True, retrieves positions for perpetual contracts. If False, retrieves spot balances. Defaults to True.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.rand_cloid","title":"<code>rand_cloid(start='', end='', include_prefix=True, **kwargs)</code>","text":"<p>Generate a random string (cloid) consisting of hexadecimal characters, optionally with a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <code>include_prefix</code> <code>bool</code> <p>If True, includes the '0x' prefix at the beginning of the string. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for future extensibility.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A random hexadecimal string with a total length of 32 characters,  including the optional 'start' and 'end' strings, and an optional '0x' prefix.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.referral","title":"<code>referral()</code>  <code>async</code>","text":"<p>Retrieve referral information for the user's account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details related to the user's referral program, such as referral code, referral rewards, and the status of referred users.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.request_l1_action","title":"<code>request_l1_action(action, nonce, signature)</code>  <code>async</code>","text":"<p>Submit a Level 1 (L1) action to the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to be performed.</p> required <code>nonce</code> <code>int</code> <p>A unique nonce for the action to prevent replay attacks.</p> required <code>signature</code> <code>str</code> <p>The signature validating the action.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the action request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_balances","title":"<code>spot_balances()</code>  <code>async</code>","text":"<p>Retrieve the user's spot balances.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the user's spot balances for various assets, detailing the amount held and other relevant account information.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_contexts","title":"<code>spot_contexts()</code>  <code>async</code>","text":"<p>Retrieve context information for spot markets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing context information for spot markets.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_metadata","title":"<code>spot_metadata()</code>  <code>async</code>","text":"<p>Retrieve metadata for all spot markets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing metadata for all spot markets, including information such as trading pairs, asset details, and other relevant market specifications.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_perp_transfer","title":"<code>spot_perp_transfer(amount, spot_to_perp=True)</code>  <code>async</code>","text":"<p>Transfer funds between spot and perpetual accounts.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <code>spot_to_perp</code> <code>bool</code> <p>If True, transfer from spot to perpetual. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.subaccount_transfer","title":"<code>subaccount_transfer(subaccount, is_deposit, amount)</code>  <code>async</code>","text":"<p>Transfer funds to or from a subaccount.</p> <p>Parameters:</p> Name Type Description Default <code>subaccount</code> <code>str</code> <p>The identifier for the subaccount.</p> required <code>is_deposit</code> <code>bool</code> <p>If True, the transfer is a deposit. If False, it is a withdrawal.</p> required <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the subaccount transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset. If <code>is_canonical</code> is True, this should be the canonical name.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for processing the received trade messages.</p> required <code>standardize_schema</code> <code>bool</code> <p>If True, processes the incoming message to a standardized format. Defaults to True.</p> <code>True</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from trade data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset. If <code>is_canonical</code> is True, this should be the canonical name.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Coroutine</code> <p>A coroutine that can be awaited to complete the unsubscription process.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.transfer_l1","title":"<code>transfer_l1(amount, dest, asset='usdc')</code>  <code>async</code>","text":"<p>Transfer l1 funds.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <code>dest</code> <code>str</code> <p>The destination address.</p> required <code>asset</code> <code>str</code> <p>The asset to transfer (default is \"usdc\").</p> <code>'usdc'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.update_iso_margin","title":"<code>update_iso_margin(ticker, amount)</code>  <code>async</code>","text":"<p>Update the isolated margin for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The amount to adjust the isolated margin.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the isolated margin update request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.update_leverage","title":"<code>update_leverage(ticker, leverage, is_cross=True)</code>  <code>async</code>","text":"<p>Update the leverage for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>leverage</code> <code>float</code> <p>The leverage multiplier to set.</p> required <code>is_cross</code> <code>bool</code> <p>If True, sets cross-margin mode. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the leverage update request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.vault_transfer","title":"<code>vault_transfer(vault, is_deposit, amount)</code>  <code>async</code>","text":"<p>Transfer funds to or from a vault.</p> <p>Parameters:</p> Name Type Description Default <code>vault</code> <code>str</code> <p>The address of the vault.</p> required <code>is_deposit</code> <code>bool</code> <p>If True, the transfer is a deposit. If False, it is a withdrawal.</p> required <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the vault transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.withdrawal_request","title":"<code>withdrawal_request(amount, dest)</code>  <code>async</code>","text":"<p>Request a withdrawal from the bridge.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to withdraw.</p> required <code>dest</code> <code>str</code> <p>The destination address.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the withdrawal request.</p>"},{"location":"wrappers/oanda/","title":"quantpylib.wrappers.oanda","text":""},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda","title":"<code>Oanda</code>","text":"<p>A class for interacting with Oanda API for CFD data.    </p> Read <p>https://developer.oanda.com/rest-live-v20/introduction/</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.__init__","title":"<code>__init__(account_id, secret, env='practice', **kwargs)</code>","text":"<p>Initialize the Oanda instance with the account ID, API token secret, and environment.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>str</code> <p>Oanda account ID.</p> required <code>secret</code> <code>str</code> <p>Oanda API token secret.</p> required <code>env</code> <code>str</code> <p>Environment type, either \"practice\" or \"live\".</p> <code>'practice'</code>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata for the specified ticker.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the list of tickers available in the Oanda account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of tickers available in the Oanda account.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for the specified ticker and time range.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <code>start</code> <code>datetime</code> <p>The start date and time for data retrieval.</p> required <code>end</code> <code>datetime</code> <p>The end date and time for data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>The period type for the OHLCV bars.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The granularity multiplier.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: The OHLCV trade bar data for the specified ticker and time range.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Start streaming market data for the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Trading instrument ticker.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <p>Returns:     None</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Close the streaming for market data of the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"wrappers/wrappers/","title":"quantpylib.wrappers","text":"<p><code>quantpylib.wrappers</code> contain our SDKs for data vendors and exchange integrations. They may be used in silo, or as clients to <code>quantpylib.datapoller.master.Datapoller</code> and <code>quantpylib.gateway.master.Gateway</code> objects, which are further used in both OMS and data feeds used for live trading, backtesting and account management.</p>"},{"location":"wrappers/yfinance/","title":"quantpylib.wrappers.yfinance","text":""},{"location":"wrappers/yfinance/#quantpylib.wrappers.yfinance.YFinance","title":"<code>YFinance</code>","text":""},{"location":"wrappers/yfinance/#quantpylib.wrappers.yfinance.YFinance.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, **kwargs)</code>  <code>async</code>","text":"<p>Fetches trade bars data for the specified ticker and time period.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>start</code> <code>datetime</code> <p>The start date of the data to be fetched.</p> required <code>end</code> <code>datetime</code> <p>The end date of the data to be fetched.</p> required <code>granularity</code> <code>Period</code> <p>The granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The multiplier for the granularity.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The DataFrame containing the trade bars data.</p>"}]}