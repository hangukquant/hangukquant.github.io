{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"quantpylib","text":"DISCLAIMER  None of the information contained here or on hangukquant.substack.com or its affiliated platforms constitutes an offer (or solicitation of an offer) to buy or sell any currency, product or financial instrument, to make any investment, or to participate in any particular trading strategy, or a recommendation for any security or any third party. Trading involves real risks of loss and is solely your responsibility. Past performance is not indicative of future performance; material enclosed herein is for educational purposes only. There is absolutely no warranty or guarantee implied with this product. Use at your own risk. Trading is a risky operation.  COPYRIGHT  Sharing and distribution of any material taken herein is not allowed without express and written approval by HangukQuant, and is only intended for private usage. The code is meant for subscribers of hangukquant.substack.com and any member expressly allowed by HangukQuant.  <p>Welcome to the <code>quantpylib</code> repository! This repository is a Python package for quantitative trading and research, with in-house tools for powerful, fast, flexible and batteries-included quantitative backtesting, data retrieval and all things quant trading. The library is not specific to any strategy or trading instrument. Members are encouraged to participate in the contribution of the code.</p> <p>The code requires a 3.8+ version of Python to run.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Installation</li> <li>User Documentation and Examples,</li> <li>Running Tests</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>To install this library, users need to obtain access to the private Github repo by leaving your Github id on our post or directly requesting to be shortlisted (for unpaid readers) to HangukQuant by email (hangukquant@gmail.com).</p> <p>Alternatively, obtain an access pass.</p> <p>You can use <code>quantpylib</code> in your local Python environment after cloning our repository and running bash script: <pre><code>chmod +x install.sh\n./install.sh\n</code></pre> in the working directory with the <code>setup.py</code> Python script.</p>"},{"location":"#user-documentation-and-examples","title":"User Documentation and Examples","text":"<p>You can jump into our examples here, or go through official documentation hosted here.</p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>Our test suites can be run using the <code>pytest</code> framework. To run all tests, run  <pre><code>python3 -m pip install pytest\npython3 -m pytest quantpylib/tests \n</code></pre> For more verbose test information, run <pre><code>python3 -m pytest quantpylib/tests -vs \n</code></pre> You can choose specific modules or scripts to test by specifying the path to the test suite <pre><code>python3 -m pytest quantpylib/tests/simulator\npython3 -m pytest quantpylib/tests/simulator/test_operators.py\n</code></pre> Contributors who modify the codebase should run all tests and verify the tests pass before submitting a Pull Request.</p>"},{"location":"bounties/","title":"USDC Bounties","text":""},{"location":"bounties/#about","title":"About \ud83d\udcdd\ud83d\udcdd\ud83d\udcdd","text":"<p>It is time to recognise individuals who contribute to the success of <code>quantpylib</code> and make it a healthy, robust environment for learning and implementing quantitative trading. We will award users who add (high quality) value to the project (features, documentation, tests, optimizations, bug reports/fixes, tutorials, learning material and everything else) on quantitative trading. </p> <p>There is no set metric - decisions are completely centralised, biased and discretionarily determined by <code>HangukQuant</code>. The bounties are funded from <code>HangukQuant's Wallet</code>. Users can quality for repeated bounties contingent on contributions. User <code>hangukquant</code> is not eligible for bounty rewards, for he is too powerful. </p> <p>All bounties will be denominated in USDC or equivalent. Transaction fees are borne by receiver. Unclaimed bounties may be received by reaching out to <code>HangukQuant</code> from <code>01 Mar 2025</code> onwards.</p>"},{"location":"bounties/#bounty-pool","title":"Bounty Pool \ud83d\udcb0\ud83d\udcb0\ud83d\udcb0","text":"<p>450. Come get this \ud83c\udf5e.</p>"},{"location":"bounties/#unclaimed","title":"Unclaimed \ud83e\udd11\ud83e\udd11\ud83e\udd11","text":"User/On Amount #Remark ben9809/github 100 tester/. edot/discord 100 contributor/. vehctor/discord 100 contributor/hft mektigboy/github 100 contributor/woox"},{"location":"bounties/#total","title":"Total \ud83e\udde7\ud83e\udde7\ud83e\udde7","text":"<p>Pool : 450</p> <p>Unclaimed: 400</p> <p>Claimed: 0</p> <p>Total: 850</p>"},{"location":"bounties/#claims","title":"Claims:","text":""},{"location":"datapoller/base/","title":"quantpylib.datapoller.base","text":""},{"location":"datapoller/base/#quantpylib.datapoller.base.BasePoller","title":"<code>BasePoller</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A base class for creating pollers to interact with various data sources.</p> <p>Attributes:</p> Name Type Description <code>pollers</code> <code>dict</code> <p>A dictionary of pollers for different data sources.</p> <code>default_src</code> <code>str</code> <p>The default data source to be used.</p>"},{"location":"datapoller/base/#quantpylib.datapoller.base.BasePoller.__init__","title":"<code>__init__(pollers, default_src='')</code>","text":"<p>Initialize the BasePoller with pollers and default data source.</p> <p>Parameters:</p> Name Type Description Default <code>pollers</code> <code>dict</code> <p>A dictionary of pollers for different data sources.</p> required <code>default_src</code> <code>str</code> <p>The default data source to be used.</p> <code>''</code>"},{"location":"datapoller/crypto/","title":"quantpylib.datapoller.crypto","text":""},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto","title":"<code>Crypto</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_funding_rates","title":"<code>get_funding_rates(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve funding rate data for cryptocurrencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.crypto.get_funding_rates(ticker=\"ETH\",start=start,end=end,src=\"hyperliquid\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, **kwargs)</code>","text":"<p>Retrieve fundamentals data for a specific cryptocurrency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Fundamentals data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f=datapoller.crypto.get_ticker_fundamentals(ticker=\"ETH-USD\",src=\"eodhd\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for a specific cryptocurrency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Metadata for the specified cryptocurrency from the selected data source.</p>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for cryptocurrencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified cryptocurrency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.crypto.get_trade_bars(ticker=\"BTCUSDT\",start=start,end=end,granularity=\"d\",src=\"binance\")\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L1 OB data for a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.crypto.l1_book_subscribe(ticker=\"BTC-USD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 OB data for a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.crypto.l2_book_subscribe(ticker=\"BTC-USD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/crypto/#quantpylib.datapoller.crypto.Crypto.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific cryptocurrency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Cryptocurrency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/currencies/","title":"quantpylib.datapoller.currencies","text":""},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies","title":"<code>Currencies</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for a specific currency. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Metadata for the specified currency from the selected data source.</p>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for currencies. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Trade bar data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df=datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"d\",src=\"oanda\")\n&gt;&gt;&gt; df=datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",granularity=\"h\",granularity_multiplier=4,start=start,end=end,src=\"oanda\")\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Streaming market data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.currencies.l1_book_subscribe(ticker=\"EURUSD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Streaming market data for the specified currency from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def handler(msg): \n        print(msg)\n&gt;&gt;&gt; await datapoller.currencies.l2_book_subscribe(ticker=\"EURUSD\",src=\"eodhd\",handler=handler)\n</code></pre>"},{"location":"datapoller/currencies/#quantpylib.datapoller.currencies.Currencies.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate streaming for market data of a specific currency. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Currency ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/datapoller/","title":"quantpylib.datapoller","text":"<p><code>quantpylib.datapoller</code> is a quant module used for multi-asset, multi-source/vendor/exchange financial data retrieval. </p> <p>The datapollers are categorized into their data-classes, with current support for: </p> <pre><code>- crypto\n- currencies \n- equities\n- exchange\n- metadata\n</code></pre> <p>The datasources supported are:</p> <pre><code>- binance\n- eodhd\n- oanda\n- hyperliquid\n- yfinance\n</code></pre> <p>In general, a trader may have requirements for different asset-class/categories of financial data, subscriptions to  multiple data sources, with each data source supporting a subset of the asset-class universe. Each data source  has its own endpoints, parameters, rate-restrictions and authentication flow - the datapoller abstracts these concerns  to provide a seamless interface for data retrieval while attempting to maximize throughput. </p> <p>Each datapoller is derived from the base <code>quantpylib.datapoller.base.BasePoller</code> class and implements a set of methods, and routs the requests to the specified data source and endpoints. The supported data sources are written as wrappers  on the <code>quantpylib.wrappers</code> module, and their supported endpoints share the same function name as in the datapollers.  The different datapollers are accessible via the master data polling class, given in <code>quantpylib.datapoller.master.Datapoller</code> object instance. For instance, if we would like to get trade bars using the <code>quantpylib.datapoller.currencies.Currencies.get_trade_bars</code>, we can do so by creating a <code>obj = DataPoller(...)</code> instance, and calling <code>obj.currencies.get_trade_bars(...,src=\"oanda\")</code>. The function call is only valid if it is supported by both the datapoller and the datasource, which we can check by their matching  function signatures. In general each datasource has its own parameters to the vendor-specific endpoint, as well as different specifications (such as start time of OHLCV historical request in YYYY-MM-DD vs unix-timestamp), so the library provides a unified standard that convert between these specifications. In addition, the datapoller take in flexible arguments  to support the different configurations for each external API - it would be alot easier to understand through the given examples.</p> <p>Note that each of the datasource wrappers are also designed to be available for use as standalone Python-SDKs. Supported datapollers and datasources are added and updated frequently.</p> <p>To understand the valid function signatures of each datapoller, we need to understand the function\u2019s decorator-type,  which is indicated <code>@poller</code> or <code>@ts_poller</code> in the documentation, and is defined in <code>quantpylib.datapoller.utils</code> module for polling or time-series polling respectively.  The default arguments are supplied through these decorators, which also provide parameter-standardization and parameter-guessing  for vendor/source-unique specifications. Source-specific arguments are documented in its corresponding data-wrapper.</p> <p>We now walkthrough how to construct a valid datapolling request and construct valid parameters to our datapollers for the various datasources. Note that the various endpoints and their matching  function name-signatures can be easily looked up in the search-bar (top right): </p> <p>We need more data sources, more data pollers and more data endpoints to support. If there is a particular functionality  you would like documented or implemented, please feel free to reach out to me @ hangukquant@gmail.com or submit a Github issue. Cheers.</p>"},{"location":"datapoller/datapoller/#walkthrough","title":"Walkthrough","text":"<p>Supposed we are interested in getting some OHLC(V) data for equities. From our <code>quantpylib.wrappers</code> library, we see that the datasources supported with equities data is <code>eodhd</code> and <code>yfinance</code>. Suppose we have no API access to <code>eodhd</code>, so we will make a request through  the <code>yfinance</code> library. To see what endpoints are available  in the <code>equities</code> datapoller, we can just look at the documentation page - the sidebar has a summary, which we see has a <code>get_trade_bars</code> method. The arguments are not specified, but it is tagged <code>@ts_poller</code>, which means the arguments to supply are  given by decorators, documented here. The augmented arguments are <code>ticker</code>, <code>start</code>, <code>end</code>, <code>periods</code> <code>granularity</code>, <code>granularity_multiplier</code> and <code>src</code>. We shall provide <code>ticker</code>, <code>start</code>, <code>periods</code> and <code>src</code> to make our request, and let the rest settle to default arguments.</p> <p>A dictionary containing configuration keys for different data sources we  have access to is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code>, where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the <code>src</code> parameter in the datapoller methods.</p> <p>We already have the keys in our <code>.env</code> file in the current working directory, and we will make the following imports: <pre><code>import os\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\nfrom quantpylib.datapoller.master import DataPoller\n\nconfig_keys = {\n    \"yfinance\": {\"alias\":\"yfinance\"},\n    \"eodhd\": {\"eod_key\":os.getenv(\"EOD_KEY\")},\n    \"binance\": {},\n    \"oanda\": {\n        \"alias\":\"oanda\",\n        \"account_id\":os.getenv(\"OANDA_ACC\"),\n        \"secret\": os.getenv(\"OANDA_KEY\"),\n        \"env\":\"practice\",\n    },\n    \"hyperliquid\": {\"alias\":\"hyp\",\"key\":os.getenv(\"HYP_PUBLIC\"),\"secret\":os.getenv(\"HYP_KEY\")},\n}\n\n\nasync def main():\n    start,end=datetime(2023,9,30),datetime.now()\n    datapoller = DataPoller(config_keys=config_keys)\n    print(datapoller.src_pollers)\n\n    await datapoller.init_clients()\n\n    #...code goes between here...\n\n    await datapoller.cleanup_clients()\n    print(\"cleanup\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> We only need secret keys for private endpoints, and only <code>eodhd</code>, <code>oanda</code> keys are required for the demonstration here. The rest allow retrieval of data through their public endpoints. We can of course omit it all together, if we are not interested in having access to its data archives.  We just instantiated a master datapoller with our keys. We used the alias <code>hyp</code> for <code>hyperliquid</code> in our datapoller initiation. We may access the equities <code>get_trade_bars</code> method and specify <code>src=\"yfinance\"</code> alias, like this: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    periods=365,\n    src=\"yfinance\"\n)\nprint(df)\n</code></pre> This gives us a year-worth of data for the year 2000~2001: <pre><code>                               open      high       low     close     volume\ndatetime                                                                    \n2000-01-03 00:00:00-05:00  0.792742  0.850379  0.768648  0.846127  535796800\n2000-01-04 00:00:00-05:00  0.818254  0.836206  0.764869  0.774790  512377600\n2000-01-05 00:00:00-05:00  0.784238  0.835733  0.778569  0.786128  778321600\n2000-01-06 00:00:00-05:00  0.802191  0.808805  0.718098  0.718098  767972800\n2000-01-07 00:00:00-05:00  0.729436  0.763452  0.721878  0.752113  460734400\n...                             ...       ...       ...       ...        ...\n2000-12-22 00:00:00-05:00  0.213539  0.226768  0.213539  0.226768  318052000\n2000-12-26 00:00:00-05:00  0.224878  0.226768  0.215429  0.222044  216815200\n2000-12-27 00:00:00-05:00  0.216846  0.223933  0.214484  0.223933  325466400\n2000-12-28 00:00:00-05:00  0.217319  0.225823  0.216374  0.223933  305177600\n2000-12-29 00:00:00-05:00  0.222044  0.226768  0.219209  0.224878  630336000\n</code></pre> Now if we were to specify <code>end=datetime(2000,1,1)</code> instead of <code>start=datetime(2000,1,1)</code>, then  we will have data from 1999~2000. Or we can just specify  the <code>start</code>,<code>end</code> directly, which means we can exclude the  <code>periods</code> parameter, like this: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"yfinance\"\n)\nprint(df)\n</code></pre> to get  <pre><code>                                open       high        low      close     volume\ndatetime                                                                        \n2000-01-03 00:00:00-05:00   0.792742   0.850379   0.768648   0.846127  535796800\n2000-01-04 00:00:00-05:00   0.818254   0.836206   0.764869   0.774790  512377600\n2000-01-05 00:00:00-05:00   0.784238   0.835734   0.778569   0.786128  778321600\n2000-01-06 00:00:00-05:00   0.802191   0.808805   0.718097   0.718097  767972800\n2000-01-07 00:00:00-05:00   0.729436   0.763452   0.721878   0.752113  460734400\n...                              ...        ...        ...        ...        ...\n2019-12-24 00:00:00-05:00  69.250147  69.298799  68.819601  69.147980   48478800\n2019-12-26 00:00:00-05:00  69.281768  70.536927  69.252580  70.519897   93121200\n2019-12-27 00:00:00-05:00  70.814237  71.507495  70.084495  70.493149  146266000\n2019-12-30 00:00:00-05:00  70.410455  71.196148  69.379088  70.911545  144114400\n2019-12-31 00:00:00-05:00  70.524783  71.436962  70.425051  71.429665  100805600\n</code></pre> Under the hood, we are mapping the parameters to  the <code>quantpylib.wrappers.yfinance.YFinance.get_trade_bars</code> method. You may use this as a standalone SDK, but the parameters are alot more rigid. With the master datapoller, we can provide any 2 of the 3 of <code>start</code>, <code>end</code>, and <code>periods</code>. But <code>yfinance</code> does not support too many endpoints, and is also  not stable, albeit free. Suppose we have an API key for  <code>eodhd</code>, we don't need to change much code: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\nprint(df)\n</code></pre> <pre><code>                open      high       low     close  adjusted_close     volume\ndatetime                                                                     \n2000-01-03  104.8768  112.5040  101.6848  111.9328          0.8461  535796800\n2000-01-04  108.2480  110.6224  101.1920  102.5024          0.7748  512377600\n2000-01-05  103.7456  110.5664  102.9952  104.0032          0.7862  778321600\n2000-01-06  106.1200  107.0048   94.9984   94.9984          0.7181  767972800\n2000-01-07   96.4992  101.0016   95.5024   99.5008          0.7521  460734400\n...              ...       ...       ...       ...             ...        ...\n2024-03-28  171.7500  172.2300  170.5100  171.4800        171.4800   65672700\n2024-04-01  171.1900  171.2500  169.4800  170.0300        170.0300   46240500\n2024-04-02  169.0800  169.3400  168.2300  168.8400        168.8400   49329500\n2024-04-03  168.7900  170.6800  168.5800  169.6500        169.6500   47602100\n2024-04-04  170.2900  171.9200  168.8200  168.8200        168.8200   53289969\n</code></pre> Actually we don't even need <code>src=\"eodhd\"</code>, the equities datapoller has that as its default, and the <code>@ts_poller</code> decorator is capable of guessing some parameters. This of course routs the request to <code>quantpylib.wrappers.eodhd.Eodhd.get_trade_bars</code>. Different from the <code>yfinance</code> wrapper's <code>get_trade_bars</code> endpoint, there is an additional parameter <code>exchange=\"US\"</code>, that is specific to the <code>eodhd</code> REST API. They have parameters to identify which asset with the same  ticker the client is referring to, but this nomenclature is unique to this particular vendor. This parameter is actually also  guessed by the <code>@ts_poller</code> decorator, but if we know precisely what we want, we should pass it in as arguments, as we may guess wrongly - here is an example of <code>AAPL</code> on the US and Mexican exchanges: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"US\"\n)\nprint(df)\ndf = await datapoller.equities.get_trade_bars(\n    ticker=\"AAPL\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"MX\"\n)\nprint(df)\n</code></pre> giving <pre><code>                open      high       low     close  adjusted_close     volume\ndatetime                                                                     \n2000-01-03  104.8768  112.5040  101.6848  111.9328          0.8461  535796800\n2000-01-04  108.2480  110.6224  101.1920  102.5024          0.7748  512377600\n2000-01-05  103.7456  110.5664  102.9952  104.0032          0.7862  778321600\n2000-01-06  106.1200  107.0048   94.9984   94.9984          0.7181  767972800\n2000-01-07   96.4992  101.0016   95.5024   99.5008          0.7521  460734400\n...              ...       ...       ...       ...             ...        ...\n2024-03-28  171.7500  172.2300  170.5100  171.4800        171.4800   65672700\n2024-04-01  171.1900  171.2500  169.4800  170.0300        170.0300   46240500\n2024-04-02  169.0800  169.3400  168.2300  168.8400        168.8400   49329500\n2024-04-03  168.7900  170.6800  168.5800  169.6500        169.6500   47602100\n2024-04-04  170.2900  171.9200  168.8200  168.8200        168.8200   53289969\n\n[6102 rows x 6 columns]\n                 open       high        low      close  adjusted_close   volume\ndatetime                                                                       \n2004-12-20   704.4184   704.4184   694.5484   697.9980         11.0377   722401\n2004-12-21   702.4780   704.4996   702.4780   703.8080         11.1296  1804322\n2004-12-27   705.1688   705.1688   705.1688   705.1688         11.1511   140000\n2005-01-05   738.7380   738.7380   738.7380   738.7380         11.6819    14560\n2005-03-07   471.2496   471.2496   471.2496   471.2496         14.9041   266000\n...               ...        ...        ...        ...             ...      ...\n2024-03-27  2846.0000  2874.9900  2842.0000  2874.4299       2874.4299     1941\n2024-04-01  2873.0000  2873.0000  2819.3500  2827.2100       2827.2100    16860\n2024-04-02  2808.0000  2813.6900  2792.5000  2799.7800       2799.7800    23005\n2024-04-03  2798.0000  2829.9900  2798.0000  2810.0000       2810.0000     7258\n2024-04-04  2810.0000  2839.9900  2800.0000  2807.0300       2807.0300     3685\n</code></pre> The best is no-guessing, where you specify the source-specific parameters explicitly. For example, this would raise Exception: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\n</code></pre> but if you change the request using <code>crypto</code> poller <pre><code>df = await datapoller.crypto.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\"\n)\nprint(df)\n</code></pre> we get <pre><code>                    open          high           low         close  adjusted_close       volume\ndatetime                                                                                       \n2010-07-17      0.049510      0.049510      0.049510      0.049510        0.049510            0\n2010-07-18      0.049510      0.049510      0.049510      0.049510        0.049510            0\n2010-07-19      0.085840      0.085840      0.085840      0.085840        0.085840            0\n2010-07-20      0.080800      0.080800      0.080800      0.080800        0.080800            0\n2010-07-21      0.074740      0.074740      0.074740      0.074740        0.074740            0\n...                  ...           ...           ...           ...             ...          ...\n2024-03-31  69647.779030  71377.779498  69624.868677  71333.647926    71333.647926  20050941373\n2024-04-01  71333.484717  71342.091454  68110.696020  69702.146113    69702.146113  34873527352\n2024-04-02  69705.024322  69708.381258  64586.594304  65446.974233    65446.974233  50705240709\n2024-04-03  65446.671764  66914.322564  64559.899948  65980.808650    65980.808650  34488018367\n2024-04-04  65975.696667  69291.254806  65113.796534  68508.841844    68508.841844  34439527442\n</code></pre> Although the <code>@ts_poller</code> adds a layer of complexity, it's purpose is to both be extremely flexible in the arguments the methods takes in, to generalize to arbitrary data-sources, while still providing the simplest possible unified-interface at the user-level by routing to the correct wrapper's endpoint. In fact, if we knew how they were routed, some 'wrong' calls actually work: <pre><code>df = await datapoller.equities.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    exchange=\"CC\"\n)\n</code></pre> this works because even though we are using the <code>equities</code> datapoller, we specified the <code>CC</code> exchange which maps to the  crypto asset class in the <code>eodhd</code> vendor. Of course, we do not  recommend such workarounds. Note that additional arguments to otherwise valid requests are simply ignored - this request is valid: <pre><code>df = await datapoller.crypto.get_trade_bars(\n    ticker=\"BTC-USD\",\n    start=datetime(2000,1,1),\n    end=datetime(2020,1,1),\n    src=\"eodhd\",\n    gibberish=\"gibberish\"\n)\n</code></pre> Let's make a request to a <code>@poller</code> method, such as  the <code>quantpylib.datapoller.equities.get_ticker_fundamentals</code>. The <code>@poller</code> only asks for the <code>src</code> parameter,  while <code>get_ticker_fundamentals</code> asks for a <code>ticker</code> parameter, so we can do <pre><code>df=datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\",src=\"eodhd\")\n</code></pre> that routs to the <code>eodhd</code> wrapper. Everything else is the same.</p>"},{"location":"datapoller/datapoller/#safe-throttling","title":"Safe-Throttling","text":"<p>As far as possible, when the specified endpoint specifies rate-limits, rapid submission of requests are sent-through  to the data-vendor as quickly as possible, while respecting the rate-limits. This is done by using our custom semaphore-like logic, defined in the <code>quantpylib.throttler.rate_semaphore</code>. This is specific to each data-vendor, and each instance of the wrapper around  our data-source has its own resource-pool. This design is to maximise throughput of user-requests, and is supported in both asynchronous and synchronous methods. All requests submitted to a specific datasource with  throttle-support will be paced, with support for multi-threading or coroutines. For instance, suppose we do <pre><code>import threading\nimport requests\ntry:\n    def raw():\n        response=requests.get(f\"https://eodhd.com/api/fundamentals/AAPL.US?api_token={os.getenv('EOD_KEY')}&amp;fmt=json\")\n        if response.status_code == 429: raise Exception(\"TooManyTooFast\")\n        else: print(response.status_code)\n    req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n    threads=[threading.Thread(target=raw,args=()) for i in range(500)]\n    # req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n    # threads=[threading.Thread(target=req,args=()) for i in range(500)]\n    for thread in threads: thread.start()\n    for thread in threads: thread.join()\nexcept Exception as err:\n    print(err)\n</code></pre> The raw, multi-threaded request will eventually get rejected by the server with a <code>429 TooManyRequests</code> code, while if we try: <pre><code># req=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\n# threads=[threading.Thread(target=raw,args=()) for i in range(500)]\nreq=lambda:datapoller.equities.get_ticker_fundamentals(ticker=\"AAPL\")\nthreads=[threading.Thread(target=req,args=()) for i in range(500)]\n</code></pre> the application will gracefully pace the execution of multiple threads and  not crash.</p>"},{"location":"datapoller/datapoller/#examples","title":"Examples","text":"<p>A number of examples are given. This would be the setup: <pre><code>import os\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\nfrom quantpylib.datapoller.master import DataPoller\n\nconfig_keys = {\n    \"yfinance\": {\"alias\":\"yfinance\"},\n    \"eodhd\": {\"eod_key\":os.getenv(\"EOD_KEY\")},\n    \"binance\": {},\n    \"oanda\": {\n        \"alias\":\"oanda\",\n        \"account_id\":os.getenv(\"OANDA_ACC\"),\n        \"secret\": os.getenv(\"OANDA_KEY\"),\n        \"env\":\"practice\",\n    },\n    \"hyperliquid\": {\"alias\":\"hyp\",\"key\":os.getenv(\"HYP_PUBLIC\"),\"secret\":os.getenv(\"HYP_KEY\")},\n}\n\nasync def main():\n    start,end=datetime(2023,9,30),datetime.now()\n    datapoller = DataPoller(config_keys=config_keys)\n    print(datapoller.src_pollers)\n\n    await datapoller.init_clients()\n\n    #...code goes between here...\n\n    await datapoller.cleanup_clients()\n    print(\"cleanup\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-ohlcv","title":"Get OHLCV","text":"<p>Let's get OHLCV for crypto, currencies and equities. We get <code>AAPL</code>, <code>EUR_USD</code>, <code>BTCUSDT</code> OHLCV data from  the <code>equities</code>, <code>currencies</code> and <code>crypto</code> datapoller  using source <code>eodhd</code>, <code>oanda</code> and <code>binance</code> respectively. The same contract may trade under different tickers, as we see in <code>hyperliquid</code> -  we need to match to the correct symbol. <pre><code>df1=await datapoller.equities.get_trade_bars(ticker=\"AAPL\",periods=500,end=end,granularity=\"d\",src=\"eodhd\")\ndf2=await datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"h\",src=\"oanda\")\ndf3=await datapoller.crypto.get_trade_bars(ticker=\"BTCUSDT\",start=start,end=end,granularity=\"d\",src=\"binance\")\ndf4=await datapoller.crypto.get_trade_bars(ticker=\"BTC\",start=start,end=end,granularity=\"d\",src=\"hyp\")\nprint(df1,df2,df3,df4)\n</code></pre> We can go for other data-granularities and multipliers: <pre><code>df=await datapoller.currencies.get_trade_bars(ticker=\"EUR_USD\",start=start,end=end,granularity=\"h\",granularity_multiplier=4,src=\"oanda\")\nprint(df)\n</code></pre> and we get 4-hour candles: <pre><code>                              open     high      low    close  volume\ndatetime                                                             \n2020-01-01 22:00:00+00:00  1.12124  1.12246  1.12124  1.12209     673\n2020-01-02 02:00:00+00:00  1.12206  1.12247  1.12010  1.12044     700\n2020-01-02 06:00:00+00:00  1.12044  1.12140  1.12013  1.12032    2392\n2020-01-02 10:00:00+00:00  1.12034  1.12039  1.11830  1.11966    2610\n2020-01-02 14:00:00+00:00  1.11962  1.12030  1.11636  1.11700    4887\n...                            ...      ...      ...      ...     ...\n2024-04-04 17:00:00+00:00  1.08587  1.08620  1.08319  1.08374   13217\n2024-04-04 21:00:00+00:00  1.08401  1.08441  1.08350  1.08416    9891\n2024-04-05 01:00:00+00:00  1.08416  1.08431  1.08234  1.08264    7608\n2024-04-05 05:00:00+00:00  1.08263  1.08464  1.08226  1.08376    9345\n2024-04-05 09:00:00+00:00  1.08374  `1.08422  1.08350  1.08393    1436\n</code></pre> The datapoller routs to the <code>oanda</code> wrapper, and because Oanda places a limit of candles per request, given your polling-period and granularity desired, there may be multiple requests to  the Oanda REST API server to stitch together the non-overlapping periods. This is the advantage of our <code>datapoller</code> and <code>wrapper</code> interface - the user does not have to concern themselves with the source-specific limitations.</p>"},{"location":"datapoller/datapoller/#get-tick-historical","title":"Get Tick Historical","text":"<p>Some endpoints support historical data. <code>eodhd</code> has support for  tick data on the US-listed common-stocks. <pre><code>ticks=datapoller.equities.get_trade_ticks(ticker=\"META\",start=datetime(2023,4,3,0,0,0), end=datetime(2023,4,3,12,0,0))\nprint(ticks)\n</code></pre> We get: <pre><code>     ex mkt   price      seq  shares    sl sub_mkt             ts\n0     Q   K  211.00    77001       5  @ TI          1680508800013\n1     Q   K  211.42    77002       1  @ TI          1680508800013\n2     Q   K  210.99    77124      10  @ TI          1680508800017\n3     Q   K  211.42    77125       7  @ TI          1680508800017\n4     Q   K  211.42    77127      30  @ TI          1680508800017\n...  ..  ..     ...      ...     ...   ...     ...            ...\n2071  Q   Q  210.00  3635409      59  @FTI          1680523180411\n2072  Q   Q  210.00  3635410      41  @FTI          1680523180411\n2073  Q   K  210.00  3636017     800  @FT           1680523181713\n2074  Q   Q  210.00  3636650      20  @FTI          1680523184200\n2075  Q   K  210.00  3637810      27  @FTI          1680523185877\n\n[2076 rows x 8 columns]\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-fundamentals","title":"Get Fundamentals","text":"<p>Some assets and datasources support fundamental data. We could  get fundamental data for Goldman Sachs and Ethereum like this: <pre><code>f1=datapoller.equities.get_ticker_fundamentals(ticker=\"GS\",src=\"eodhd\")\nf2=datapoller.crypto.get_ticker_fundamentals(ticker=\"ETH-USD\",src=\"eodhd\")\n</code></pre></p>"},{"location":"datapoller/datapoller/#get-exchange-universe","title":"Get Exchange Universe","text":"<p>We might also be interested in getting the listed set of tickers for  a data vendor or exchange. In the case of <code>eodhd</code>, a data vendor,  they support multiple exchanges. We can type in the search-bar (top right)  for the endpoint <code>get_tickers_in_exchange</code>, and we see <code>binance</code>, <code>eodhd</code> and <code>oanda</code> support this endpoint through the <code>exchange</code> datapoller. We can see that the <code>eodhd</code> endpoint takes in an <code>exchange</code> parameter, so we can ask for their US-listed stocks as follows: <pre><code>tickers = datapoller.exchange.get_tickers_in_exchange(exchange=\"US\",src=\"eodhd\")\n</code></pre> On the other hand Binance is already an exchange, so looking at their endpoint, we see that no additional argument is required, so we can do the route by (same for <code>oanda</code>)  <pre><code>tickers = datapoller.exchange.get_tickers_in_exchange(src=\"binance\")\ntickers = datapoller.exchange.get_tickers_in_exchange(src=\"oanda\")\n</code></pre> Note that the return type from these endpoints are mostly not-standardized, and no have fixed schema, except for the <code>get_trade_bars</code> and common methods. This is a point for improvement that we are hoping contributors can come in, as we need the manpower!</p>"},{"location":"datapoller/datapoller/#queries","title":"Queries","text":"<p>Some data vendors provide a functionality to input some string or alternatively formatted specification into their search engine. This is provided in the <code>quantpylib.datapoller.metadata.query_engine</code> method: <pre><code>query = datapoller.metadata.query_engine(query=\"AAPL\")\nprint(query)\n</code></pre> gives us <pre><code>      Code Exchange                                               Name          Type  ... Currency          ISIN previousClose  previousCloseDate\n0     AAPL       US                                          Apple Inc  Common Stock  ...      USD  US0378331005      168.8200         2024-04-04\n1     AAPL       BA                                      Apple Inc DRC  Common Stock  ...      ARS  US0378331005     8925.5000         2024-04-04\n2     AAPL       MX                                          Apple Inc  Common Stock  ...      MXN  US0378331005     2807.0300         2024-04-04\n3     AAPL      NEO                                      Apple Inc CDR  Common Stock  ...      CAD  CA03785Y1007       25.0400         2024-04-04\n4     AAPL       SN                                          Apple Inc  Common Stock  ...      USD  US0378331005      170.5200         2024-04-04\n5   AAPL34       SA                                          Apple Inc  Common Stock  ...      BRL  BRAAPLBDR004       42.8200         2024-04-04\n6     AAPU       US  Direxion Shares ETF Trust - Direxion Daily AAP...           ETF  ...      USD  US25461A8743       21.9100         2024-04-04\n7     AAPD       US  Direxion Shares ETF Trust - Direxion Daily AAP...           ETF  ...      USD  US25461A3041       23.0400         2024-04-04\n8     APLY       US           YieldMax AAPL Option Income Strategy ETF           ETF  ...      USD  US88634T8577       16.5600         2024-04-04\n9     3SAP       PA                                   Granite -3x AAPL           ETF  ...      EUR  XS2193970030       26.9500         2024-04-04\n10    APLY      NEO              APPLE (AAPL) Yield Shares Purpose ETF           ETF  ...      CAD          None       22.7000         2024-04-04\n11    3LAP       PA                                   Granite +3x AAPL           ETF  ...      EUR  XS2193969883       18.4260         2024-04-04\n12    SALE      LSE  Leverage Shares 3x Short Apple (AAPL) ETP Secu...           ETF  ...      EUR  XS2472334742        2.9949         2024-04-04\n13    3SAA    XETRA               Leverage Shares -3x Short Apple AAPL           ETF  ...      EUR  XS2472334742        2.9892         2024-04-04\n14    AAPY       US       Kurv Yield Premium Strategy Apple (AAPL) ETF           ETF  ...      USD          None       23.3839         2024-04-04\n</code></pre></p>"},{"location":"datapoller/datapoller/#streaming-data","title":"Streaming Data","text":"<p>Datapoller allows for market data streaming using socket connections when made available by the endpoints of the data source. We can see that both <code>eodhd</code> and <code>oanda</code> support  subscription to L1-Book/BBO data, as does the <code>equities</code>,<code>currencies</code> data class. We can make request: <pre><code>async def handler(msg):\n    print(msg)\n\nawait datapoller.currencies.l1_book_subscribe(ticker=\"EURUSD\",handler=handler,src=\"eodhd\")\nawait datapoller.currencies.l1_book_subscribe(ticker=\"EUR_USD\",handler=handler,src=\"oanda\")\nawait datapoller.equities.l1_book_subscribe(ticker=\"AAPL\",handler=handler,src=\"eodhd\")\n</code></pre> Some data sources such as <code>binance</code> and <code>hyperliquid</code> allow for L2-Book data subscriptions. We let it stream for 20 seconds. <pre><code>await datapoller.crypto.l2_book_subscribe(ticker=\"BTCUSDT\",handler=handler,src=\"binance\")\nawait datapoller.crypto.l2_book_subscribe(ticker=\"BTC\",handler=handler,src=\"hyp\")\nawait asyncio.sleep(20)\n</code></pre> As the messages come through the subscription channels, our handler prints them out to console: <pre><code>...\n{'ts': 1716111203621, 'b': [[67035.0, 2.44344], [67034.0, 0.1216], ...], 'a': [[67036.0, 0.00303], ...]}\n...\n</code></pre> Of course, you can stream the same assets from different data sources, different assets from the same data source, and so on simultaneously...</p> <p>Once we are done, we can close the streams: <pre><code>await asyncio.gather(\n    *[\n        datapoller.currencies.l1_book_unsubscribe(ticker=\"EURUSD\",src=\"eodhd\"),\n        datapoller.currencies.l1_book_unsubscribe(ticker=\"EUR_USD\",src=\"oanda\"),\n        datapoller.equities.l1_book_unsubscribe(ticker=\"AAPL\",src=\"eodhd\"),\n        datapoller.crypto.l2_book_unsubscribe(ticker=\"BTCUSDT\",src=\"binance\")\n    ]\n)\nprint(\"closed all but one stream\")\n</code></pre></p>"},{"location":"datapoller/equities/","title":"quantpylib.datapoller.equities","text":""},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities","title":"<code>Equities</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_dividends","title":"<code>get_ticker_dividends(ticker, **kwargs)</code>","text":"<p>Retrieve ticker dividends. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_earnings_history","title":"<code>get_ticker_earnings_history(ticker, **kwargs)</code>","text":"<p>Retrieve ticker earnings history. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_earnings_trend","title":"<code>get_ticker_earnings_trend(ticker, **kwargs)</code>","text":"<p>Retrieve ticker earnings trend. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_financials","title":"<code>get_ticker_financials(ticker, **kwargs)</code>","text":"<p>Retrieve ticker financials. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, **kwargs)</code>","text":"<p>Retrieve ticker fundamentals. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f1=datapoller.equities.get_ticker_fundamentals(ticker=\"GS\",src=\"eodhd\")\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_historical_mcap","title":"<code>get_ticker_historical_mcap(ticker, **kwargs)</code>","text":"<p>Retrieve ticker historical market cap. @ts_poller(assert_span=False, automap_span=False)</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_insider_txn","title":"<code>get_ticker_insider_txn(ticker, **kwargs)</code>","text":"<p>Retrieve ticker insider transactions. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve ticker metadata. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_shares_stats","title":"<code>get_ticker_shares_stats(ticker, **kwargs)</code>","text":"<p>Retrieve ticker shares statistics. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_splits","title":"<code>get_ticker_splits(ticker, **kwargs)</code>","text":"<p>Retrieve ticker splits. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_ticker_stat_snapshot","title":"<code>get_ticker_stat_snapshot(ticker, **kwargs)</code>","text":"<p>Retrieve ticker statistical snapshot. @poller</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_trade_bars","title":"<code>get_trade_bars(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLC(V) trade bars data. @ts_poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = datapoller.equities.get_trade_bars(ticker=\"AAPL\",start=datetime(2020,1,1),periods=365,src=\"yfinance\")\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.get_trade_ticks","title":"<code>get_trade_ticks(start, end, **kwargs)</code>","text":"<p>Retrieve ticker ticks data. @ts_poller(automap_span=False)</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start datetime.</p> required <code>end</code> <code>datetime</code> <p>End datetime.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ticks=datapoller.equities.get_trade_ticks(ticker=\"META\",start=datetime(2023,4,3,0,0,0), end=datetime(2023,4,3,12,0,0))\n</code></pre>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 order book data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Stream L2 order book data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/equities/#quantpylib.datapoller.equities.Equities.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data. @poller(tag=\"stream\")</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code>"},{"location":"datapoller/exchange/","title":"quantpylib.datapoller.exchange","text":""},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange","title":"<code>Exchange</code>","text":"<p>               Bases: <code>BasePoller</code></p> <p>A class for interacting with exchange-related data sources.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.check_exchange_open","title":"<code>check_exchange_open(**kwargs)</code>","text":"<p>Check if the exchange is open for trading. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The exchange trading status from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_delisted_tickers_in_exchange","title":"<code>get_delisted_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the collection of delisted tickers in a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of delisted tickers in the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_holidays","title":"<code>get_exchange_holidays(**kwargs)</code>","text":"<p>Retrieve the exchange holidays for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The exchange holidays for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_hours","title":"<code>get_exchange_hours(**kwargs)</code>","text":"<p>Retrieve the trading hours for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The trading hours for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_server_timestamp","title":"<code>get_exchange_server_timestamp(**kwargs)</code>","text":"<p>Retrieve the server timestamp for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The server timestamp for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_exchange_tz","title":"<code>get_exchange_tz(**kwargs)</code>","text":"<p>Retrieve the time zone for a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The time zone for the specified exchange from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_supported_exchanges","title":"<code>get_supported_exchanges(**kwargs)</code>","text":"<p>Retrieve the collection of supported exchanges. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of supported exchanges from the selected data source.</p>"},{"location":"datapoller/exchange/#quantpylib.datapoller.exchange.Exchange.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the collection of tickers in a specific exchange. @poller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Data-source specific keyword arguments for endpoint specification.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The collection of tickers in the specified exchange from the selected data source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tickers = datapoller.exchange.get_tickers_in_exchange(exchange=\"US\",src=\"eodhd\")\n&gt;&gt;&gt; tickers = datapoller.exchange.get_tickers_in_exchange(src=\"binance\")\n</code></pre>"},{"location":"datapoller/master/","title":"quantpylib.datapoller.master","text":""},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller","title":"<code>DataPoller</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.__init__","title":"<code>__init__(config_keys=None)</code>","text":"<p>Initialize the DataPoller class with the provided configuration keys. The configuration keys are passed in as dictionaries with the appropriate key-value pair. An example of the valid key-value format is shown as default arguments. You can create a <code>.env</code>file and place your keys there, or set it as environment variables. All the datapollers are available through this master poller,  by accessing the attribute values <code>datapoller.equities</code>, <code>datapoller.crypto</code> and so on.</p> <p>Parameters:</p> Name Type Description Default <code>config_keys</code> <code>dict</code> <p>A dictionary containing configuration keys for different data sources.  The key-pair dictionary is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code> where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the  <code>src</code> parameter to the datapoller methods. API keys are required for private endpoints only. For instance, we pass in <code>{ \"binance\": { \"api_key\" : MY_KEY , \"api_secret\" : SECRET } }</code> matching to the constructor in <code>quantpylib.wrappers.Binance</code> that looks like :</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>equities</code> <code>Equities</code> <p>An instance of Equities that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>metadata</code> <code>Metadata</code> <p>An instance of Metadata that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>crypto</code> <code>Crypto</code> <p>An instance of Crypto that uses the specified data pollers and defaults to 'binance' as the source.</p> <code>currencies</code> <code>Currencies</code> <p>An instance of Currencies that uses the specified data pollers and defaults to 'eodhd' as the source.</p> <code>exchange</code> <code>Exchange</code> <p>An instance of Exchange that uses the specified data pollers and defaults to 'eodhd' as the source.</p>"},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.__init__--def-initselfapi_keynoneapi_secretnonekwargs","title":"def init(self,api_key=None,api_secret=None,**kwargs):","text":""},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.cleanup_clients","title":"<code>cleanup_clients()</code>  <code>async</code>","text":"<p>Cleans up all clients asynchronously, if applicable.</p>"},{"location":"datapoller/master/#quantpylib.datapoller.master.DataPoller.init_clients","title":"<code>init_clients()</code>  <code>async</code>","text":"<p>Initializes all clients asynchronously, if applicable.</p>"},{"location":"datapoller/metadata/","title":"quantpylib.datapoller.metadata","text":""},{"location":"datapoller/metadata/#quantpylib.datapoller.metadata.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>BasePoller</code></p>"},{"location":"datapoller/metadata/#quantpylib.datapoller.metadata.Metadata.query_engine","title":"<code>query_engine(query, **kwargs)</code>","text":"<p>Execute a query using a specific data poller.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to be executed.</p> required <code>**kwargs</code> <p>Additional keyword arguments for executing the query.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the query execution using the specified data poller.</p>"},{"location":"datapoller/utils/","title":"quantpylib.datapoller.utils","text":""},{"location":"datapoller/utils/#quantpylib.datapoller.utils.poller","title":"<code>poller(_func=None, *, tag=None)</code>","text":"<p>Decorator for instance level methods of <code>quantpylib.datapoller.base.BasePoller</code> objects.  Let the object be given the variable name <code>poller_obj</code>, then decorated instance level methods  have augmented default arguments <code>**kwargs</code> with following key-pairs:</p> <p>Specs:</p> <pre><code>src (string): Data source we want to poll for. Defaults to `poller_obj.default_src`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>The decorated instance level method.</p>"},{"location":"datapoller/utils/#quantpylib.datapoller.utils.ts_poller","title":"<code>ts_poller(_func=None, *, tag=None, assert_span=True, automap_span=True)</code>","text":"<p>Decorator for instance level methods of <code>quantpylib.datapoller.base.BasePoller</code> objects.  Let the object be given the variable name <code>poller_obj</code>, then decorated instance level methods  have augmented default arguments <code>**kwargs</code> with following key-pairs:</p> <p>Specs:</p> <pre><code>ticker (str): The identifier for the time-series of interest. Defaults to None.\nstart (datetime.datetime): The start time of the time-series being polled. Defaults to None.\nend (datetime.datetime): The end time of the time-series being polled. Defaults to None.\nperiods (int): Number of periods of granularity_multiplier * granularity of time-series being polled. Defaults to None. \ngranularity (str): Granularity of data being polled. Valid values are ['s','m','h','d','w','M','y']. Defaults to 'd'.\ngranularity_multiplier (int): Multiplier for the granularity. For instance, 4 for multiplier and 'h' for granularity implies '4h' candles/periods. Defaults to 1.\nsrc (string): Data source we want to poll for. Defaults to `poller_obj.default_src`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>method</code> <p>The decorated instance level method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>function</code> <p>The function to be decorated. Defaults to None.</p> <code>None</code> <code>tag</code> <code>str</code> <p>A tag to identify the poller. Defaults to None.</p> <code>None</code> <code>assert_span</code> <code>bool</code> <p>Whether to assert the validity of time span arguments. If <code>True</code>, exactly two of <code>start</code>, <code>end</code>, and <code>periods</code> must be specified. Defaults to <code>True</code>.</p> <code>True</code> <code>automap_span</code> <code>bool</code> <p>Whether to automatically map (<code>start</code>,<code>end</code>,<code>periods</code>,<code>granularity</code>,<code>granularity_multiplier</code>) into time span arguments. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <p>The decorated instance level method.</p>"},{"location":"gateway/account/","title":"quantpylib.gateway.account","text":""},{"location":"gateway/account/#quantpylib.gateway.account.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_balance","title":"<code>account_balance(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_fill_subscribe","title":"<code>account_fill_subscribe(exc, handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/account/#quantpylib.gateway.account.Account.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/base/","title":"quantpylib.gateway.base","text":""},{"location":"gateway/base/#quantpylib.gateway.base.BaseGateway","title":"<code>BaseGateway</code>","text":"<p>A base class for creating exchange clients to interact with various markets.</p> <p>Attributes:</p> Name Type Description <code>clients</code> <code>dict</code> <p>A dictionary of exchange clients for different exchanges/brokerages.</p>"},{"location":"gateway/base/#quantpylib.gateway.base.BaseGateway.__init__","title":"<code>__init__(clients)</code>","text":"<p>Initialize the BaseGateway with exhange clients.</p> <p>Parameters:</p> Name Type Description Default <code>clients</code> <code>dict</code> <p>A dictionary of exchange clients for different exchanges/brokerages.</p> required"},{"location":"gateway/exchange/","title":"quantpylib.gateway.exchange","text":""},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange","title":"<code>Exchange</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.contract_specifications","title":"<code>contract_specifications(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing contract specifications such as price precision,</p> <p>quantity precision and minimum notional order value.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_exchange_server_timestamp","title":"<code>get_exchange_server_timestamp(exc, **kwargs)</code>","text":"<p>Retrieve the server timestamp from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The server timestamp from the exchange.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_exchange_tz","title":"<code>get_exchange_tz(exc, **kwargs)</code>","text":"<p>Get the timezone for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Timezone of the exchange.</p>"},{"location":"gateway/exchange/#quantpylib.gateway.exchange.Exchange.get_funding_info","title":"<code>get_funding_info(exc, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the funding information for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing funding information such as funding rate, </p> <p>funding interval, next funding time etc.</p>"},{"location":"gateway/executor/","title":"quantpylib.gateway.executor","text":""},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor","title":"<code>Executor</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.cancel_open_orders","title":"<code>cancel_open_orders(exc, **kwargs)</code>  <code>async</code>","text":"<p>Group cancel orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.cancel_order","title":"<code>cancel_order(exc, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.get_all_marks","title":"<code>get_all_marks(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all mark prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.get_all_mids","title":"<code>get_all_mids(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_get","title":"<code>l2_book_get(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Request data for L2 Order Book snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_mirror","title":"<code>l2_book_mirror(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Keep a local mirror copy of the L2 Order Book using orderbook updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_peek","title":"<code>l2_book_peek(ticker, exc, **kwargs)</code>","text":"<p>Retrieve the local mirror copy of the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The local mirror copy of the L2 Order Book.</p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book update/increment/snapshot streams.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_subscriptions","title":"<code>l2_book_subscriptions(exc, **kwargs)</code>","text":"<p>Get the current subscriptions to the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The current L2 Order Book subscriptions.</p>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book update/increment/snapshot streams.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.limit_order","title":"<code>limit_order(ticker, amount, exc, **kwargs)</code>  <code>async</code>","text":"<p>Submit limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.market_order","title":"<code>market_order(ticker, amount, exc, **kwargs)</code>  <code>async</code>","text":"<p>Submit market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.rand_cloid","title":"<code>rand_cloid(exc, **kwargs)</code>","text":"<p>Generate a random client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/executor/#quantpylib.gateway.executor.Executor.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/gateway/","title":"quantpylib.gateway","text":"<p><code>quantpylib.gateway</code> is a quant module used for multi-exchange integration and account management.</p> <p>The clients are categorized into their gateway classes, with current support for:</p> <pre><code>- account\n- exchange\n- executor\n- orders\n- positions\n</code></pre> <p>The exchange clients supported are:</p> <pre><code>- binance\n- bybit\n- hyperliquid\n- paradex\n- woox\n</code></pre> <p>In general, a trader may have requirements for multi-exchange account management and broker integrations. Each exchange has its own authentication flow, order schema and account management - the gateway abstracts these concerns to provide a seamless, common interface for exchange integration.</p> <p>Each gateway is derived from the base <code>quantpylib.gateway.base.BaseGateway</code> class and implements a set of methods, and routs the requests to the specified exchange client and endpoints through the argument <code>\"exc\"</code>.  The supported exchange clients are written as wrappers on the <code>quantpylib.wrappers</code> module,  and their supported endpoints share the same function name as in the gateways. The different gateways are accessible via the master gateway class, given in <code>quantpylib.gateway.master.Gateway</code> object instance. For instance, if we would like to get position data using the <code>quantpylib.gateway.positions.Positions.positions_get</code>, we can do so by creating a <code>obj = Gateway(...)</code> instance, and calling <code>obj.positions.positions_get(...,exc=\"binance\")</code>. The function call is only valid if it is supported by both the gateway type and the exchange client, which we can check by their matching  function signatures. In general each exchange has its own parameters to the vendor-specific endpoint, as well as different specifications (such as limit orders through a specified price or a price-matching rule), so the library provides a flexible variation between these specifications to support the different configurations for each external API - it would be  alot easier to understand through the given examples.</p> <p>Note that each of the exchange client wrappers are also designed to be available for use as standalone Python-SDKs. Supported gateways and exchanges are added and updated frequently.</p> <p>Note that the various endpoints and their matching  function name-signatures can be easily looked up in the search-bar (top right): </p>"},{"location":"gateway/gateway/#examples","title":"Examples","text":"<p>A dictionary containing configuration keys for different exchanges we  want access to is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code>, where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the <code>exc</code> parameter in the gateway methods.</p> <p>We already have the keys in our <code>.env</code> file in the current working directory, and we will make the following imports: <pre><code>import os \nimport logging\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom datetime import datetime\n\nimport quantpylib.standards.markets as markets\nfrom quantpylib.gateway.master import Gateway\n\nconfig_keys={\n    \"binance\": {\n        \"alias\": \"binance\",\n        \"key\": os.getenv(\"BIN_PUBLIC\"),\n        \"secret\" : os.getenv(\"BIN_KEY\"),\n    },\n    \"hyperliquid\": {\n        \"alias\" : \"hyperliquid\",\n        \"key\" : os.getenv(\"HYP_DEMO\"),\n        \"secret\" : os.getenv(\"HYP_KEY\"),\n    }\n}\n\nasync def main():\n    gateway = Gateway(config_keys=config_keys)\n    print(gateway.exc_clients)\n    await gateway.init_clients()\n\n    #...code goes between here...\n\n    await gateway.cleanup_clients()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"gateway/gateway/#account","title":"Account","text":"<p>We are interested in getting some account balances. We can simply do <pre><code>res = await gateway.account.account_balance(exc='binance')\nres = await gateway.account.account_balance(exc='hyperliquid')\nprint(res) \n</code></pre> We get some details about equity and margin information: <pre><code>{'equity_total': 1884.960586, 'margin_maintenance': 131.131965, 'margin_total': 262.26393, 'equity_withdrawable': 1622.696656, 'notional_position': 5232.9393}\n</code></pre></p> <p>We want to subscribe to updates to changes in the account's positions. This happens whenever there is an order filled. I subscribe to fill events, pass it a print-handler and let it sleep. Before the sleep times out, I made a market order on the web platform. <pre><code>async def handler(msg):\n    print(msg)\n\nawait gateway.account.account_fill_subscribe(exc='hyperliquid',handler=handler)\nawait asyncio.sleep(10)\n'''\nI just put in a market order... and on my console:\n{'channel': 'userFills', \n'data': {'user': 'demodemodemodemodemodemodemodemodemodemodemodemo', \n            'fills': [{'coin': 'PENDLE', 'px': '4.1099', 'sz': '3.0', 'side': 'A', ...}}\n'''\nawait gateway.account.account_fill_unsubscribe(exc='hyperliquid')\n</code></pre></p>"},{"location":"gateway/gateway/#exchanges","title":"Exchanges","text":"<p>We may want to get contract specifications for valid orders: <pre><code>res = await gateway.exchange.contract_specifications(exc='hyperliquid')\nres = await gateway.exchange.contract_specifications(exc='binance')\nprint(res)\n</code></pre> <pre><code>{'BTCUSDT': {'price_precision': 2, 'quote_precision': 8, 'quantity_precision': 3, 'min_notional': 100.0}}, \n'ETHUSDT': {'price_precision': 2, 'quote_pr...}\n</code></pre></p>"},{"location":"gateway/gateway/#executor","title":"Executor","text":"<p>We want to make some limit orders: <pre><code>res = await gateway.executor.limit_order(ticker='PENDLE',amount=-3,price=5.001,exc='hyperliquid')\nres = await gateway.executor.limit_order(ticker='PENDLEUSDT',amount=-3,price=5.001,exc='binance')\n</code></pre> <code>Binance</code> exchange allows limit order that does not need to specify price - instead, the price is set relative to the order book state through a price-matching rule. This is specified in the <code>price_match</code> argument to the <code>quantpylib.wrappers.Binance.limit_order</code>: <pre><code>res = await gateway.executor.limit_order(ticker='PENDLEUSDT',amount=-3,price_match=markets.PRICE_MATCH_QUEUE_20,exc='binance')\n</code></pre> Here, our order sits as a maker order at price 20-levels deep. Of course, there are market orders too: <pre><code>res = await gateway.executor.market_order(ticker='PENDLE',amount=-3,exc='hyperliquid')\nprint(res)\n</code></pre> <pre><code>{'status': 'ok', 'response': {'type': 'order', 'data': {'statuses': [{'filled': {'totalSz': '3.0', 'avgPx': '4.8122', 'oid': 1234}}]}}}\n</code></pre></p> <p>It is often useful to have order book data during the execution stage. We can get an order book snapshot: <pre><code>res = await gateway.executor.l2_book_get(ticker='AAVE',exc=\"hyperliquid\")\nprint(res)\nres = await gateway.executor.l2_book_get(ticker='AAVE',exc='hyperliquid',depth=2,nsigfig=5)\nprint(res)\nres = await gateway.executor.l2_book_get(ticker='AAVEUSDT',exc=\"binance\")\nprint(res)\n</code></pre> <pre><code>{'ts': 1716119324540, 'b': array([[8.7165e+01, 6.7900e+00],...])'a':array([[8.7190e+01, 3.4490e+01],[8.7198e+01, 8.3140e+01],...])}\n{'ts': 1716119324940, 'b': (87.13, 48.1), 'a': (87.19, 34.49)}\n{'lastUpdateId': 4633878434615, 'E': 1716119327150, 'T': 1716119327141, 'bids': [['87.090', '25.7'], ['87.080', '29.9'], ['87.070', '76.1'], ['87.060', '111.7'], ['87.050', '87.9'], ['87.040', '80.8'], ['87.030', '34.1'], ['87.020', '179.0'], ['87.010', '130.4'], ['87.000', '190.9']], 'asks': [['87.100', '0.2'], ['87.110', '8.8'], ['87.120', '27.9'], ['87.130', '37.2'], ['87.140', '118.4'], ['87.150', '57.9'], ['87.160', '40.3'], ['87.170', '83.7'], ['87.180', '130.3'], ['87.190', '26.4']]}\n</code></pre> Instead of requesting a snapshot each time we need it, a socket subscription is probably more efficient if we need a constant stream of order book updates: <pre><code>await gateway.executor.l2_book_subscribe(ticker='BTC',handler=handler,exc='hyperliquid')\nawait gateway.executor.l2_book_subscribe(ticker='BTCUSDT',handler=handler,exc='binance',depth=5)\nawait asyncio.sleep(3)\n</code></pre> The handler will be invoked each time we receive an order book event or some interval. Our handler is just the print statement: <pre><code>{'ts': 1716119783147, 'b': [[67372.0, 0.68409], [67371.0, 0.56], [67370.0, 0.46385],...]...}\n</code></pre> Let's unsubscribe. <pre><code>print(gateway.executor.l2_book_subscriptions(exc='hyperliquid'))\nawait gateway.executor.l2_book_unsubscribe(ticker='BTC',exc='hyperliquid')\nprint(gateway.executor.l2_book_subscriptions(exc='hyperliquid'))\n</code></pre> Or maybe we just want mid-prices <pre><code>await gateway.executor.all_mids_subscribe(handler=handler,exc='hyperliquid')\nawait asyncio.sleep(5)\nawait gateway.executor.all_mids_unsubscribe(exc='hyperliquid')\nawait asyncio.sleep(5)\n</code></pre></p>"},{"location":"gateway/gateway/#orders","title":"Orders","text":"<p>We have order endpoints too. We can get order details using their ID: <pre><code>print(await gateway.orders.order_query(id=12345,exc='hyperliquid'))\nprint(await gateway.orders.order_query(id=1,ticker=\"PENDLEUSDT\",exc='binance'))\n</code></pre></p> <p>We want a snapshot of the orders page on the exchange: <pre><code>print(await gateway.orders.orders_get(exc='hyperliquid'))\nprint(await gateway.orders.orders_get(exc='binance'))\n</code></pre> We get <pre><code>{1234: {'ticker': 'PENDLE', 'order_id': '1234', 'limit_price': 5.001, 'amount_total': Decimal('-3.0'), 'amount_left': Decimal('-3.0'), 'timestamp': 000000}}\n{1234: {'ticker': 'PENDLEUSDT', 'order_id': '1234', 'limit_price': 5.001, 'amount_total': Decimal('-3'), 'amount_filled': Decimal('-0'), 'tif': 'GTC', 'timestamp': 000000}}\n</code></pre></p> <p>If we need to maintain a local copy of the orders page, it would be more suitable to use event subscriptions. The <code>orders_mirror</code> and <code>orders_peek</code> use the underlying socket endpoints available to keep an updated local copy of it. We need to mirror once, then subsequent calls to peek will fetch the local copy. Additionally, we may want to attach a callback handler, which is invoked whenever the local copy of the order book is modified: <pre><code>try:\n    await gateway.orders.orders_peek(exc='hyperliquid')\nexcept ValueError as e:\n    print(e)\n\nawait gateway.orders.orders_mirror(exc='hyperliquid') #OR\nawait gateway.orders.orders_mirror(on_update=handler,exc='hyperliquid')\nawait gateway.orders.orders_mirror(on_update=handler,exc='binance')\nprint(gateway.orders.orders_peek(exc='hyperliquid'))\nprint(gateway.orders.orders_peek(exc='binance'))\nawait asyncio.sleep(100)\n</code></pre> The handler receives the entire updated, local order page state when passed into the <code>orders_mirror</code> function, but we may prefer to receive just the realtime order event: <pre><code>await gateway.orders.order_updates_subscribe(handler=handler,exc='hyperliquid')\nawait asyncio.sleep(100)\nawait gateway.orders.order_updates_unsubscribe(exc='hyperliquid')\n</code></pre></p>"},{"location":"gateway/gateway/#positions","title":"Positions","text":"<p>We can get position details. As in the Orders gateway, we can request for a snapshot <pre><code>res = await gateway.positions.positions_get(exc='binance')\nres = await gateway.positions.positions_get(exc='hyperliquid')\nprint(res)\n</code></pre> <pre><code>{'SOL': {'ticker': 'SOL', 'amount': Decimal....'unrealized_pnl': 1315.35}}\n</code></pre> Or keep a local copy and peek: <pre><code>try:\n    await gateway.positions.positions_peek(exc='hyperliquid')\nexcept ValueError as e:\n    print(e)\nawait gateway.positions.positions_mirror(on_update=handler,exc='binance')\nawait gateway.positions.positions_mirror(on_update=handler,exc='hyperliquid')\nawait asyncio.sleep(100)\nprint(gateway.positions.positions_peek(exc='hyperliquid'))\n</code></pre></p>"},{"location":"gateway/master/","title":"quantpylib.gateway.master","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway","title":"<code>Gateway</code>","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.__init__","title":"<code>__init__(config_keys={})</code>","text":"<p>Initialize the Gateway class with the provided configuration keys. The configuration keys are passed in as dictionaries with the appropriate key-value pair. An example of the valid key-value format is shown as default arguments. You can create a <code>.env</code>file and place your keys there, or set it as environment variables. All the gateways are available through this master gateway,  by accessing the attribute values <code>gateway.account</code>, <code>gateway.executor</code> and so on.</p> <p>Parameters:</p> Name Type Description Default <code>config_keys</code> <code>dict</code> <p>A dictionary containing configuration keys for different exchange clients.  The key-pair dictionary is formatted as <code>\"source\" : { arg1 : var1 , arg2 : var2 }</code> where each arg is the parameter to the wrapper object instance's constructor in <code>quantpylib.wrappers</code>. An additional key-value for <code>\"alias\"</code> may be specified, which is used for reference to the  <code>exc</code> parameter to the gateway methods. API keys are required for private endpoints only. For instance, we pass in <code>{ \"binance\": { \"api_key\" : MY_KEY , \"api_secret\" : SECRET } }</code> matching to the constructor in <code>quantpylib.wrappers.Binance</code> that looks like :</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>account</code> <code>Account</code> <p>An instance of Account for account related endpoints.</p> <code>exchange</code> <code>Exchange</code> <p>An instance of Exchange for exchange related endpoints.</p> <code>executor</code> <code>Executor</code> <p>An instance of Executor for execution related endpoints.</p> <code>orders</code> <code>Orders</code> <p>An instance of Orders for order related endpoints.</p> <code>positions</code> <code>Positions</code> <p>An instance of Positions for position related endpoints.</p> <code>trades</code> <code>Trades</code> <p>An instance of Trades for trades related endpoints.</p> <code>transactions</code> <code>Transactions</code> <p>An instance of Transactions for transaction related endpoints.</p>"},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.__init__--def-initselfapi_keynoneapi_secretnonekwargs","title":"def init(self,api_key=None,api_secret=None,**kwargs):","text":""},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.cleanup_clients","title":"<code>cleanup_clients()</code>  <code>async</code>","text":"<p>Cleanup all exchange clients that have a <code>cleanup</code> method.</p> <p>This method iterates through all the exchange clients and calls their <code>cleanup</code> method, if it exists. This is useful for performing any necessary cleanup actions, such as closing connections or releasing resources.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of results from the <code>cleanup</code> method calls.</p>"},{"location":"gateway/master/#quantpylib.gateway.master.Gateway.init_clients","title":"<code>init_clients()</code>  <code>async</code>","text":"<p>Initialize all exchange clients that have an <code>init_client</code> method.</p> <p>This method iterates through all the exchange clients and calls their <code>init_client</code> method, if it exists. This is useful for setting up any necessary initializations before using the clients.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of results from the <code>init_client</code> method calls.</p>"},{"location":"gateway/orders/","title":"quantpylib.gateway.orders","text":""},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders","title":"<code>Orders</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_query","title":"<code>order_query(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(str, int)</code> <p>Order ID in exchange</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, exc, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(exc, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_get","title":"<code>orders_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_mirror","title":"<code>orders_mirror(exc, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/orders/#quantpylib.gateway.orders.Orders.orders_peek","title":"<code>orders_peek(exc, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/","title":"quantpylib.gateway.positions","text":""},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions","title":"<code>Positions</code>","text":"<p>               Bases: <code>BaseGateway</code></p>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_get","title":"<code>positions_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_mirror","title":"<code>positions_mirror(exc, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open positons.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/positions/#quantpylib.gateway.positions.Positions.positions_peek","title":"<code>positions_peek(exc, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"gateway/utils/","title":"quantpylib.gateway.utils","text":""},{"location":"gateway/utils/#quantpylib.gateway.utils.standardize_query","title":"<code>standardize_query(_func=None, *, tag=None)</code>","text":"<p>Decorator that standardizes key-value data types returned to their standard forms  as defined in <code>quantpylib.standards.markets</code>.</p>"},{"location":"hft/features/","title":"quantpylib.hft.features","text":""},{"location":"hft/features/#quantpylib.hft.features.flow_pnl","title":"<code>flow_pnl(trades)</code>","text":"<p>Calculates the pnl of the a set of trades.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>ndarray</code> <p>2d-array of trades as <code>[[timestamp, price, size, direction], ...]</code>.</p> required <p>Returns:</p> Type Description <p>np.ndarray: The timestamps, running PnLs and cumulative volumes.</p>"},{"location":"hft/features/#quantpylib.hft.features.rolling_vol","title":"<code>rolling_vol(mids, n, exp=False)</code>","text":"<p>Calculate rolling volatility of the mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>mids</code> <code>ndarray</code> <p>Array of mid prices.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling volatilities.</p>"},{"location":"hft/features/#quantpylib.hft.features.trade_imbalance","title":"<code>trade_imbalance(trades, decay_function=lambda sample: exponential_weights(arr=sample, unique_values=True, normalize=True))</code>","text":"<p>Calculate the trade imbalance for a given set of trades w.r.t. some decay function.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>ndarray</code> <p>2d-array of trades as <code>[[timestamp, price, size, direction], ...]</code>.</p> required <code>decay_function</code> <code>function</code> <p>The decay function. Defaults to <code>exponential_weights</code>.</p> <code>lambda sample: exponential_weights(arr=sample, unique_values=True, normalize=True)</code>"},{"location":"hft/features/#quantpylib.hft.features.vol","title":"<code>vol(sample, exp=False)</code>","text":"<p>Calculate the sample volatility.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>ndarray</code> <p>The input sample.</p> required <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated sample volatility.</p>"},{"location":"hft/feed/","title":"quantpylib.hft.feed","text":""},{"location":"hft/feed/#quantpylib.hft.feed.Feed","title":"<code>Feed</code>","text":""},{"location":"hft/feed/#quantpylib.hft.feed.Feed.__init__","title":"<code>__init__(gateway, exchanges=None, archiver=False)</code>","text":"<p>Initialize the feeder object.</p> <p>Parameters:</p> Name Type Description Default <code>gateway</code> <code>Gateway</code> <p>Initialized gateway object.</p> required <code>exchanges</code> <code>list</code> <p>The list of exchanges to subscribe to. If None, use the clients in the gateway.</p> <code>None</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_handler_to_feed","title":"<code>add_handler_to_feed(feed_id, handler)</code>","text":"<p>Add a handler to a feed.</p> <p>Parameters:</p> Name Type Description Default <code>feed_id</code> <code>str</code> <p>The feed id.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add.</p> required"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_l2_book_feed","title":"<code>add_l2_book_feed(exc, ticker, handler=None, depth=20, buffer=100, apply_shadow_depth=False, **kwargs)</code>  <code>async</code>","text":"<p>Add a level 2 order book feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The depth of the order book. Defaults to 20.</p> <code>20</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.add_trades_feed","title":"<code>add_trades_feed(exc, ticker, handler=None, buffer=100, **kwargs)</code>  <code>async</code>","text":"<p>Add a trades feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleanup the feeder object.</p>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.flush_archives","title":"<code>flush_archives(path='./archives/', prefix='', postfix='', idx='')</code>","text":"<p>Flush the archives to disk with filename <code>{path}/{exchange}/{feed_cls}/{feed_type}/{prefix}{ticker}{_metadata}{postfix}.parquet</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>prefix</code> <code>str</code> <p>The prefix for the archive filename. Defaults to ''.</p> <code>''</code> <code>postfix</code> <code>str</code> <p>The postfix for the archive filename. Defaults to ''.</p> <code>''</code> <code>idx</code> <code>str</code> <p>The partial archive index. Defaults to ''.</p> <code>''</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.get_feed","title":"<code>get_feed(feed_id)</code>","text":"<p>Get the feed object or buffer associated with feed_id.</p> <p>Parameters:</p> Name Type Description Default <code>feed_id</code> <code>str</code> <p>The feed id.</p> required"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.get_feed_id","title":"<code>get_feed_id(exc, feed_cls, feed_type, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Get the feed id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>feed_cls</code> <code>str</code> <p>The asset class.</p> required <code>feed_type</code> <code>str</code> <p>The feed type.</p> required"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.get_feed_ids","title":"<code>get_feed_ids()</code>","text":"<p>Get list of all feed ids.</p>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.load_lob_archive","title":"<code>load_lob_archive(exc, ticker, depth, feed_cls=FeedCls.PERPETUAL, path='./archives/', prefix='', postfix='', raw=False)</code>  <code>staticmethod</code>","text":"<p>Load parquet lob archives from disk. Loads the file from <code>{path}/{exchange}/{feed_cls}/{feed_type}/{prefix}{ticker}{postfix}.parquet</code>. An example would be <code>./archives/binance/perp/l2book/BTCUSDT_depth20.parquet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>depth</code> <code>int</code> <p>The depth of the order book archive.</p> required <code>feed_cls</code> <code>str</code> <p>The asset class. Defaults to FeedCls.PERPETUAL.</p> <code>PERPETUAL</code> <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>prefix</code> <code>str</code> <p>The prefix for the archive. Defaults to ''.</p> <code>''</code> <code>postfix</code> <code>str</code> <p>The postfix for the archive. Defaults to ''.</p> <code>''</code> <code>raw</code> <code>bool</code> <p>Whether to return the raw loaded parquet dataframe or processed archive <code>[{ts,b,a}]</code>.</p> <code>False</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.load_lob_archives","title":"<code>load_lob_archives(exc, ticker, depth, feed_cls=FeedCls.PERPETUAL, path='./archives/', start=datetime.now(pytz.utc) - timedelta(days=14), end=datetime.now(pytz.utc), only_paths=False)</code>  <code>staticmethod</code>","text":"<p>Load parquet lob archives that have been saved by the scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>depth</code> <code>int</code> <p>The depth of the order book archive.</p> required <code>feed_cls</code> <code>str</code> <p>The asset class. Defaults to FeedCls.PERPETUAL.</p> <code>PERPETUAL</code> <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>start</code> <code>str or datetime</code> <p>The start date. Can take str format <code>%Y-%m-%d:%H</code> .Defaults to <code>datetime.now(pytz.utc) - timedelta(days=14)</code>.</p> <code>now(utc) - timedelta(days=14)</code> <code>end</code> <code>str or datetime</code> <p>The end date. Can take str format <code>%Y-%m-%d:%H</code>. Defaults to <code>datetime.now(pytz.utc)</code>.</p> <code>now(utc)</code> <code>only_paths</code> <code>bool</code> <p>Whether to return only the paths to the archives. Defaults to False.</p> <code>False</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.load_trade_archive","title":"<code>load_trade_archive(exc, ticker, feed_cls=FeedCls.PERPETUAL, path='./archives/', prefix='', postfix='', raw=False)</code>  <code>staticmethod</code>","text":"<p>Load parquet trade archives from disk. Loads the file from <code>{path}/{exchange}/{feed_cls}/{feed_type}/{prefix}{ticker}{postfix}.parquet</code>. An example would be <code>./archives/binance/perp/trades/BTCUSDT.parquet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>feed_cls</code> <code>str</code> <p>The asset class. Defaults to FeedCls.PERPETUAL.</p> <code>PERPETUAL</code> <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>prefix</code> <code>str</code> <p>The prefix for the archive. Defaults to ''.</p> <code>''</code> <code>postfix</code> <code>str</code> <p>The postfix for the archive. Defaults to ''.</p> <code>''</code> <code>raw</code> <code>bool</code> <p>Whether to return the raw loaded parquet or processed archive <code>[[ts,price,size,dir]]</code>.</p> <code>False</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.load_trade_archives","title":"<code>load_trade_archives(exc, ticker, feed_cls=FeedCls.PERPETUAL, path='./archives/', start=datetime.now(pytz.utc) - timedelta(days=14), end=datetime.now(pytz.utc), only_paths=False)</code>  <code>staticmethod</code>","text":"<p>Load parquet trade archives that have been saved by the scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>feed_cls</code> <code>str</code> <p>The asset class. Defaults to FeedCls.PERPETUAL.</p> <code>PERPETUAL</code> <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>start</code> <code>str or datetime</code> <p>The start date. Can take str format <code>%Y-%m-%d:%H</code> .Defaults to <code>datetime.now(pytz.utc) - timedelta(days=14)</code>.</p> <code>now(utc) - timedelta(days=14)</code> <code>end</code> <code>str or datetime</code> <p>The end date. Can take str format <code>%Y-%m-%d:%H</code>. Defaults to <code>datetime.now(pytz.utc)</code>.</p> <code>now(utc)</code> <code>only_paths</code> <code>bool</code> <p>Whether to return only the paths to the archives. Defaults to False.</p> <code>False</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.run_archive_scheduler","title":"<code>run_archive_scheduler(splits=1, squash=True, rm_subfiles=True, max_workers=5)</code>  <code>async</code>","text":"<p>Run the archive scheduler which saves data with the following rules.</p> <p>1: Store data in an archive buffer. 2: At the end of every hour, flush the buffer to disk. If splits &gt; 1, flush the buffer every <code>3600 / splits</code> seconds to partial archive to reduce memory load. 3: The files are stored in <code>./archives/{exchange}/{feed_cls}/{feed_type}/{yy}/{mm}/{ticker}{_metadata}_{ddhh}.parquet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>splits</code> <code>int</code> <p>The number of archival splits in an hour. Defaults to 1.</p> <code>1</code> <code>squash</code> <code>bool</code> <p>Whether to squash the partial archives automatically. Defaults to True.</p> <code>True</code> <code>rm_subfiles</code> <code>bool</code> <p>Whether to remove the subfiles after squashing. Defaults to True.</p> <code>True</code> <code>max_workers</code> <code>int</code> <p>The number of thread workers to use for squashing. Defaults to 5.</p> <code>5</code>"},{"location":"hft/feed/#quantpylib.hft.feed.Feed.squash_archives","title":"<code>squash_archives(path='./archives/', rm_subfiles=False, max_workers=5)</code>  <code>staticmethod</code>","text":"<p>Squash the partial parquet archives to a single parquet archive.  Partial archives are used to store data in chunks when the scheduler is ran with splits &gt; 1 to reduce memory footprint.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the archives. Defaults to './archives/'.</p> <code>'./archives/'</code> <code>rm_subfiles</code> <code>bool</code> <p>Whether to remove the subfiles after squashing. Defaults to False.</p> <code>False</code> <code>max_workers</code> <code>int</code> <p>The number of thread workers to use for squashing. Defaults to 5.</p> <code>5</code>"},{"location":"hft/feed/#quantpylib.hft.feed.FeedCls","title":"<code>FeedCls</code>","text":"<p>Asset classes.</p> <p>Attributes:</p> Name Type Description <code>PERPETUAL</code> <code>str</code> <p>Perpetual futures.</p> <code>FUTURES</code> <code>str</code> <p>Futures.</p> <code>SPOT</code> <code>str</code> <p>Spot.</p> <code>OPTIONS</code> <code>str</code> <p>Options.</p>"},{"location":"hft/feed/#quantpylib.hft.feed.FeedType","title":"<code>FeedType</code>","text":"<p>Types of feeds.</p> <p>Attributes:</p> Name Type Description <code>L1BOOK</code> <code>str</code> <p>Level 1 order book feed.</p> <code>L2BOOK</code> <code>str</code> <p>Level 2 order book feed.</p> <code>L2DELTA</code> <code>str</code> <p>Level 2 order book delta feed.</p> <code>TRADES</code> <code>str</code> <p>Trades feed.</p> <code>MIDS</code> <code>str</code> <p>Mid prices</p>"},{"location":"hft/hft/","title":"quantpylib.hft","text":"<p><code>quantpylib.hft</code> is our core module designed for hft-trading purposes, including modelling, analysis and simulation of high-frequency data.</p> <p><code>quantpylib.hft.alpha</code> is our simulator, modeller and backtester. You may simulate fills, portfolio wealth and do statistical modelling, such as fair price analysis.</p> <p><code>quantpylib.hft.feed</code> is our data feeder for public information and market data such as order book and trade feeds.</p> <p><code>quantpylib.hft.oms</code> is our order management system for positions, orders tracking and trade execution + management.</p> <p><code>quantpylib.hft.lob</code> is our internal limit-order book representation, and is designed to store orderbook states and buffers. There are utility functions to keep accurate representations of the internal state for both book snapshots and incremental updates. A host of other utility functions related to orderbook modelling can be found.</p> <p><code>quantpylib.hft.trades</code> is our internal trade buffer. There are utility functions to compute useful information and statistics from the data stored in the buffer.</p> <p><code>quantpylib.hft.statistics</code> is a statistics library for hft modelling - in addition it should work seamlessly with the data structures in the <code>quantpylib.hft.lob.LOB</code> and <code>quantpylib.hft.trades.Trades</code> object instances.</p>"},{"location":"hft/hft/#examples","title":"Examples","text":""},{"location":"hft/hft/#data-feed","title":"Data Feed","text":"<p>Obtaining data feeds are extremely simple with <code>quantpylib.hft.feed.Feed</code> objects. Simply - create a gateway object with the correct keys and pass them in</p> <p><pre><code>import os \nimport asyncio\n\nfrom pprint import pprint\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.gateway.master import Gateway \nfrom quantpylib.hft.feed import Feed\n\nkeys = {\n    \"binance\": {'key':'','secret':''},\n    \"hyperliquid\": {'key':'','secret':''},\n}\n\nasync def printer(data):\n    print(data)\n\nasync def printer_1(data):\n    print('1\\n',data.as_dict())\n\nasync def printer_2(data):\n    print('2\\n',data.as_dict())\n\nasync def main():\n    exchange,ticker = 'hyperliquid', 'BTC'\n    # exchange,ticker = 'binance', 'BTCUSDT'\n\n    gateway = Gateway(config_keys=keys)\n    await gateway.init_clients()\n    feed = Feed(gateway=gateway)\n    #code goes here\n    pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> To use binance, simply uncomment the line above. Proceeding... </p> <p>To get a order book feed, we can write: <pre><code>    l2_feed = await feed.add_l2_book_feed(exc=exchange,ticker=ticker,handler=printer_1)\n</code></pre> and we get <code>hyperliquid/perp/l2book/BTC_depth20</code>. Notice how we added a handler here - this is optional. We can add arbitrary number of coroutine handlers - when the feed is received, it will be broadcast to all handlers asynchronously. All the schema is standardized - there is no need to write exchange-dependent code. <pre><code>feed.add_handler_to_feed(l2_feed,printer_2)\n</code></pre> We will get (the same message) <pre><code>1\n {'ts': 1725903430442, \n 'bids': array([[5.65460e+04, 8.75000e-03],\n       [5.65430e+04, 9.33710e-01],\n       ...\n       [5.65220e+04, 1.98847e+00]]), \n 'asks': array([[5.65470e+04, 2.20767e+00],\n       [5.65480e+04, 1.67035e+00],\n       ...\n       [5.65710e+04, 2.64770e-01]])}\n2\n {'ts': 1725903430442, \n 'bids': array([[5.65460e+04, 8.75000e-03],\n       [5.65430e+04, 9.33710e-01],\n       ...\n       [5.65220e+04, 1.98847e+00]]), \n 'asks': array([[5.65470e+04, 2.20767e+00],\n       [5.65480e+04, 1.67035e+00],\n       ...\n       [5.65710e+04, 2.64770e-01]])}\n</code></pre> This message is constructed from order-book delta updates - it is a local order book state. We can also control the depth of the streams, speed of update and how much data buffer we keep. This data buffer is actually given to us as a <code>quantpylib.hft.lob.LOB</code> object -  we can retrieve it using the feed id. <pre><code>lob = feed.get_feed(l2_feed)\nprint(l2_feed)\nprint(lob) #`quantpylib.hft.lob.LOB` object\nprint(lob.get_mid(), lob.get_vamp(notional=30000)) #54884.5 54883.872068603436\nprint(lob.get_bids_buffer())\n</code></pre> We can get the time-series of bids, most recent mid-price, bba, vamp indicators and what not from this object. It is equally simple to get the trades feed, obtain a <code>quantpylib.hft.trades.Trades</code> object and get the running buffer, statistics and what not: <pre><code>trades_feed = await feed.add_trades_feed(exc=exchange,ticker=ticker,handler=printer)\ntrades = feed.get_feed(trades_feed)\nawait asyncio.sleep(5)\nprint(trades) #`quantpylib.hft.trades.Trades` object\nprint(trades.get_imbalance()) #0.8328041302230744\n</code></pre> The messages look like this: <pre><code>(1725904146989, 56497.0, 0.00037, -1)\n(1725904147170, 56498.0, 0.01171, 1)\n(1725904147773, 56498.0, 0.02284, 1)\n(1725904148396, 56497.0, 0.03539, -1)\n(1725904148401, 56498.0, 0.14221, 1)\n(1725904148401, 56498.0, 0.52174, 1)\n(1725904148401, 56498.0, 1.06198, 1)\n(1725904148401, 56498.0, 0.27407, 1)\n(1725904153032, 56492.0, 0.00887, 1)\n(1725904154037, 56490.0, 0.00022, 1)\n(1725904157831, 56476.0, 0.002, 1)\n(1725904158024, 56475.0, 0.00021, -1)\n(1725904159031, 56476.0, 0.00963, 1)\n</code></pre> It is simple to interpret: <code>time, price, size, dir</code>. When <code>dir = 1</code>, it means a taker buy initiated trade. </p> <p>Get all the running feed ids here: <pre><code>print(feed.get_feed_ids())\n</code></pre></p>"},{"location":"hft/hft/#data-archival","title":"Data Archival","text":"<p>In the previous section we have seen how easy it is to run tick data streams, add handlers and use <code>LOB</code> and <code>Trade</code> buffers to compute live statistics efficiently for high-frequency strategies. We would also like to have a data archival feature that allows us to store tick-data in a seamless manner to disk.</p> <p>Like, one-liner seamless. Let me demonstrate. We will do the same imports and setup: <pre><code>import os \nimport asyncio\n\nfrom pprint import pprint\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.hft.feed import Feed\nfrom quantpylib.gateway.master import Gateway \n\nkeys = {\n    \"binance\": {'key':'','secret':''},\n    \"hyperliquid\": {'key':'','secret':''},\n}\n\nexchanges = ['binance','hyperliquid']\n\nasync def main():\n    pass #&lt;&lt;&lt;\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> except this time we instantiate the feed with a flag <code>archiver=True</code> and list of tickers we want to archive: <pre><code>async def main():\n    l2_feeds = {\n        \"binance\": ['BTCUSDT','ETHUSDT'],\n        \"hyperliquid\": ['BTC','SOL']\n    }\n    trade_feeds = {\n        \"binance\": ['BTCUSDT','ETHUSDT'],\n        \"hyperliquid\": ['BTC','SOL']\n    }\n\n    gateway = Gateway(config_keys=keys)\n    await gateway.init_clients()\n    feed = Feed(gateway=gateway,archiver=True) #enable archiver\n</code></pre> then we add the magic line: <pre><code>    await feed.run_archive_scheduler()\n</code></pre> and the rest is as per normal (we skip the optional handler) and let the data stream forever. The <code>run_archive_scheduler</code> can be configured to flush data to disk and free up RAM quicker in large scale data archival with <code>splits</code> argument - by default <code>splits=1</code>. <pre><code>    for exchange in exchanges:\n        l2_feed_ids = await asyncio.gather(*[\n            feed.add_l2_book_feed(\n                exc=exchange,\n                ticker=ticker,\n                depth=20,\n            ) for ticker in l2_feeds[exchange]\n        ])\n        print(l2_feed_ids)\n        '''\n        ['binance/perp/l2book/BTCUSDT_depth20', 'binance/perp/l2book/ETHUSDT_depth20']\n        ['hyperliquid/perp/l2book/BTC_depth20', 'hyperliquid/perp/l2book/SOL_depth20']\n        '''\n        trade_feed_ids = await asyncio.gather(*[\n            feed.add_trades_feed(\n                exc=exchange,\n                ticker=ticker,\n            ) for ticker in trade_feeds[exchange]\n        ])\n        print(trade_feed_ids)\n        '''\n        ['binance/perp/trades/BTCUSDT', 'binance/perp/trades/ETHUSDT']\n        ['hyperliquid/perp/trades/BTC', 'hyperliquid/perp/trades/SOL']\n        '''\n    await asyncio.sleep(1e59)\n    await feed.cleanup()\n    await gateway.cleanup_clients()\n</code></pre></p> <p>And you will see that at the turn of every hour, the data for that hourly period is saved like this: <pre><code>./archives/{exchange}/{feed_cls}/{feed_type}/{yy}/{mm}/{ticker}{_metadata}_{ddhh}.parquet\n</code></pre> so from the <code>archives/</code> folder: <pre><code>./binance/perp/trades/2024/12/BTCUSDT_3014.parquet\n./binance/perp/trades/2024/12/ETHUSDT_3014.parquet\n./binance/perp/l2book/2024/12/BTCUSDT_depth20_3014.parquet\n./binance/perp/l2book/2024/12/ETHUSDT_depth20_3014.parquet\n...\n\n./hyperliquid/perp/trades/2024/12/BTC_3014.parquet\n./hyperliquid/perp/trades/2024/12/SOL_3014.parquet\n./hyperliquid/perp/l2book/2024/12/BTC_depth20_3014.parquet\n./hyperliquid/perp/l2book/2024/12/SOL_depth20_3014.parquet\n</code></pre> The archives can be loaded like this which loads sequential chronological, archived data from Dec-30th to Dec-31st of 2024: <pre><code>lob = Feed.load_lob_archives(\n    exc='binance',\n    ticker='BTCUSDT',\n    depth=20,\n    start='2024-12-30:00',\n    end='2024-12-31:23',\n)\n</code></pre> with format: <pre><code>[\n    {'ts': int,'b':np.ndarray,'a':np.ndarray}, {...}, ...\n]\n</code></pre> and similarly: <pre><code>trades = Feed.load_trade_archives(\n    exc='binance',\n    ticker='BTCUSDT',\n    start='2024-12-30:00',\n    end='2024-12-31:23',\n)\n</code></pre> to give <pre><code>[\n    [ts,price,size,dir],\n    [ts,price,size,dir],\n    ...\n]\n</code></pre> We can also decide to run our own scheduler, if we don't want to run the hourly-archiver. With <code>archiver=True</code> and no scheduler - <pre><code>feed = Feed(gateway=gateway,archiver=True)\n# await feed.run_archive_scheduler() \n</code></pre> we simply need to call  <pre><code>feed.flush_archives(path='./data_archives/',prefix='',postfix='')\n</code></pre> at any point in our code and the existing buffer is emptied into a parquet file with location: <pre><code>{path}/{exchange}/{feed_cls}/{feed_type}/{prefix}{ticker}{_metadata}{postfix}.parquet\n</code></pre> For example the above call would save existing buffer to <pre><code>.data_archives/hyperliquid/perp/trades/SOL.parquet\n.data_archives/hyperliquid/perp/trades/BTC.parquet\n.data_archives/hyperliquid/perp/l2book/BTC_depth20.parquet\n.data_archives/hyperliquid/perp/l2book/SOL_depth20.parquet\n\n#same for binance\n</code></pre> and this can be loaded: <pre><code>lobs = Feed.load_lob_archive(\n    exc='binance',\n    ticker='BTCUSDT',\n    depth=20,\n    path='./data_archives/',\n    # raw=True\n)\n</code></pre> or as raw parquet with columns (ts,bp,bs,ap,as) timestamp, bid price, bid size, ask price, ask size. Same goes with trades <pre><code>trades = Feed.load_trade_archive(\n    exc='binance',\n    ticker='BTCUSDT',\n    path='./data_archives/',\n    # raw=True\n)\n</code></pre> and raw parquet: <pre><code>                ts    price   size  dir\n0    1735569691383  92514.9  0.517    1\n1    1735569691480  92514.8  0.051   -1\n2    1735569691539  92514.9  0.051    1\n...\n</code></pre></p>"},{"location":"hft/hft/#oms","title":"OMS","text":"<p>It is easy to create a manager class - it is similar to the<code>quantpylib.hft.feed.Feed</code> objects. Simply - create a gateway object with the correct keys and pass them in.</p> <p>We will demonstrate with examples: <pre><code>import os \nimport asyncio \n\nfrom pprint import pprint\nfrom dotenv import load_dotenv \nload_dotenv()\n\nfrom quantpylib.hft.oms import OMS\nfrom quantpylib.gateway.master import Gateway\nimport quantpylib.standards.markets as markets\n\nconfig_keys = {\n    'binance': {\n        'key': '1234',\n        'secret': '1234',\n    },\n    'hyperliquid': {\n        'key': '1234',\n        'secret': '1234',\n    }\n}\ngateway = Gateway(config_keys)\n\nasync def main():\n    await gateway.init_clients()\n    oms = OMS(gateway)\n    await oms.init()\n    #code goes here... \n    ###\n    await oms.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>For all of our socket-based message handlers, we will use a generic printer to showcase results: <pre><code>async def printer(data):\n    if isinstance(data,dict) or isinstance(data,list):\n        pprint(data)\n    else:\n        try: pprint(data.as_dict())\n        except: pprint(data.as_list())\n</code></pre> Now, let us take a look at the functionalities. We can get trading specifications for the contracts on initiated exchanges: <pre><code>pprint(oms.contract_specs(exc='hyperliquid', ticker='BTC'))\n</code></pre> we get <pre><code>{'base_asset': 'BTC',\n'min_notional': Decimal('10.0'),\n'price_precision': 1,\n'quantity_precision': 5,\n'quote_asset': 'USDT'}\n</code></pre> Some useful statistics and utilities: <pre><code>pprint(oms.lagged_price(exc='hyperliquid', ticker='ETH')) #Decimal('2368.25')\npprint(oms.lot_precision(exc='hyperliquid', ticker='BTC')) #5\npprint(oms.price_precision(exc='hyperliquid', ticker='DOGE')) #6\npprint(oms.rounded_lots(exc='hyperliquid', ticker='BTC',amount=0.0023032)) #0.0023\npprint(oms.rounded_price(exc='hyperliquid', ticker='BTC',price=62000.1234)) #62000.1\npprint(oms.min_notional(exc='hyperliquid', ticker='BTC')) #Decimal('10.0')\npprint(oms.rand_cloid(exc='binance')) #'b486130e1b35986abc803bb79d2e675d'\npprint(oms.common_lot_precision(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #3\npprint(oms.common_price_precision(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #1\npprint(oms.common_min_notional(ex1='hyperliquid',ex2='binance',ticker1='BTC',ticker2='BTCUSDT')) #Decimal('100')\n</code></pre> We can get account informations for the included exchanges: <pre><code>pprint(await oms.get_balance(exc='hyperliquid'))\npprint(await oms.get_all_balances())\n</code></pre></p> <p>We would like to get some positions data. Note that when <code>oms.init()</code> is called, all orders and positions are automatically mirrored using underlying exchange socket subscriptions. We can make connection-less request by retrieving local state: <pre><code>pprint(oms.get_position(exc='hyperliquid', ticker='SOL')) #Decimal('1.0') (no requests made)\n</code></pre> or we can force the OMS to make a HTTP request: <pre><code>pprint(await oms.positions_get(exc='hyperliquid')) #HTTP requests made\npprint(await oms.positions_get_all())\n</code></pre> which gives us outputs <pre><code>{'SOL': {'amount': Decimal('1.0'),\n         'entry': Decimal('134.81'),\n         'ticker': 'SOL',\n         'unrealized_pnl': -0.3,\n         'value': Decimal('134.51')}}\n</code></pre> and <pre><code>{'binance': {'QUANTUSDT': {'amount': Decimal('826'),\n                         'entry': Decimal('0.1250522412206'),\n                         'ticker': 'QUANTUSDT',\n                         'unrealized_pnl': 1.03231002,\n                         'value': Decimal('104.32546026')}},\n 'hyperliquid': {'SOL': {'amount': Decimal('1.0'),\n                         'entry': Decimal('134.81'),\n                         'ticker': 'SOL',\n                         'unrealized_pnl': -0.3,\n                         'value': Decimal('134.51')}}}\n</code></pre> respectively. Only one of each schema level is shown - obviously if more positions were held, more entries would be seen.</p> <p>If we want to get the live positions object that tracks all positions, or register a handler on position change, we may do so. In particular, we can register handler <code>on_update</code> which passes the entire positions page (and/or) <code>on_delta</code> which passes the change in positions. Furthermore, the return value is the <code>Positions</code> object which is 'alive', so to speak, and keeps up to date with filled orders. <pre><code>live_positions = await oms.positions_mirror(exc='hyperliquid',on_update=printer,on_delta=printer)\nprint(live_positions)#&lt;quantpylib.standards.portfolio.Positions object at 0x12a98c8f0&gt;\n</code></pre></p> <p>We may do the same with orders: <pre><code>pprint(await oms.orders_get(exc='hyperliquid')) #HTTP\npprint(await oms.orders_get_all())\n</code></pre> for output: <pre><code>{1234: {\n        'amount': Decimal('1.0'),\n        'cloid': '',\n        'filled_sz': Decimal('0.0'),\n        'oid': '1234',\n        'ord_status': 'NEW',\n        'price': Decimal('100.0'),\n        'ticker': 'SOL',\n        'timestamp': 1726113126684\n        }\n}\n{'hyperliquid': {1234: {'amount': Decimal('1.0'),\n                        'cloid': '',\n                        'filled_sz': Decimal('0.0'),\n                        'oid': '1234',\n                        'ord_status': 'NEW',\n                        'price': Decimal('100.0'),\n                        'ticker': 'SOL',\n                        'timestamp': 1726113126684}}}\n'binance': .... {}\n</code></pre> Or...register handlers for orders page snapshot (and/or) just the changes. This also returns us a live <code>Orders</code> object: <pre><code>live_orders = await oms.orders_mirror(exc='hyperliquid',on_update=printer,on_delta=printer)\nprint(live_orders)#&lt;quantpylib.standards.portfolio.Orders object at 0x13252f050&gt;\n</code></pre></p> <p>Now that we have registered some handlers for orders, and what not - let us see what the messages look like. We can make a limit order through the OMS - the parameters are the same as in <code>Gateway</code> usage: <pre><code>cloid = oms.rand_cloid(exc='hyperliquid')\nawait oms.limit_order(exc='hyperliquid',ticker='SOL',amount=1,price=129.56,cloid=cloid)\nawait oms.limit_order(exc='binance',ticker='SOLUSDT',price_match=markets.PRICE_MATCH_QUEUE_1,amount=1)\n</code></pre> Recall that our handlers are registered for <code>hyperliquid</code>, so let's see what gets printed: The <code>on_delta</code> handler receives two messages: <pre><code>{'amount': Decimal('1'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154778980,\n 'tp': None}\n{'amount': Decimal('1.0'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '1234',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154781307,\n 'tp': None}\n</code></pre> The first is order-creation: a request has been sent to the exchange, but not yet acknowledged. Only the local trading agent is aware, but the order is possibly unsuccessful; hence <code>PENDING</code> status. This is followed by a <code>NEW</code> order which means the order was acknowledged successful by the exchange. The <code>on_update</code> handler sends this order, along with all the other open orders - which we print as a list: <pre><code>[{'amount': Decimal('1.0'),\n  ...\n  'timestamp': 1726123317580,\n  'tp': None},\n {'amount': Decimal('1.0'),\n  'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n  'exc': 'hyperliquid',\n  'filled_sz': Decimal('0.0'),\n  'last_fill_sz': Decimal('0.0'),\n  'oid': '1234',\n  'ord_status': 'NEW',\n  'ord_type': None,\n  'price': Decimal('129.56'),\n  'price_match': None,\n  'reduce_only': None,\n  'sl': None,\n  'ticker': 'SOL',\n  'tif': None,\n  'timestamp': 1726154781307,\n  'tp': None}]\n</code></pre> Next we submit an order cancel: <pre><code>await oms.cancel_order(exc='hyperliquid',ticker='SOL',cloid=cloid) #or use oid\n</code></pre> and this is acknowledged <code>on_delta</code>: <pre><code>{'amount': Decimal('1.0'),\n 'cloid': '0x272e45bf06706c3259f41079a1d48d2a',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '1234',\n 'ord_status': 'CANCELLED',\n 'ord_type': None,\n 'price': Decimal('129.56'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154781307,\n 'tp': None}\n</code></pre> and the <code>on_update</code> prints the new list (not shown), this time without the cancelled order - since it is not on the orders page anymore (it is no longer open).</p> <p>We can of course, do a market-order: <pre><code>await oms.market_order(exc='hyperliquid',ticker='SOL',amount=-1)\n</code></pre> Which also gives a <code>on_delta</code>, <code>PENDING</code> message: <pre><code>{'amount': Decimal('-1'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154778980,\n 'tp': None}\n</code></pre> This is filled immediately in two blocks, and the <code>positions</code>'s <code>on_delta</code> message is called with each fill <pre><code>{'amount': Decimal('0.19'),\n 'delta': Decimal('-0.81'),\n 'entry': Decimal('134.81'),\n 'ticker': 'SOL'}\n{'amount': Decimal('0.00'),\n 'delta': Decimal('-0.19'),\n 'entry': Decimal('134.79'),\n 'ticker': 'SOL'}\n</code></pre> where <code>amount</code> is the new signed position held after <code>delta</code> is filled - at the end of this market order our <code>SOL</code> position is closed fully, so our <code>positions</code>'s <code>on_update</code> receives the positions page (no open positions): <pre><code>{}\n</code></pre> on the other hand the <code>PENDING</code> order created is acknowledged by exchange to <code>NEW</code> and then immediately <code>FILLED</code> on creation with <code>on_delta</code> triggers: <pre><code>{'amount': Decimal('-1.0'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': 'yomama',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('127.69'), #hyperliquid's market order is an aggressive limit order\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154797325,\n 'tp': None}\n{'amount': Decimal('-1.0'),\n 'cloid': '0xa70c993f525b2e8106ffd60fd19af35e',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('1.0'),\n 'last_fill_sz': Decimal('1.0'),\n 'oid': 'yomama',\n 'ord_status': 'FILLED',\n 'ord_type': None,\n 'price': Decimal('127.69'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726154797325,\n 'tp': None}\n</code></pre> and <code>on_update</code> triggers: <pre><code>[{'amount': Decimal('1.0'),\n  ...\n  'timestamp': 1726123317580,\n  'tp': None},]\n</code></pre> We will demonstrate a complex order supported by the OMS - let's call it <code>hedge_order</code>. It is quite often that we want one order to trigger another in a multi-leg trade. For instance, a triangular arbitrage, cross-exchange market making, funding arbitrage and l/s arbitrage all often use similar fixtures. A hedge order allows us to submit a maker-order, and the matching taker order is triggered with size matching that of the filled amount on the maker-leg. When lot size rounding doesn't allow for complete hedging, the remaining balance is stored and flushed with the next best available order. Let's see how we can make use of this. To get information from both exchanges, we wil add the binance handlers: <pre><code>await oms.positions_mirror(exc='binance',on_update=printer,on_delta=printer)\nawait oms.orders_mirror(exc='binance',on_update=printer,on_delta=printer)\nawait asyncio.sleep(5)\n</code></pre> and then make a hedge order <pre><code>await oms.hedge_order(\n    maker_order = {\n        \"exc\": \"binance\",\n        \"ticker\": \"SOLUSDT\",\n        \"amount\": -3,\n        \"price_match\": markets.PRICE_MATCH_QUEUE_5\n    },\n    hedge_order = {\n        \"exc\": \"hyperliquid\",\n        \"ticker\": \"SOL\",\n    }\n)\n</code></pre> Note that an amount is not specified for the hedge-order - since we are listening for the filled sizes on binance. First - a pending order is created on binance, then acknowledged <pre><code>&gt;&gt; orders delta:\n{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': 'QUEUE_5',\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': None,\n 'timestamp': 1726199235551,\n 'tp': None}\n{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': '68254554715',\n 'ord_status': 'NEW',\n 'ord_type': 'LIMIT',\n 'price': Decimal('134.5460'),\n 'price_match': 'QUEUE_5',\n 'reduce_only': False,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': 'GTC',\n 'timestamp': 1726199241966,\n 'tp': None}\n&gt;&gt; orders snapshot:\n[{'amount': Decimal('-3'),\n  'cloid': 'c484811d8ce145004eeb26c917013c29',\n  'exc': 'binance',\n  'filled_sz': Decimal('0'),\n  'last_fill_sz': Decimal('0'),\n  'oid': '68254554715',\n  'ord_status': 'NEW',\n  'ord_type': 'LIMIT',\n  'price': Decimal('134.5460'),\n  'price_match': 'QUEUE_5',\n  'reduce_only': False,\n  'sl': None,\n  'ticker': 'SOLUSDT',\n  'tif': 'GTC',\n  'timestamp': 1726199241966,\n  'tp': None}]\n</code></pre> It is later filled: <pre><code>&gt;&gt; positions delta:\n{'amount': Decimal('-3'),\n 'delta': Decimal('-3'),\n 'entry': Decimal('134.546'),\n 'ticker': 'SOLUSDT'}\n&gt;&gt; positions snapshot:\n{'SOLUSDT': {'amount': Decimal('-3'),\n            'entry': Decimal('134.546'),\n            'ticker': 'SOLUSDT'}}\n</code></pre> Which also shows up in the orders: <pre><code>{'amount': Decimal('-3'),\n 'cloid': 'c484811d8ce145004eeb26c917013c29',\n 'exc': 'binance',\n 'filled_sz': Decimal('3'),\n 'last_fill_sz': Decimal('3'),\n 'oid': '68254554715',\n 'ord_status': 'FILLED',\n 'ord_type': 'LIMIT',\n 'price': Decimal('134.5460'),\n 'price_match': 'QUEUE_5',\n 'reduce_only': False,\n 'sl': None,\n 'ticker': 'SOLUSDT',\n 'tif': 'GTC',\n 'timestamp': 1726199256915,\n 'tp': None}\n</code></pre> This triggers a taker order on hyperliquid - which goes from <code>PENDING</code> to <code>NEW</code> to <code>FILLED</code> <pre><code>{'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0'),\n 'last_fill_sz': Decimal('0'),\n 'oid': None,\n 'ord_status': 'PENDING',\n 'ord_type': None,\n 'price': None,\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199235551,\n 'tp': None}\n {'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('0.0'),\n 'last_fill_sz': Decimal('0.0'),\n 'oid': '37771235449',\n 'ord_status': 'NEW',\n 'ord_type': None,\n 'price': Decimal('141.36'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199257706,\n 'tp': None}\n{'amount': Decimal('3.0'),\n 'cloid': '0xb09f965b3b58613bce2b12f15a94ad47',\n 'exc': 'hyperliquid',\n 'filled_sz': Decimal('3.0'),\n 'last_fill_sz': Decimal('3.0'),\n 'oid': '37771235449',\n 'ord_status': 'FILLED',\n 'ord_type': None,\n 'price': Decimal('141.36'),\n 'price_match': None,\n 'reduce_only': None,\n 'sl': None,\n 'ticker': 'SOL',\n 'tif': None,\n 'timestamp': 1726199257706,\n 'tp': None}\n</code></pre> We also get the positions delta and snapshots on hyperliquid: <pre><code>{'amount': Decimal('3.0'),\n 'delta': Decimal('3.0'),\n 'entry': Decimal('134.65'),\n 'ticker': 'SOL'}\n\n{'SOL': {'amount': Decimal('3.0'), 'entry': Decimal('134.65'), 'ticker': 'SOL'}}\n</code></pre> Note that the orders are sent even if it is a partial-fill with matching size - we don't have to wait for the entire maker order to be complete.</p>"},{"location":"hft/hft/#market-making","title":"Market-Making","text":"<p>Please refer to the market-making tutorial using the <code>Feed</code> and <code>OMS</code> object to write cross-exchange, cross environment (live, backtest and modelling) code for high-frequency data.</p>"},{"location":"hft/hft/#limit-order-book","title":"Limit-Order Book","text":"<p>You may want to use the orderbook with your own data stream. Here is an example of how you can do it (speudo-code) <pre><code>from quantpylib.hft.lob import LOB \nob = LOB(depth=depth,buffer_size=buffer_size)   \n\nasync def on_stream(msg):\n    ob.update(msg['ts'],msg['b'],msg['a'],is_snapshot=True / False)\n</code></pre></p> <p>A limit order book object is only interesting with data already in it. Although we can create a <code>LOB</code> object directly, for demonstration - we are going to obtain it from a market data stream. Fortunately, our <code>quantpylib.gateway.executor</code> library has a <code>l2_book_mirror</code> method that returns a live orderbook object.</p> <p>We will get data from hyperliquid through the gateway object: <pre><code>import asyncio\n\nfrom quantpylib.gateway.master import Gateway\n\ngateway = Gateway(config_keys={\"hyperliquid\":{}})\n\nasync def ob_handler(ob):\n    print(ob.get_mid(), ob.get_spread())\n    return\n\nasync def main():\n\n    await gateway.init_clients()\n    ob_model = await gateway.executor.l2_book_mirror(\n        ticker=\"SOL\",\n        depth=20,\n        buffer_size=200,\n        as_dict=False,\n        on_update=ob_handler,\n        exc='hyperliquid'\n    )\n\n    await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> This maps to the <code>l2_book_mirror</code> method in <code>quantpylib.wrappers.hyperliquid</code> wrapper, and <code>as_dict=False</code> specifices we want a <code>quantpylib.hft.lob.LOB</code> object.</p> <p>We can now use the utility functions of the orderbook class. While we are sleeping, the <code>ob_handler</code> prints out... <pre><code>182.04500000000002 0.010000000000019327\n182.04500000000002 0.010000000000019327\n182.04500000000002 0.010000000000019327\n182.05 0.020000000000010232\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n182.075 0.010000000000019327\n</code></pre> and so on. We do not have to call the <code>LOB.update</code> method here, since the mirror method takes care of the state of the orderbook on data stream. Let's take a look at some of the utility functions after sleeping: <pre><code>    print(ob_model.get_mid(),ob_model.get_vamp(notional=3000))\n    print(ob_model.get_vol(exp=True))\n    print(ob_model.buffer_len())\n</code></pre> and we get  <pre><code>182.085 182.06296258333333\n0.018219811123247037\n104\n</code></pre> We get different figures for mid-price, fair-price estimator using quote volume imbalance, volatility and length of running buffer. Of course, these methods have additional parameters, such as the sample size used to compute volatility - we refer to documentation.</p>"},{"location":"hft/hft/#trades","title":"Trades","text":"<p>Like the <code>LOB</code> object, <code>Trades</code> is a trade buffer stream. Using the data streamed in, we may get useful information such as trade imbalance.</p> <p>Filling in the trade buffer is extremely easy, let's get the hyperliquid BTC trade stream: <pre><code>import asyncio\n\nfrom quantpylib.hft.trades import Trades\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def main():\n    ticker = \"BTC\"\n\n    hpl = Hyperliquid()\n    await hpl.init_client()\n    trades = Trades(buffer_size=1_000_000)\n    async def trade_handler(trade):\n        #trade is (time_ms, price, size, dir)\n        #&gt;&gt;&gt; (1722177301662, 67749.0, 0.0003, -1)\n        trades.append(trade=trade) \n\n    await hpl.trades_subscribe(ticker=ticker,handler=trade_handler)\n    await asyncio.sleep(1000)\n</code></pre> That's pretty much it - from here the buffer is being populated, and we can  compute figures such as trade imbalance and so on.</p>"},{"location":"hft/hft/#statistics","title":"Statistics","text":"<p>This is our statistical library for hft modelling. It is designed to work seamlessly with the data structures from our internal state representations, such as the orderbook <code>LOB</code> and trades <code>Trades</code>, but will work just as well with external data.</p> <p>For instance, we may be interested in computing orderbook liquidity - to do this we fit an exponential decay model for the hit and -lifted amounts against the distance to mid price. This figure is directly related to the Poisson intensity that is often taken as a model for trade arrivals.</p> <p>Let's stream both the l2-book data and the trades occuring: <pre><code>import asyncio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom quantpylib.hft.lob import LOB\nfrom quantpylib.hft.trades import Trades\nfrom quantpylib.hft.stats import intensity\n\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def main():\n    ticker = \"BTC\"\n\n    hpl = Hyperliquid()\n    await hpl.init_client()\n\n    ob = await hpl.l2_book_mirror(\n        ticker=ticker,\n        depth=20,\n        buffer_size=1_000_000,\n        as_dict=False\n    )\n    trades = Trades(buffer_size=1_000_000)\n    async def trade_handler(trade):\n        trades.append(trade=trade)\n\n    await hpl.trades_subscribe(ticker=ticker,handler=trade_handler)\n    await asyncio.sleep(60 * 20)\n\n    #code goes here...\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> After twenty minutes, we get some two thousand data points and four hundred trades. Let's fit the exponential function using <code>quantpylib.hft.stats.intensity</code>, and make some plots: <pre><code>    print(ob.buffer_len()) #2051\n    print(trades.buffer_len()) #408\n\n    params = intensity(\n        lob_timestamps=ob.get_ts_buffer(),\n        lob_mids=ob.get_mids_buffer(),\n        trades=trades.get_buffer(),\n    )   \n\n    alpha = params.get(\"alpha\")\n    kappa = params.get(\"kappa\")\n    levels = params.get(\"levels\")\n    agg_amounts = params.get(\"amounts\")\n    fitted_values = alpha * np.exp(-kappa * levels)\n\n    # Plot the actual and fitted\n    plt.figure(figsize=(10, 6))\n    plt.plot(levels, agg_amounts, 'o', label='Aggregated Amounts', color='red')\n    plt.plot(levels, fitted_values, '-', label=f'Fitted Model: $A(d) = {alpha:.2f} e^{{-{kappa:.2f} d}}$', color='blue')\n    plt.xlabel('Distance from Mid-Price (d)')\n    plt.ylabel('Aggregated Trade Amount (A(d))')\n    plt.title('Exponential Decay Model Fit to Aggregated Trade Amounts')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n</code></pre> Obviously, the sample size is rather small, but we will carry on for the sake of demonstration. Here is the decay function:</p> <p></p> <p>Values such as kappa are often used as measures of orderbook liquidity. Higher values of kappa indicate strong decay, hence greater trading near the mid-price. Lower values indicate weak decay - market order sizes often wipe out a few levels in the orderbook and have strong  price impact. See Hummingbot implementation of computing trade intensity. In stoikov-avellaneda market making formula, kappa appears as term in optimal spread; see Hummingbot avellaneda_market_making.pyx: <pre><code>self._optimal_spread = self.gamma * vol * time_left_fraction\nself._optimal_spread += 2 * Decimal(1 + self.gamma / self._kappa).ln() / self.gamma\n</code></pre> Optimal spread has an additive factor of log(1 + c/kappa), where smaller values of kappa encourages wider maker orders (although I am pretty sure this should be dollar-normalized first).</p>"},{"location":"hft/hft/#hftlob","title":"hft.lob","text":""},{"location":"hft/hft/#hfttrades","title":"hft.trades","text":""},{"location":"hft/hft/#hftfeatures","title":"hft.features","text":""},{"location":"hft/hft/#hftstats","title":"hft.stats","text":""},{"location":"hft/lob/","title":"quantpylib.hft.lob","text":""},{"location":"hft/lob/#quantpylib.hft.lob.LOB","title":"<code>LOB</code>","text":""},{"location":"hft/lob/#quantpylib.hft.lob.LOB.__init__","title":"<code>__init__(timestamp=-1, bids=None, asks=None, depth=100, buffer_size=100, apply_shadow_depth=False)</code>","text":"<p>A class representing a Limit Order Book (LOB) for financial trading.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The initial timestamp in milliseconds. Defaults to current time.</p> <code>-1</code> <code>bids</code> <code>ndarray</code> <p>Initial bid array. Defaults to None.</p> <code>None</code> <code>asks</code> <code>ndarray</code> <p>Initial ask array. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The maximum depth of the order book. Defaults to 100.</p> <code>100</code> <code>buffer_size</code> <code>int</code> <p>The size of the buffers for storing historical data. Defaults to 100.</p> <code>100</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.as_dict","title":"<code>as_dict()</code>","text":"<p>Represent the current state of the order book as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The current timestamp, bids, and asks.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.as_tuple","title":"<code>as_tuple()</code>","text":"<p>Represent the current state of the order book as a tuple.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>The current timestamp, bids, and asks.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.buffer_as_list","title":"<code>buffer_as_list()</code>","text":"<p>Obtain the historical data buffers as a list of dictionaries.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.buffer_len","title":"<code>buffer_len()</code>","text":"<p>Get the length of the buffers.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the buffers.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.clear_buffer","title":"<code>clear_buffer()</code>","text":"<p>Clear all historical data buffers.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_ask","title":"<code>get_ask()</code>","text":"<p>Get the best ask price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_ask_sz","title":"<code>get_ask_sz()</code>","text":"<p>Get the best ask size.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_asks","title":"<code>get_asks()</code>","text":"<p>Get the current ask array.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_asks_buffer","title":"<code>get_asks_buffer()</code>","text":"<p>Get the buffer of three-dimensional (time,price,size) ask arrays.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of ask arrays in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_asks_sample","title":"<code>get_asks_sample(n=None, tau=None, T=None)</code>","text":"<p>Get the most recent sample of ask arrays.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to take.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bid","title":"<code>get_bid()</code>","text":"<p>Get the best bid price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bid_sz","title":"<code>get_bid_sz()</code>","text":"<p>Get the best bid size.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bids","title":"<code>get_bids()</code>","text":"<p>Get the current bid array.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bids_buffer","title":"<code>get_bids_buffer()</code>","text":"<p>Get the buffer of three-dimensional (time,price,size) bid arrays.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of bid arrays in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_bids_sample","title":"<code>get_bids_sample(n=None, tau=None, T=None)</code>","text":"<p>Get the most recent sample of bid arrays.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to take.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_cumulative_size","title":"<code>get_cumulative_size(dir, price)</code>","text":"<p>Returns the size and volume that can be executed given a limit price instantaneously.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>int</code> <p>The direction of the trade. 1 for buy, -1 for sell.</p> required <code>price</code> <code>float</code> <p>The limit price.</p> required"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_impact_price","title":"<code>get_impact_price(dir, notional)</code>","text":"<p>Calculate the volume-weighted price for a given notional amount.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>int</code> <p>The direction of the trade. 1 for buy, -1 for sell.</p> required <code>notional</code> <code>float</code> <p>The notional amount.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The volume-weighted price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_impact_spread","title":"<code>get_impact_spread(notional, x=False)</code>","text":"<p>Get the spread between impact prices from top of book.</p> <p>Parameters:</p> Name Type Description Default <code>notional</code> <code>float</code> <p>The notional amount for the calculation.</p> required <code>x</code> <code>bool</code> <p>Whether to normalize by price.</p> <code>False</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_impact_worst","title":"<code>get_impact_worst(dir, sz)</code>","text":"<p>Returns the worst limit price for a given market order size.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>int</code> <p>The direction of the trade. 1 for buy, -1 for sell.</p> required <code>sz</code> <code>float</code> <p>The size of the market order.</p> required"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_mid","title":"<code>get_mid()</code>","text":"<p>Get the mid price of the current order book.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The mid price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_mids_buffer","title":"<code>get_mids_buffer()</code>","text":"<p>Get the buffer of one-dimensional mid prices.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of mid prices in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_mids_sample","title":"<code>get_mids_sample(n=None, tau=None, T=None)</code>","text":"<p>Get the most recent sample of mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to take.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_spread","title":"<code>get_spread(x=False)</code>","text":"<p>Get the spread at top of book.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>bool</code> <p>Whether to normalize by price.</p> <code>False</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_ts_buffer","title":"<code>get_ts_buffer()</code>","text":"<p>Get the buffer of one-dimensional timestamps.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of timestamps in the buffer.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_vamp","title":"<code>get_vamp(notional=0, bid_notional=0, ask_notional=0)</code>","text":"<p>Calculate the volume-adjusted mid price.</p> <p>Parameters:</p> Name Type Description Default <code>notional</code> <code>float</code> <p>The notional amount for the calculation.</p> <code>0</code> <code>bid_notional</code> <code>float</code> <p>The notional amount for the bid side. Defaults to <code>notional</code>.</p> <code>0</code> <code>ask_notional</code> <code>float</code> <p>The notional amount for the ask side. Defaults to <code>notional</code>.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The volume-adjusted mid price.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.get_vol","title":"<code>get_vol(n=None, tau=None, T=None, x=False, exp=False)</code>","text":"<p>Get mid-price volatility. Excludes zero differences.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to use.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code> <code>x</code> <code>bool</code> <p>Whether to normalize by price.</p> <code>False</code> <code>exp</code> <code>bool</code> <p>Whether to use exponential weighting. Defaults to False.</p> <code>False</code>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.sample_len","title":"<code>sample_len(n=None, tau=None, T=None)</code>","text":"<p>Get the length of the most recent samples to take.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to take.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the samples.</p>"},{"location":"hft/lob/#quantpylib.hft.lob.LOB.update","title":"<code>update(timestamp, bids, asks, is_snapshot, sort_levels=False)</code>","text":"<p>Update the order book with new bid and ask data.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The current timestamp in milliseconds.</p> required <code>bids</code> <code>ndarray</code> <p>The new bid array.</p> required <code>asks</code> <code>ndarray</code> <p>The new ask array.</p> required <code>is_snapshot</code> <code>bool</code> <p>Whether the update is a snapshot (true) or an incremental update (false).</p> required"},{"location":"hft/lob/#quantpylib.hft.lob.a_in_b","title":"<code>a_in_b(a, b)</code>","text":"<p>Check if elements of array <code>a</code> are in array <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The array of elements to check.</p> required <code>b</code> <code>ndarray</code> <p>The array to check against.</p> required <p>Returns:</p> Type Description <p>np.ndarray: A boolean array indicating if elements of <code>a</code> are in <code>b</code>.</p>"},{"location":"hft/mocks/","title":"quantpylib.hft.mocks","text":"<p>The mocks module contains classes that replicate the <code>quantpylib.hft.feed.Feed</code> and <code>quantpylib.hft.oms.OMS</code> trading agents, as well as the <code>Replayer</code> class that drives these mock classes. The <code>Replayer</code> has auxiliary statistical and graphical utility functions.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Latencies","title":"<code>Latencies</code>","text":"<p>Latency types/constants.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockFeed","title":"<code>MockFeed</code>","text":"<p>               Bases: <code>Feed</code></p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockFeed.add_l2_book_feed","title":"<code>add_l2_book_feed(exc, ticker, handler=None, depth=20, buffer=100, **kwargs)</code>  <code>async</code>","text":"<p>Add a level 2 book feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The depth of the order book. Defaults to 20.</p> <code>20</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockFeed.add_trades_feed","title":"<code>add_trades_feed(exc, ticker, handler=None, buffer=100, **kwargs)</code>  <code>async</code>","text":"<p>Add a trades feed.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>handler</code> <code>coroutine</code> <p>The handler to add. Defaults to None.</p> <code>None</code> <code>buffer</code> <code>int</code> <p>The buffer size. Defaults to 100.</p> <code>100</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockOMS","title":"<code>MockOMS</code>","text":"<p>               Bases: <code>OMS</code></p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockOMS.add_clock_callback","title":"<code>add_clock_callback(callback, name='CLOCK', interval_ms=500)</code>  <code>async</code>","text":"<p>Add a callback to the event queue that is triggered every interval_ms. Can be used for clock-based trading agents.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>coroutine</code> <p>The callback to trigger.</p> required <code>name</code> <code>str</code> <p>The name of the callback. Defaults to 'CLOCK'.</p> <code>'CLOCK'</code> <code>interval_ms</code> <code>int</code> <p>The interval in milliseconds. Defaults to 500.</p> <code>500</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockOMS.get_positions_value","title":"<code>get_positions_value(exc)</code>","text":"<p>Get the net signed value of all open positions for an exchange at replay time.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.MockOMS.lagged_price","title":"<code>lagged_price(exc, ticker)</code>","text":"<p>Get the price for a given exchange and ticker at current replay time.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/mocks/#quantpylib.hft.mocks.ReplayEvents","title":"<code>ReplayEvents</code>","text":"<p>Replay event types/constants.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer","title":"<code>Replayer</code>","text":""},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.__init__","title":"<code>__init__(l2_data, trade_data, maker_fees=0.0001, taker_fees=0.0003, gateway=None, exchanges=None, latencies={Latencies.REQ_PUBLIC: 100, Latencies.REQ_PRIVATE: 50, Latencies.ACK_PUBLIC: 100, Latencies.ACK_PRIVATE: 50, Latencies.FEED_PUBLIC: 100, Latencies.FEED_PRIVATE: 50}, exchange_fees=None, exchange_latencies=None, stamp_cycle=1000)</code>","text":"<p>A replayer for backtesting. This class replays orderboook depth data, trade data  and provides a mock feed and oms classes to replay agent-based communications between  the trading logic and the exchange. Simulates data feed, order submissions, matching,  latencies and more.</p> <p>Parameters:</p> Name Type Description Default <code>l2_data</code> <code>dict</code> <p>Level 2 data mapping <code>{exc:{ticker:[{ts,b,a}]}}</code>.</p> required <code>trade_data</code> <code>dict</code> <p>Trade data mapping <code>{exc:{ticker:[(ts,price,sz,dir)]}}</code>.</p> required <code>maker_fees</code> <code>float</code> <p>The maker fees. Defaults to 0.0001.</p> <code>0.0001</code> <code>taker_fees</code> <code>float</code> <p>The taker fees. Defaults to 0.0003.</p> <code>0.0003</code> <code>gateway</code> <code>`quantpylib.gateway.master.Gateway`</code> <p>The gateway used to instantiate contract rules. Defaults to None.</p> <code>None</code> <code>exchanges</code> <code>list</code> <p>The list of exchanges. Defaults to keys inside the <code>l2_data</code> dict.</p> <code>None</code> <code>latencies</code> <code>dict</code> <p>Latency mapping in ms for each message channel. Defaults to <code>50</code> for all private and <code>100</code> for public communications. Keys are <code>Latencies.REQ_PUBLIC</code>, <code>Latencies.REQ_PRIVATE</code>, <code>Latencies.ACK_PUBLIC</code>, <code>Latencies.ACK_PRIVATE</code>, <code>Latencies.FEED_PUBLIC</code>, <code>Latencies.FEED_PRIVATE</code>. </p> <code>{REQ_PUBLIC: 100, REQ_PRIVATE: 50, ACK_PUBLIC: 100, ACK_PRIVATE: 50, FEED_PUBLIC: 100, FEED_PRIVATE: 50}</code> <code>exchange_fees</code> <code>dict</code> <p>The exchange fees specify fees <code>dict</code> by exchange. Defaults to <code>maker_fees</code> and <code>taker_fees</code> for each exchange.</p> <code>None</code> <code>exchange_latencies</code> <code>dict</code> <p>The exchange latencies specify latencies <code>dict</code> by exchange. Defaults to <code>latencies</code> for each exchange.</p> <code>None</code> <code>stamp_cycle</code> <code>int</code> <p>The interval in ms used for stamping backtest statistics such as portfolio equity, inventory. Defaults to 1000.</p> <code>1000</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.add_callback","title":"<code>add_callback(event_id, callback)</code>","text":"<p>Add a callback to an event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>str</code> <p>The event id.</p> required <code>callback</code> <code>coroutine</code> <p>The callback for events belonging to <code>event_id</code>.</p> required"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.add_events","title":"<code>add_events(event_id, timestamps, events, exc, latency=Latencies.NULL)</code>","text":"<p>Add events to the replayer queue.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>str</code> <p>The event id.</p> required <code>timestamps</code> <code>list</code> <p>The timestamps of event occurence.</p> required <code>events</code> <code>list</code> <p>The events. Note <code>len(timestamps) == len(events)</code>.</p> required <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>latency</code> <code>str</code> <p>The latency for event arrival added to the timestamps of event occurence.  Defaults to Latencies.NULL, zero latency.</p> <code>NULL</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.add_to_queue","title":"<code>add_to_queue(event_id, timestamp, msg, exc, latency=Latencies.NULL)</code>","text":"<p>Add an event to the replayer queue.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>str</code> <p>The event id.</p> required <code>timestamp</code> <code>int</code> <p>The timestamp of event occurence.</p> required <code>msg</code> <code>Any</code> <p>The message/event.</p> required <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>latency</code> <code>str</code> <p>The latency for event arrival added to the timestamps of event occurence.  Defaults to Latencies.NULL, zero latency.</p> <code>NULL</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.augment_forward_prices","title":"<code>augment_forward_prices(df, forward_intervals=[0, 1, 10, 30, 60, 120, 300])</code>","text":"<p>Augment the dataframe with forward prices for each interval. <code>df</code> should contain columns  <code>ts,exc,ticker</code>. to match forward prices.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.declare","title":"<code>declare(key, value, exc=None, ticker=None, group=None)</code>","text":"<p>Declare a value for logging purposes. Can later be used for tick-data modelling and analysis.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key.</p> required <code>value</code> <code>Any</code> <p>The value.</p> required <code>exc</code> <code>str</code> <p>The exchange. Defaults to None.</p> <code>None</code> <code>ticker</code> <code>str</code> <p>The ticker. Defaults to None.</p> <code>None</code> <code>group</code> <code>str</code> <p>The group this key belongs to. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_actions","title":"<code>df_actions(exc=None, ticker=None)</code>","text":"<p>Get a dataframe of all order fills, with columns <code>ts,price,size,dir,is_maker,exc,ticker</code>.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_counterparty_pnl","title":"<code>df_counterparty_pnl(exc_tickers, plot=True, show=True, save=None)</code>","text":"<p>Get the normalized counterparty pnl comparison for mapping between exchange and list of tickers. This simulates being the maker to all market orders that are traded on the exchange's market with zero fees.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_declarations","title":"<code>df_declarations(key=None, exc=None, ticker=None, group=None)</code>","text":"<p>Retrieve the declarations logs as a dataframe.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_exchange","title":"<code>df_exchange(exc, plot=True, show=True, save=None)</code>","text":"<p>Get the equity and inventory breakdown for an exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>plot</code> <code>bool</code> <p>Plot the pnl and inventory breakdown. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_fairprices","title":"<code>df_fairprices(group, key=None, exc=None, ticker=None, forward_intervals=[0, 1, 10, 30, 60, 120, 300], plot=False, show=True, save=None)</code>","text":"<p>If a group declared in <code>Replayer.declare</code> is a fairprice estimator, this method performs a fairprice analysis and metrics comparison  by common objectives such as MSE, MAD, etc by comparing the declared fairprice with the actual price at different forward intervals.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>The group.</p> required <code>key</code> <code>str</code> <p>The key. Defaults to None.</p> <code>None</code> <code>exc</code> <code>str</code> <p>The exchange. Defaults to None.</p> <code>None</code> <code>ticker</code> <code>str</code> <p>The ticker. Defaults to None.</p> <code>None</code> <code>forward_intervals</code> <code>list</code> <p>The forward intervals in seconds. Defaults to <code>[0,1,10,30,60,120,300]</code>.</p> <code>[0, 1, 10, 30, 60, 120, 300]</code> <code>plot</code> <code>bool</code> <p>Plot the results. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_fills","title":"<code>df_fills(ticker, exc, plot=True, ax=None, show=True, save=None)</code>","text":"<p>Get fills for a ticker and exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>plot</code> <code>bool</code> <p>Plot the fills. Defaults to True.</p> <code>True</code> <code>ax</code> <code>Axes</code> <p>The axes to plot on. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_markouts","title":"<code>df_markouts(ticker=None, exc=None, plot=True, show=True, save=None, intervals=list(np.linspace(1, 151, 31) * 1000))</code>","text":"<p>Get markouts for a ticker and exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker. Defaults to None. If None, all tickers are aggregated.</p> <code>None</code> <code>exc</code> <code>str</code> <p>The exchange. Defaults to None. If None, all exchanges are aggregated.</p> <code>None</code> <code>plot</code> <code>bool</code> <p>Plot the markouts. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code> <code>intervals</code> <code>list</code> <p>The intervals in ms. Defaults to <code>list(np.linspace(1, 151, 31) * 1000)</code>.</p> <code>list(linspace(1, 151, 31) * 1000)</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_portfolio","title":"<code>df_portfolio(plot=True, show=True, save=None)</code>","text":"<p>Get the portfolio pnl breakdown by exchange.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>Plot the portfolio pnl breakdown. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.df_prices","title":"<code>df_prices(ticker, exc, plot=True, ax=None, with_fill=True, with_inventory=None, key=None, group=None, share_index=False, show=True, save=None)</code>","text":"<p>Get tick prices for a ticker and exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>plot</code> <code>bool</code> <p>Plot the prices. Defaults to True.</p> <code>True</code> <code>ax</code> <code>Axes</code> <p>The axes to plot on. Defaults to None.</p> <code>None</code> <code>with_fill</code> <code>bool</code> <p>Plot fills on the price plot. Defaults to True.</p> <code>True</code> <code>with_inventory</code> <code>bool</code> <p>Plot inventory on the price plot. Defaults to truth value of <code>group is None</code>.</p> <code>None</code> <code>key</code> <code>str</code> <p>If group is provided, the values of corresponding key are overlayed on the price plot. Defaults to None.</p> <code>None</code> <code>group</code> <code>str</code> <p>The group. Defaults to None.</p> <code>None</code> <code>share_index</code> <code>bool</code> <p>Share the x-axis index with the price plot for plotted key. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Show the plot. Defaults to True.</p> <code>True</code> <code>save</code> <code>str</code> <p>Saves the plot to specified filename if provided. Defaults to None.</p> <code>None</code>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.get_feed","title":"<code>get_feed()</code>","text":"<p>Get a <code>MockFeed</code> instance that can be used like a <code>quantpylib.hft.feed.Feed</code> instance.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.get_mid","title":"<code>get_mid(exc, ticker)</code>","text":"<p>Get the mid price known at current replay time.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.get_oms","title":"<code>get_oms()</code>","text":"<p>Get a <code>MockOMS</code> instance that can be used like a <code>quantpylib.hft.oms.OMS</code> instance.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.play","title":"<code>play()</code>  <code>async</code>","text":"<p>Play the replayer. To be used in place of <code>await asyncio.sleep(x)</code> that sleeps while the trading logic runs.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.statistics","title":"<code>statistics()</code>","text":"<p>Get a dictionary of statistics for each exchange after the replay.</p>"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.statistics_exc","title":"<code>statistics_exc(exc)</code>","text":"<p>Get a dictionary of statistics for a specific exchange after the replay.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required"},{"location":"hft/mocks/#quantpylib.hft.mocks.Replayer.time","title":"<code>time()</code>","text":"<p>Get millisecond timestamp of the replayer is at during <code>play</code>.</p>"},{"location":"hft/oms/","title":"quantpylib.hft.oms","text":""},{"location":"hft/oms/#quantpylib.hft.oms.OMS","title":"<code>OMS</code>","text":""},{"location":"hft/oms/#quantpylib.hft.oms.OMS.__init__","title":"<code>__init__(gateway, exchanges=None, pending_timeout=5000, refresh_orders_snapshot=60, refresh_positions_snapshot=60)</code>","text":"<p>Intialize the Order Management System object.</p> <p>Parameters:</p> Name Type Description Default <code>gateway</code> <code>Gateway</code> <p>Initialized gateway object.</p> required <code>exchanges</code> <code>list</code> <p>The list of exchanges to subscribe to. If None, use the clients in the gateway.</p> <code>None</code> <code>pending_timeout</code> <code>int</code> <p>The timeout in milliseconds for pending orders. Defaults to 5000.</p> <code>5000</code> <code>refresh_orders_snapshot</code> <code>int</code> <p>The refresh interval in seconds to check orders snapshot against mirrored orders. Defaults to 60.</p> <code>60</code> <code>refresh_positions_snapshot</code> <code>int</code> <p>The refresh interval in seconds to check positions snapshot against mirrored positions. Defaults to 60.</p> <code>60</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.add_clock_callback","title":"<code>add_clock_callback(callback, name='CLOCK', interval_ms=500)</code>  <code>async</code>","text":"<p>Add a callback to the event loop that is triggered every interval_ms. Can be used for clock-based trading agents. Callback is shutdown when  OMS is cleaned up.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>coroutine</code> <p>The callback to trigger.</p> required <code>name</code> <code>str</code> <p>The name of the callback. Defaults to 'CLOCK'.</p> <code>'CLOCK'</code> <code>interval_ms</code> <code>int</code> <p>The interval in milliseconds. Defaults to 500.</p> <code>500</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.cancel_order","title":"<code>cancel_order(exc, ticker=None, oid=None, cloid=None)</code>  <code>async</code>","text":"<p>Cancel an order by order id or client order id. If both oid and cloid are None, cancel all open orders for given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker. Defaults to None.</p> <code>None</code> <code>oid</code> <code>str</code> <p>The order id. Defaults to None.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>The client order id. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Clean up the OMS object.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.cloid_query","title":"<code>cloid_query(exc, cloid)</code>","text":"<p>Query order information by client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>cloid</code> <code>str</code> <p>The client order id.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_lot_precision","title":"<code>common_lot_precision(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the lot precision for trading on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_min_notional","title":"<code>common_min_notional(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the minimum notional trade on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.common_price_precision","title":"<code>common_price_precision(ex1, ticker1, ex2, ticker2)</code>","text":"<p>Get the price precision for trading on two different exchanges.</p> <p>Parameters:</p> Name Type Description Default <code>ex1</code> <code>str</code> <p>The first exchange.</p> required <code>ticker1</code> <code>str</code> <p>The first ticker.</p> required <code>ex2</code> <code>str</code> <p>The second exchange.</p> required <code>ticker2</code> <code>str</code> <p>The second ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.contract_specs","title":"<code>contract_specs(exc, ticker)</code>","text":"<p>Get the contract specifications for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.get_all_balances","title":"<code>get_all_balances()</code>  <code>async</code>","text":"<p>Get the balances for all exchanges. Uses HTTP request.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.get_all_equities","title":"<code>get_all_equities()</code>  <code>async</code>","text":"<p>Get the equity for all exchanges. Uses HTTP request.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.get_balance","title":"<code>get_balance(exc)</code>  <code>async</code>","text":"<p>Get the balance for a given exchange. Uses HTTP request.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.get_position","title":"<code>get_position(exc, ticker)</code>","text":"<p>Get the position for a given exchange and ticker. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.hedge_order","title":"<code>hedge_order(maker_order, hedge_order, trigger_after_ms=0)</code>  <code>async</code>","text":"<p>Place a maker-taker order. The maker order is the order that is being hedged. The taker order is the order that hedges the maker order - taker order has no <code>amount</code> specified, size executed is contingent on the size of maker fills.  Each order are dictionaries - and are passed as named arguments (**order) into the gateway  as per the <code>quantpylib.gateway.executor.limit_order</code> and <code>quantpylib.gateway.executor.market_order</code> methods respectively.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.hedge_portfolio_delta","title":"<code>hedge_portfolio_delta(hedge_on='', default_on='', blacklisted_on=set(), by=markets.MARGIN_TOTAL, ord_type=markets.ORDER_TYPE_MARKET, **kwargs)</code>  <code>async</code>","text":""},{"location":"hft/oms/#quantpylib.hft.oms.OMS.init","title":"<code>init(include_funding=False)</code>  <code>async</code>","text":"<p>Initialize the OMS object with information such as exchange contract trading specifications and metadata.  To be called after the OMS has been created.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.lagged_price","title":"<code>lagged_price(exc, ticker)</code>","text":"<p>Get the lagged price for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.limit_order","title":"<code>limit_order(round_to_specs=False, **kwargs)</code>  <code>async</code>","text":"<p>Place a limit order. If round_to_specs is True, round the order amount to the lot precision. Updates the orders page maintained by the OMS with a PENDING status.</p> <p>Parameters:</p> Name Type Description Default <code>round_to_specs</code> <code>bool</code> <p>Round the order amount to the lot precision. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>The order parameters. Parameter usage is same as the <code>quantpylib.gateway.executor.limit_order</code> method.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.lot_precision","title":"<code>lot_precision(exc, ticker)</code>","text":"<p>Get the lot precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.market_order","title":"<code>market_order(round_to_specs=False, **kwargs)</code>  <code>async</code>","text":"<p>Place a market order. If round_to_specs is True, round the order amount to the lot precision. Updates the orders page maintained by the OMS with a PENDING status.</p> <p>Parameters:</p> Name Type Description Default <code>round_to_specs</code> <code>bool</code> <p>Round the order amount to the lot precision. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>The order parameters. Parameter usage is same as the <code>quantpylib.gateway.executor.market_order</code> method.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.min_notional","title":"<code>min_notional(exc, ticker)</code>","text":"<p>Get the minimum notional required to trade for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.oid_query","title":"<code>oid_query(exc, oid)</code>","text":"<p>Query order information by order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>oid</code> <code>str</code> <p>The order id.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.order_delta_hedge","title":"<code>order_delta_hedge()</code>","text":"<p>Hedge order logic. Fill sizes on maker exchange that are not compatible with trading rules on taker exchange are hedged as much as possible, and size differences are submitted to a hedge balance that waits for future arriving fills to be hedged.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_get","title":"<code>orders_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get the orders for a given exchange. Uses HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_get_all","title":"<code>orders_get_all()</code>  <code>async</code>","text":"<p>Get the orders for all exchanges.Uses HTTP request.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_mirror","title":"<code>orders_mirror(exc, on_update=None, on_delta=None)</code>  <code>async</code>","text":"<p>Mirror the orders for a given exchange. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>on_update</code> <code>coroutine</code> <p>The update handler receives order page snapshots. Defaults to None.</p> <code>None</code> <code>on_delta</code> <code>coroutine</code> <p>The delta handler receives order page changes. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.orders_peek","title":"<code>orders_peek(exc)</code>","text":"<p>Return the <code>quantpylib.standards.portfolio.Orders</code> object maintained for a given exchange.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get","title":"<code>positions_get(exc, **kwargs)</code>  <code>async</code>","text":"<p>Get the positions for a given exchange. Uses HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get_all","title":"<code>positions_get_all()</code>  <code>async</code>","text":"<p>Get the positions for all exchanges. Uses HTTP request.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of positions for all exchanges.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get_by_base","title":"<code>positions_get_by_base()</code>","text":"<p>Gets mapping from base asset to exchange positions for all exchanges using the mirrored positions.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_get_net_base","title":"<code>positions_get_net_base()</code>","text":"<p>Gets the net positions for each base asset across all exchanges using the mirrored positions.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_mirror","title":"<code>positions_mirror(exc, on_update=None, on_delta=None)</code>  <code>async</code>","text":"<p>Mirror the positions for a given exchange. Uses socket.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>on_update</code> <code>coroutine</code> <p>The update handler. Defaults to None.</p> <code>None</code> <code>on_delta</code> <code>coroutine</code> <p>The delta handler. Defaults to None.</p> <code>None</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.positions_peek","title":"<code>positions_peek(exc)</code>","text":"<p>Return the <code>quantpylib.standards.portfolio.Positions</code> object maintained for a given exchange.</p>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.price_precision","title":"<code>price_precision(exc, ticker)</code>","text":"<p>Get the price precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.rand_cloid","title":"<code>rand_cloid(exc, **kwargs)</code>","text":"<p>Generate a client order id.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.rounded_lots","title":"<code>rounded_lots(exc, ticker, amount, **kwargs)</code>","text":"<p>Round an amount to the lot precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>amount</code> <code>Decimal</code> <p>The amount to round.</p> required"},{"location":"hft/oms/#quantpylib.hft.oms.OMS.rounded_price","title":"<code>rounded_price(exc, ticker, price, **kwargs)</code>","text":"<p>Round a price to the price precision for a given exchange and ticker.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>The exchange.</p> required <code>ticker</code> <code>str</code> <p>The ticker.</p> required <code>price</code> <code>Decimal</code> <p>The price to round.</p> required"},{"location":"hft/stats/","title":"quantpylib.hft.stats","text":""},{"location":"hft/stats/#quantpylib.hft.stats.intensity","title":"<code>intensity(lob_timestamps, lob_mids, trades, alpha_0=0, kappa_0=0)</code>","text":"<p>Calculate the trading intensity in a Limit Order Boosk.</p> <p>The function takes the historical data of the LOB timestamps, mid prices, and trades,  then calculates the liquidity of the orderbook by fitting an exponential decay model for A = alpha * exp ( - kappa * delta ), where A is the trade amount, alpha is scale, kappa is decay rate, and delta is price distance to mid. Large values of kappa implies is related with higher liquidity and tighter spreads.</p> <p>Parameters:</p> Name Type Description Default <code>lob_timestamps</code> <code>ndarray</code> <p>Array of LOB timestamps.</p> required <code>lob_mids</code> <code>ndarray</code> <p>Array of LOB mid prices.</p> required <code>trades</code> <code>ndarray</code> <p>Array of trade data with columns for timestamp, price, and amount.</p> required <code>alpha_0</code> <code>float</code> <p>Initial guess for the alpha parameter in the exponential decay model. Defaults to 0.</p> <code>0</code> <code>kappa_0</code> <code>float</code> <p>Initial guess for the kappa parameter in the exponential decay model. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the estimated alpha and kappa parameters. Returns (None, None) if no valid data is found.</p> Algorithm <ol> <li>Initialize arrays to store quote and trade events.</li> <li>Populate quote events with timestamps and mid prices from the LOB.</li> <li>Populate trade events with timestamps, prices, and amounts from the trade data.</li> <li>Combine quote and trade events, and sort them by timestamp.</li> <li>Calculate the distance between trade prices and the last observed mid price from the quotes.</li> <li>Aggregate the trade amounts by the calculated distance levels.</li> <li>Fit an exponential decay model to the aggregated data to estimate the alpha and kappa parameters.</li> </ol> Notes <p>see Hummingbot implementation.</p>"},{"location":"hft/trades/","title":"quantpylib.hft.trades","text":""},{"location":"hft/trades/#quantpylib.hft.trades.Trades","title":"<code>Trades</code>","text":""},{"location":"hft/trades/#quantpylib.hft.trades.Trades.__init__","title":"<code>__init__(buffer_size=100)</code>","text":"<p>A class representing a buffer for storing trade logs with attributes for timestamp, price, size, and direction.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>The size of the buffer for storing trades. Defaults to 100.</p> <code>100</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.append","title":"<code>append(trade=None, ts=None, price=None, size=None, dir=None)</code>","text":"<p>Append a new trade to the buffer. A trade is specified by the arguments ts,price,size,dir or with the 4-tuple (ts,price,size,dir).</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>int</code> <p>The timestamp of the trade. Defaults to None.</p> <code>None</code> <code>price</code> <code>float</code> <p>The price of the trade. Defaults to None.</p> <code>None</code> <code>size</code> <code>float</code> <p>The size of the trade. Defaults to None.</p> <code>None</code> <code>dir</code> <code>int</code> <p>The direction of the trade, 1 or -1. Defaults to None.</p> <code>None</code> <code>trade</code> <code>tuple</code> <p>A tuple representing the trade (ts,price,size,dir).</p> <code>None</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.buffer_len","title":"<code>buffer_len()</code>","text":"<p>Get the length of the trade buffer.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the trade buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.clear_buffer","title":"<code>clear_buffer()</code>","text":"<p>Clear the trade buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_buffer","title":"<code>get_buffer()</code>","text":"<p>Get the current contents of the trade buffer.</p> <p>Returns:</p> Type Description <p>np.ndarray: The array of trades in the buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_flow_pnl","title":"<code>get_flow_pnl(n=None, tau=None, T=None, min_n=10, default=0, norm_volume=True, norm_variance=False)</code>","text":"<p>Get the flow pnl over the last sample trades, assuming zero-fee counterparty to all  trades.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of trades to consider. Defaults to the whole stored buffer.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code> <code>min_n</code> <code>int</code> <p>The minimum number of trades required to calculate the flow pnl. Defaults to 10.</p> <code>10</code> <code>default</code> <code>float</code> <p>The default value to return if the buffer has less than <code>min_n</code> data points. Defaults to 0.0.</p> <code>0</code> <code>norm_volume</code> <code>bool</code> <p>Normalize the pnl by the volume. Defaults to True.</p> <code>True</code> <code>norm_variance</code> <code>bool</code> <p>Normalize the pnl by the square root of the number of trades. Defaults to False. Only applicable if <code>norm_volume</code> is True.</p> <code>False</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_imbalance","title":"<code>get_imbalance(n=None, tau=None, T=None, min_n=10, default=0, decay_function=None)</code>","text":"<p>Get the trade imbalance over the last n trades.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of trades to consider. Defaults to the whole stored buffer.</p> <code>None</code> <code>default</code> <code>float</code> <p>The default value to return if the buffer has less than <code>n</code> data points. Defaults to 0.0.</p> <code>0</code> <code>decay_function</code> <code>function</code> <p>The decay function to apply to the samples. Defaults to simple weighting.</p> <code>None</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_sample","title":"<code>get_sample(n=None, tau=None, T=None)</code>","text":"<p>Get a sample of trades from the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of trades to sample.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.get_ts_buffer","title":"<code>get_ts_buffer()</code>","text":"<p>Get the timestamps in the trade buffer.</p>"},{"location":"hft/trades/#quantpylib.hft.trades.Trades.sample_len","title":"<code>sample_len(n=None, tau=None, T=None)</code>","text":"<p>Get the length of the samples.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of samples to take.</p> <code>None</code> <code>tau</code> <code>int</code> <p><code>T - t</code>, where <code>t</code> is the earliest sample time.</p> <code>None</code> <code>T</code> <code>int</code> <p>The terminal time. Defaults to last timestamp observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the samples.</p>"},{"location":"hft/utils/","title":"quantpylib.hft.utils","text":""},{"location":"hft/utils/#quantpylib.hft.utils.exponential_weights","title":"<code>exponential_weights(arr, unique_values=False, normalize=False)</code>","text":"<p>Generates exponential weights for an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray or list</code> <p>The input array.</p> required <code>unique_values</code> <code>bool</code> <p>If True, weights are generated based on the number of unique values in the array.          Duplicate values share the same weight.</p> <code>False</code> <code>normalize</code> <code>bool</code> <p>If True, the weights are normalized to sum to 1.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of exponential weights.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_ema","title":"<code>rolling_ema(arr, n)</code>","text":"<p>Calculate the rolling Exponential Moving Average (EMA).</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input array.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling EMAs.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_window","title":"<code>rolling_window(a, window)</code>","text":"<p>Create a rolling window view of the array <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The input array.</p> required <code>window</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: A view of the input array with the specified rolling window.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.rolling_zscore","title":"<code>rolling_zscore(arr, n)</code>","text":"<p>Calculate the rolling Z-score.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input array.</p> required <code>n</code> <code>int</code> <p>The size of the rolling window.</p> required <p>Returns:</p> Type Description <p>np.ndarray: An array of rolling Z-scores.</p>"},{"location":"hft/utils/#quantpylib.hft.utils.simple_weights","title":"<code>simple_weights(arr, normalize=False)</code>","text":"<p>Generates simple weights for an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray or list</code> <p>The input array.</p> required <code>normalize</code> <code>bool</code> <p>If True, the weights are normalized to sum to 1.</p> <code>False</code> <p>Returns:</p> Type Description <p>np.ndarray: An array of simple weights.</p>"},{"location":"learn/learn/","title":"Learn","text":"<p>See bounties. We are here to learn, so teach us something about markets! Non-trivial stuff, please \ud83d\ude4f.</p>"},{"location":"learn/scientific_programming/","title":"Scientific Programming","text":"<p>lorem ipsum</p>"},{"location":"logger/formatters/","title":"quantpylib.logger.formatters","text":""},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter","title":"<code>JSONFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>A custom JSON formatter for logging.</p> <p>This formatter converts log records to JSON format. It includes level, time, and message by default and can optionally include additional attributes. Key-value pairs in the <code>extra</code> variable of logs are included in the JSON log.</p> <p>Parameters:</p> Name Type Description Default <code>include_attrs</code> <code>list</code> <p>List of additional attributes to include in the log record. Valid entries in the list can be found in <code>quantpylib.logger.utils</code>.</p> <code>[]</code>"},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter.__init__","title":"<code>__init__(include_attrs=[])</code>","text":"<p>Initializes the JSONFormatter.</p> <p>Parameters:</p> Name Type Description Default <code>include_attrs</code> <code>list</code> <p>List of additional attributes to include in the log record.                   Defaults to an empty list. Valid entries in the list can be found in <code>quantpylib.logger.utils</code>.</p> <code>[]</code>"},{"location":"logger/formatters/#quantpylib.logger.formatters.JSONFormatter.format","title":"<code>format(record)</code>","text":"<p>Formats a log record and converts it to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The JSON-formatted log record as a string.</p>"},{"location":"logger/handlers/","title":"quantpylib.logger.handlers","text":""},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler","title":"<code>BufferedFileHandler</code>","text":"<p>               Bases: <code>FileHandler</code></p> <p>A logging handler that buffers log messages and writes them to a file when the buffer is full or on exit.</p> <p>This handler extends <code>logging.FileHandler</code> to provide buffered writing. Log messages are stored in a buffer and are written to the file only when the buffer reaches a specified size or the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.__init__","title":"<code>__init__(filename, mode='a', encoding=None, delay=False, errors=None, buffer_size=64)</code>","text":"<p>Initializes the BufferedFileHandler with the specified parameters.</p> <p>Registers an atexit function to flush the buffer when the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.emit","title":"<code>emit(record)</code>","text":"<p>Adds a log record to the buffer and writes to the file if the buffer is full.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to add to the buffer.</p> required"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedFileHandler.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Writes the contents of the buffer to the file and clears the buffer.</p> <p>This method is thread-safe.</p>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler","title":"<code>BufferedRotatingFileHandler</code>","text":"<p>               Bases: <code>RotatingFileHandler</code></p> <p>A rotating file handler with buffered writing.</p> <p>This handler extends <code>RotatingFileHandler</code> to buffer log messages and write them to the file only when the buffer reaches a specified size. The file is rotated when it reaches a certain size.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>maxBytes</code> <code>int</code> <p>The maximum size of the file before it is rotated. Defaults to 1GB.</p> <code>1 * 1024 * 1024 * 1024</code> <code>backupCount</code> <code>int</code> <p>The number of backup files to keep. Defaults to 5.</p> <code>5</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.__init__","title":"<code>__init__(filename, mode='a', maxBytes=1 * 1024 * 1024 * 1024, backupCount=5, encoding=None, delay=False, errors=None, buffer_size=64)</code>","text":"<p>Initializes the BufferedRotatingFileHandler with the specified parameters.</p> <p>Registers an atexit function to flush the buffer when the program exits.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to write log messages to.</p> required <code>mode</code> <code>str</code> <p>The mode in which the file is opened. Defaults to 'a' (append).</p> <code>'a'</code> <code>maxBytes</code> <code>int</code> <p>The maximum size of the file before it is rotated. Defaults to 1GB.</p> <code>1 * 1024 * 1024 * 1024</code> <code>backupCount</code> <code>int</code> <p>The number of backup files to keep. Defaults to 5.</p> <code>5</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the file. Defaults to None.</p> <code>None</code> <code>delay</code> <code>bool</code> <p>If True, file opening is deferred until the first call to <code>emit()</code>. Defaults to False.</p> <code>False</code> <code>errors</code> <code>str</code> <p>How encoding errors are to be handled. Defaults to None.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The number of log messages to buffer before writing to the file. Defaults to 64.</p> <code>64</code>"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.emit","title":"<code>emit(record)</code>","text":"<p>Adds a log record to the buffer and writes to the file if the buffer is full.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to add to the buffer.</p> required"},{"location":"logger/handlers/#quantpylib.logger.handlers.BufferedRotatingFileHandler.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Writes the contents of the buffer to the file and clears the buffer.</p> <p>This method is thread-safe. Only the last log record in the buffer state is used to check for rotate condition.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written to.</p>"},{"location":"logger/logger/","title":"logger","text":"<p><code>quantpylib.logger</code> is a thread-safe logging module for quantpylib featuring custom formatters and handlers for recording structured log messages and reducing log latency.   </p> <p>The logger is designed for easy usage in Python applications that require both log analysis and performance requirements. </p> <p>In particular, the formatters in <code>quantpylib.logger.formatters</code>  contain log formatters extending the <code>logging.Formatter</code> classes,  designed for structured logging to be used in log aggregation and analysis tools  downstreams. The <code>quantpylib.logger.handlers</code> contain handlers extending  <code>logging.Handler</code> classes, designed for improving write log latencies, such as  buffered handlers that reduce I/O operations. These can be used separetely in your own  logging setup.</p> <p>Alternatively, the <code>quantpylib.logger.Logger</code> object pre-configures a singleton,  named logger. It allows the user to be able to log messages to stdout, files or both,  with the custom handlers and formatters. We will immediately demonstrate with examples.  The documentations follow.</p>"},{"location":"logger/logger/#examples","title":"Examples","text":"<p>The examples are really simple to use. Let us start with some imports, taking the <code>logging</code> library and the <code>quantpylib.logging</code>'s <code>Logger</code> and <code>JSONFormatter</code> object. Let's also take the ability to parse arguments into our Python script.</p> <pre><code>import logging \nfrom quantpylib.logger.logger import Logger \nfrom quantpylib.logger.formatters import JSONFormatter\n\nimport argparse\nparser = argparse.ArgumentParser()\nparser.add_argument('-c', '--config', type=str, help='Specify logging config')\nargs = parser.parse_args()\n</code></pre> <p>We want to log different kinds of information about our Python application - let's create a function that generates the logs. We will use the same function for all configurations, and see how the different specifications change logging behavior.</p> <p><pre><code>def log():\n    logging.debug(\"debug log\", extra={\"my debug key\":\"my debug value\"})\n    logging.info(\"info log\", extra={\"my info key\":\"my info value\"})\n    # input(\"hold\")\n    logging.warning(\"warning log\", extra={\"my warning key\":\"my warning value\"})\n    try:\n        1/0\n    except ZeroDivisionError:\n        logging.exception(\"caught zero denominator\", extra={\"my exception key\":\"my exception value\"})\n</code></pre> Let us ignore <code>input('hold')</code> for now, and have it commented out. We will look at that later. Let us take a look at what are the configuration options for our  <code>Logger</code> object (see documentation) <pre><code>class Logger:\n    #... some stuff\n    def __new__(\n        cls,\n        name='root',\n        register_handlers=[],\n        stdout_register=True,\n        stdout_level=logging.INFO, \n        stdout_formatter_cls=JSONFormatter,\n        stdout_formatter_kwargs={},\n\n        file_register=True,\n        filename=\"app.log\", \n        logs_dir=\"./logs/\",\n        file_level=logging.INFO, \n        file_formatter_cls=JSONFormatter,\n        file_formatter_kwargs={},        \n        file_handler_cls=BufferedFileHandler, \n        file_handler_kwargs={\"buffer_size\": 64},\n    ):\n</code></pre> The default is to configure the <code>root</code> logger. <code>stdout_register</code> and <code>file_register</code> is both set to <code>True</code>, meaning we log to console and to a file. Both levels are set as <code>logging.INFO</code>, meaning we should only see <code>logging.INFO</code> and higher levels. The remainder of the arguments are quite self intuitive, so let us try different configurations:</p>"},{"location":"logger/logger/#default-python-logger","title":"Default Python Logger","text":"<p>Let us begin with no arguments: <pre><code>if __name__ == \"__main__\":\n    if not args.config:\n        print(\"using default python logger\")\n\n    #...\n\n    log()\n</code></pre> We run <pre><code>python example_logger.py\n</code></pre> and we get <pre><code>using default python logger\nWARNING:root:warning log\nERROR:root:caught zero denominator\nTraceback (most recent call last):\n  File \"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\", line 16, in log\n    1/0\n    ~^~\n</code></pre> We get no <code>logging.DEBUG</code>, <code>logging.INFO</code> level messages, and we get a nice, compact message. However, this can be rather difficult to parse in a log ingestion stack.</p> <p>Additionally, we see that the <code>extra</code> values in the log records are ignored.</p>"},{"location":"logger/logger/#default-configurations","title":"Default Configurations","text":"<p>Let's try the default configs in the <code>Logger</code>: <pre><code>    example_configs = {\n        \"name\" : \"root\",\n        \"register_handlers\" : [],\n        \"stdout_register\" : True,\n        \"stdout_level\" : logging.INFO,\n        \"file_register\" : True,\n        \"file_level\" : logging.INFO\n    }\n    if args.config:\n        if args.config == \"d\":\n            print(\"using default quantpylib logger\")\n            Logger()\n</code></pre> We run  <pre><code>python example_logger.py -c d\n</code></pre> and we get <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T15:48:17.562138+00:00\", \"message\": \"info log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T15:48:17.562633+00:00\", \"message\": \"warning log\", \"my warning key\": \"my warning value\"}\n{\"level\": \"ERROR\", \"time\": \"2024-06-15T15:48:17.562706+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"my exception key\": \"my exception value\"}\n</code></pre> We also will see a new <code>./logs/app.log</code> file with the same content. Here, we see that the key-values in the <code>extra</code> parameter are written as part of the logs.</p>"},{"location":"logger/logger/#custom-configuring-our-logger","title":"Custom Configuring our Logger","text":"<p>We can of course, configure the logger. Say, we want to print to console logs formatted by <code>logging.Formatter</code>, while writing to file logs formatted by <code>JSONFormatter</code>. Furthermore, in the <code>JSONFormatter</code>, I also want to include more information from the <code>logging.LogRecord</code>. I choose <code>funcName</code> and <code>filename</code> from the possible attributes, listed here. <pre><code>    elif args.config == \"jf\":\n        print(\"using quantpylib logger with json formatter\")\n        Logger(\n            stdout_formatter_cls=logging.Formatter,\n            file_formatter_cls=JSONFormatter,\n            file_formatter_kwargs={\"include_attrs\":[\"funcName\",\"filename\"]},\n            file_handler_cls=logging.FileHandler,\n            file_handler_kwargs={},\n            **example_configs\n        )\n</code></pre> and run <pre><code>python example_logger.py -c jf\n</code></pre> and we get (we used the standard <code>logging.Formatter</code>) <pre><code>using quantpylib logger with json formatter\ninfo log\nwarning log\ncaught zero denominator\nTraceback (most recent call last):\n  File \"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\", line 16, in log\n    1/0\n    ~^~\nZeroDivisionError: division by zero\n</code></pre> printed to console, and (we used <code>JSONFormatter</code> with <code>funcName</code> and <code>filename</code>) <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T16:26:01.515551+00:00\", \"message\": \"info log\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T16:26:02.830514+00:00\", \"message\": \"warning log\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my warning key\": \"my warning value\"}\n{\"level\": \"ERROR\", \"time\": \"2024-06-15T16:26:02.830820+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"filename\": \"example_logger.py\", \"funcName\": \"log\", \"my exception key\": \"my exception value\"}\n</code></pre> in the <code>app.log</code> file. So far, the default is the <code>BufferedFileHandler</code>, which is a <code>logging.Filehandler</code> that only flushes log to files when a buffer is full or on application exit.  What you would have noticed is that if you now uncomment the <code>input('hold')</code> line and run  <pre><code>python example_logger.py -c jf\n</code></pre> again, you would not see the logs written to file yet, when the execution pauses waiting for input. You can of course, adjust this buffer size.</p> <p>We can also used the <code>BufferedRotatingFileHandler</code>, so that we can store logs in different back up files - this of course - extends the <code>logging.handlers.RotatingFileHandler</code>. Let us try: <pre><code>    elif args.config == \"brfh\":\n        print(\"using quantpylib logger with buffered rotating file handler\")\n        from quantpylib.logger.handlers import BufferedRotatingFileHandler\n        Logger(\n            stdout_formatter_cls=logging.Formatter,\n            file_formatter_cls=JSONFormatter,\n            filename=\"brfh.log\",\n            logs_dir=\"./logs/\",\n            file_handler_cls=BufferedRotatingFileHandler,\n            file_handler_kwargs={\"maxBytes\":64},\n            **example_configs\n        )\n</code></pre> Like the parent <code>RotatingFileHandler</code>, we can set the the number of backup files. the maximum byte condition for rotation and so on. This now behaves like a combination of <code>BufferedFileHandler</code> we have defined and <code>RotatingFileHandler</code> we extended - the only difference is that this rotation is only checked when the buffer is flushed, and the rotate condition is checked on the last record inside the buffer state.</p> <p>We can run: <pre><code>python example_logger.py -c brfh\n</code></pre></p> <p>and we since we set the <code>maxBytes</code> to only 64 - when we flush the three log messages, we get <pre><code>{\"level\": \"INFO\", \"time\": \"2024-06-15T16:04:58.394926+00:00\", \"message\": \"info log\", \"my info key\": \"my info value\"}\n{\"level\": \"WARNING\", \"time\": \"2024-06-15T16:05:02.579663+00:00\", \"message\": \"warning log\", \"my warning key\": \"my warning value\"}\n</code></pre> and then the last item triggers the rotation, putting those log messages in <code>brfh.log.1</code>, and the last record <pre><code>{\"level\": \"ERROR\", \"time\": \"2024-06-15T16:05:02.579820+00:00\", \"message\": \"caught zero denominator\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"/Users/admin/Desktop/projects/quantpylib/examples/example_logger.py\\\", line 16, in log\\n    1/0\\n    ~^~\\nZeroDivisionError: division by zero\", \"my exception key\": \"my exception value\"}\n</code></pre> in <code>brfh.log</code>.</p>"},{"location":"logger/logger/#documentation","title":"Documentation","text":""},{"location":"logger/logger/#quantpylib.logger.logger.Logger","title":"<code>Logger</code>","text":"<p>A configurable singleton logger class that sets up logging for the application.</p> <p>This logger allows for the registration of custom handlers and configuration of console (stdout) and file handlers. It supports various configuration options including log levels, formatters, and buffer sizes for file handling.</p> <p>Attributes:</p> Name Type Description <code>_logger</code> <code>Logger</code> <p>The singleton logger instance.</p>"},{"location":"logger/logger/#quantpylib.logger.logger.Logger.__new__","title":"<code>__new__(name='root', register_handlers=[], stdout_register=True, stdout_level=logging.WARNING, stdout_formatter_cls=JSONFormatter, stdout_formatter_kwargs={}, file_register=True, filename='app.log', logs_dir='./logs/', file_level=logging.WARNING, file_formatter_cls=JSONFormatter, file_formatter_kwargs={}, file_handler_cls=BufferedFileHandler, file_handler_kwargs={'buffer_size': 64}, *args, **kwargs)</code>","text":"<p>Creates and configures the logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger. Defaults to 'root'.</p> <code>'root'</code> <code>register_handlers</code> <code>list</code> <p>A list of additional logging handlers to register. Defaults to an empty list.</p> <code>[]</code> <code>stdout_register</code> <code>bool</code> <p>Whether to register a console (stdout) handler. Defaults to True.</p> <code>True</code> <code>stdout_level</code> <code>int</code> <p>The logging level for the console handler. Defaults to logging.INFO.</p> <code>WARNING</code> <code>stdout_formatter_cls</code> <code>type</code> <p>The formatter class for the console handler. Defaults to <code>quantpylib.logger.formatters.JSONFormatter</code>.</p> <code>JSONFormatter</code> <code>stdout_formatter_kwargs</code> <code>dict</code> <p>Keyword arguments for the console handler formatter. Defaults to an empty dict.</p> <code>{}</code> <code>file_register</code> <code>bool</code> <p>Whether to register a file handler. Defaults to True.</p> <code>True</code> <code>filename</code> <code>str</code> <p>The name of the log file. Defaults to \"app.log\".</p> <code>'app.log'</code> <code>logs_dir</code> <code>str</code> <p>The directory where log files are stored. Defaults to \"./logs/\".</p> <code>'./logs/'</code> <code>file_level</code> <code>int</code> <p>The logging level for the file handler. Defaults to logging.INFO.</p> <code>WARNING</code> <code>file_formatter_cls</code> <code>type</code> <p>The formatter class for the file handler. Defaults to <code>quantpylib.logger.formatters.JSONFormatter</code>.</p> <code>JSONFormatter</code> <code>file_formatter_kwargs</code> <code>dict</code> <p>Keyword arguments for the file handler formatter. Defaults to an empty dict.</p> <code>{}</code> <code>file_handler_cls</code> <code>type</code> <p>The handler class for file logging. Defaults to <code>quantpylib.logger.handlers.BufferedFileHandler</code>.</p> <code>BufferedFileHandler</code> <code>file_handler_kwargs</code> <code>dict</code> <p>Keyword arguments for the file handler. Defaults to {\"buffer_size\": 64}.</p> <code>{'buffer_size': 64}</code> <code>*args</code> <p>Additional positional arguments passed to the logging configuration.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the logging configuration.</p> <code>{}</code> <p>Returns:</p> Type Description <p>logging.Logger: The configured singleton logger instance.</p>"},{"location":"logger/logger/#quantpylib.logger.logger.app","title":"<code>app(message, *args, **kwargs)</code>","text":"<p>Logs a message with the custom APP level.</p>"},{"location":"logger/utils/","title":"quantpylib.logger.utils","text":""},{"location":"logger/utils/#log-record-attributes","title":"Log Record Attributes","text":"<ul> <li><code>args</code>: The tuple of arguments passed to the logging call.</li> <li><code>asctime</code>: The string representation of the time when the <code>LogRecord</code> was created.</li> <li><code>created</code>: The time when the <code>LogRecord</code> was created, in seconds since the epoch.</li> <li><code>exc_info</code>: Exception tuple (type, value, traceback) if an exception occurred during logging.</li> <li><code>exc_text</code>: Textual representation of the exception information.</li> <li><code>filename</code>: The name of the file in which the logging call was made.</li> <li><code>funcName</code>: The name of the function or method from which the logging call was made.</li> <li><code>levelname</code>: The textual representation of the log level (e.g., 'DEBUG', 'INFO').</li> <li><code>levelno</code>: The numeric representation of the log level.</li> <li><code>lineno</code>: The line number in the source code where the logging call was made.</li> <li><code>module</code>: The name of the module in which the logging call was made.</li> <li><code>msecs</code>: The millisecond portion of the time when the <code>LogRecord</code> was created.</li> <li><code>message</code>: The logged message after merging any user-supplied arguments with the message.</li> <li><code>msg</code>: The logged message, before merging with user-supplied arguments.</li> <li><code>name</code>: The name of the logger that created the <code>LogRecord</code>.</li> <li><code>pathname</code>: The full path of the source file where the logging call was made.</li> <li><code>process</code>: The process ID of the process that created the <code>LogRecord</code>.</li> <li><code>processName</code>: The name of the process that created the <code>LogRecord</code>.</li> <li><code>relativeCreated</code>: The time since the logging module was loaded, in milliseconds.</li> <li><code>stack_info</code>: A string representation of the current stack frame.</li> <li><code>thread</code>: The thread ID of the thread that created the <code>LogRecord</code>.</li> <li><code>threadName</code>: The name of the thread that created the <code>LogRecord</code>.</li> <li><code>taskName</code>: The name of the task that created the <code>LogRecord</code>, relevant in asynchronous environments.</li> </ul>"},{"location":"scripts/market_making/","title":"Market Maker","text":"<p>This tutorial shows how to do market making (backtests and live) on different exchanges using <code>quantpylib</code>'s gateway connectors, data feeds and order management system.</p> <p>The sample scripts are placed inside <code>./scripts</code> folder in the <code>quantpylib</code> repo. This example works with exchanges implementing the <code>quantpylib.gateway.master.Gateway</code> endpoints, such as <code>binance</code>, <code>hyperliquid</code>, <code>bybit</code> <code>paradex</code> and <code>woox</code>.</p> <p>Let us first consider the data and portfolio states required for a market-making operation. Typically, a market-maker needs to be able to track their portfolio states: order states (pending/open/cancelled/rejected), open positions, account equity/balance and so on.</p> <p>Of course, tick data feeds are also required. This tick data feed includes but are not limited to orderbook ticks of the market we intend to quote, trade ticks of said market, as well as correlated assets - leader assets (<code>AAPL</code>,<code>BTC</code>) and so on.</p> <p>In general, a market maker action triggers include but are not limited to internal clock cycles, trade arrival, orderbook delta updates and a number of variable proprietary logic. We may choose to act on these data immediately upon arrival (a on-tick behavior) or store it in some shared state that is later used to compute optimal market quotes. We will explore all of these options. </p>"},{"location":"scripts/market_making/#live-simulation-modes","title":"Live + Simulation Modes","text":"<p>Our message replay architecture allows us to both trade and backtest high-frequency data using a unified codebase for seamless transition from research to production environments.</p> <p>Let's begin with the following imports - we are going demonstrate using a reference feed for <code>binance/SOLUSDT</code> and quoting on <code>bybit/SOLUSDT</code>. Let us use the following imports.</p> <p><pre><code>import os \nimport pytz\nimport asyncio \nimport logging \nimport argparse \nimport numpy as np\nfrom pprint import pprint \nfrom decimal import Decimal\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nimport quantpylib.utilities.math as math\nimport quantpylib.standards.markets as markets\n\nfrom quantpylib.hft.oms import OMS\nfrom quantpylib.hft.feed import Feed\nfrom quantpylib.gateway.master import Gateway \nfrom quantpylib.utilities.general import _time,pdf_snapshot\n\nshow = True\nparser = argparse.ArgumentParser(description=\"Parse script mode.\")\nparser.add_argument('mode', type=lambda arg:int(arg), help=\"Set script mode.\")\nargs = parser.parse_args()\nsimulated = False if args.mode == 1 else True\n</code></pre> If we run <code>python3 script.py 0</code> we will run it in simulation (backtest) mode, otherwise we will trade in a live market for <code>python3 script.py 1</code>.</p> <p>For <code>binance</code>, we are only using the public data feeds, while we need to perform privileged activity on <code>bybit</code>. So we will need keys for bybit: <pre><code>config_keys = {\n    \"binance\":{},\n    \"bybit\":{\n        'key':'BYBIT_DEMO_KEY',\n        'secret':'BYBIT_DEMO_SECRET',\n        'env':'demo'\n    },\n}\n</code></pre> These are our setup and configs: <pre><code>exc = 'bybit'\ntickers = [\"SOLUSDT\"]\nstream_data = {\n    \"binance\":[\"BTCUSDT\",\"SOLUSDT\"],\n    \"bybit\":[\"SOLUSDT\"],\n}\nreference = {\n    'SOLUSDT':('binance','SOLUSDT'),\n}\n\nrun = None\ntime = None\nreplayer = None\nprint_interval = 120 * 1000 #every 2 mins\n\nif simulated:\n    from quantpylib.hft.mocks import Replayer,Latencies\n    start='2025-01-10:01'\n    end='2025-01-10:02'\n    latencies={\n        Latencies.REQ_PUBLIC:0,\n        Latencies.REQ_PRIVATE:0,\n        Latencies.ACK_PUBLIC:0,\n        Latencies.ACK_PRIVATE:0,\n        Latencies.FEED_PUBLIC:0,\n        Latencies.FEED_PRIVATE:0,\n    }\n    replayer_configs = {\n        \"maker_fees\":0.000,\n        \"taker_fees\":0.000,\n        \"latencies\":latencies,\n    }\n\nelse:\n    run = lambda : asyncio.sleep(1e9)\n    time = lambda : _time()\n\ngateway = Gateway(config_keys=config_keys)\n</code></pre> We demonstrate with null latencies and fees in our simulation mode. You can also specify in <code>milliseconds</code> the latency for the different message channels, as well as fee tiers for reality modelling. </p> <p>We will kick off the script like this: <pre><code>async def main():\n    await gateway.init_clients() \n    if simulated:\n        oms,feed = await sim_prepare()\n    else:\n        oms = OMS(gateway=gateway,exchanges=[exc],refresh_orders_snapshot=10,refresh_positions_snapshot=10)\n        feed = Feed(gateway=gateway)\n\n    await oms.init()\n    await hft(replayer,oms,feed)\n    await gateway.cleanup_clients()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre></p> <p>The <code>gateway</code> is the connector to the relevant exchanges - which is passed into the <code>oms</code> and <code>feed</code> objects. The <code>oms</code> handles order/position tracking, recovery, execution and auxiliary tasks. The <code>feed</code> does tick data subscription, storing, and retrieval. In simulation environments, we would first need to load data from archives into RAM. The code showing data load and formats are explained in detail in our post on obtaining, archiving, and restoring data.</p> <p><pre><code>async def sim_prepare():\n    l2_data = {exchange:{} for exchange in stream_data}\n    trade_data = {exchange:{} for exchange in stream_data}\n\n    for exchange,tickers in stream_data.items():\n        # await asyncio.gather(*[\n        #     restore_archives(\n        #         exc=exchange,\n        #         ticker=ticker,\n        #         depth=20,\n        #         start=start,\n        #         end=end,\n        #     ) for ticker in tickers\n        # ])\n\n        lob_archives = [\n            Feed.load_lob_archives(\n                exc=exchange,\n                ticker=ticker,\n                depth=20,\n                start=start,\n                end=end\n            ) for ticker in tickers\n        ] \n\n        trade_archives = [\n            Feed.load_trade_archives(\n                exc=exchange,\n                ticker=ticker,\n                start=start,\n                end=end\n            ) for ticker in tickers\n        ]\n\n        l2_data[exchange] = {ticker:lob_archive for ticker,lob_archive in zip(tickers,lob_archives)}\n        trade_data[exchange] = {ticker:trade_archive for ticker,trade_archive in zip(tickers,trade_archives)}\n\n    global replayer, run, time\n    replayer = Replayer(\n        l2_data=l2_data,\n        trade_data=trade_data,\n        gateway=gateway,\n        **replayer_configs\n    )\n    oms = replayer.get_oms()\n    feed = replayer.get_feed()\n    run = lambda : replayer.play()\n    time = lambda : replayer.time()\n    return oms, feed\n</code></pre> In the code above - the <code>quantpylib.hft.mocks</code> module <code>MockOMS</code> and <code>MockFeed</code> are used in place of the <code>OMS</code> and <code>Feed</code> objects during simulation. These can be obtained from the <code>Replayer</code> object. Instead of the system time - the replayer time is used for simulations.</p> <p>We can subscribe to leader tick data feeds, such as BTC trade feeds. For instance, we can use this to compute lead-lag correlations between the quote market and leader market for trade signal. We show how to perform the subscription - but we will not use this in our demonstration. Here the <code>replayer</code> is <code>None</code> in live trading and <code>quantpylib.hft.mocks.Replayer</code> in backtest:  <pre><code>async def hft(replayer,oms,feed):\n    #&gt;&gt; subscribe to global tick-data (if any)\n    btc_feed = await feed.add_trades_feed(\n        exc='binance',\n        ticker='BTCUSDT',\n        buffer=500,\n    )\n\n    await asyncio.gather(*[\n        quote_markets(replayer=replayer,oms=oms,feed=feed,ticker=ticker) \n        for ticker in tickers\n    ])\n    await run()\n\n    if simulated:\n        await sim_report(replayer)\n</code></pre> Let's implement <code>quote_markets</code>: <pre><code>async def trade_handler(msg):\n    pass #msg : (ts,price,size,dir)\n\nasync def book_handler(lob):\n    pass #lob : quantpylib.hft.lob.LOB\n\nasync def quote_markets(replayer,oms,feed,ticker):\n    live_orders = oms.orders_peek(exc=exc)\n    live_positions = oms.positions_peek(exc=exc)\n\n    ref_exc,ref_ticker = reference[ticker]\n    reference_trade_id = await feed.add_trades_feed(\n        exc=ref_exc,\n        ticker=ref_ticker,\n        buffer=500,\n        # handler=trade_handler\n    )\n    reference_trades = feed.get_feed(reference_trade_id)\n    reference_l2_id = await feed.add_l2_book_feed(\n        exc=ref_exc,\n        ticker=ref_ticker,\n        depth=20,\n        buffer=100,\n        # handler=book_handler\n    )\n    reference_lob = feed.get_feed(reference_l2_id)\n\n    ticker_trade_id = await feed.add_trades_feed(\n        exc=exc,\n        ticker=ticker,\n        buffer=500,\n    )\n    ticker_trades = feed.get_feed(ticker_trade_id)\n</code></pre> The <code>oms</code> does order tracking and maintains <code>live_orders</code> which is a <code>quantpylib.standards.portfolio.Orders</code> object. Similarly, the <code>oms</code> maintains <code>live_positions</code> which is a <code>quantpylib.standards.portfolio.Positions</code> object.  These are achieved via the <code>gateway</code>'s underlying socket connections and requests. Note that the <code>oms</code> itself is a separate functionality provided by <code>quantpylib</code>, and is able to do a variety of useful things - such as registering coroutine handlers for order updates, position fills and so on - see examples here. In this section, we will not register any order/position update handlers, and just rely on the live updation of our orders which is intitated by default on <code>oms.init()</code>.</p> <p>Also, we subscribe to the reference market tick data feeds. We can register handlers for a 'on-tick' behavior - the trades receive <code>ts,price,size,dir</code> in the handler and orderbook updates receive <code>quantpylib.hft.lob.LOB</code> object. We are not going to have triggers for orders (you can, if you want) on the reference market tick events. Instead, we are going to use the live data buffers <code>reference_trades</code> (a <code>quantpylib.hft.trades.Trades</code>) object and <code>reference_lob</code> (a <code>quantpylib.hft.lob.LOB</code>) object. These live data buffer classes have in-built methods to compute useful statistics such as <code>get_imbalance</code>, <code>get_vol</code>, <code>get_mid</code> and so on. In our demonstration, we choose action triggers to follow the on tick behaviour of orderbook events on the quote market.</p> <p>Say, we would like to submit/cancel orders using the following logic (there is no alpha in this quoter):</p> <pre><code>1. Fix order notional value at 200.\n2. Compute volume adjusted mid price (VAMP) with notional value of the sum of last 15 taker trades. The VAMP is computed on the orderbook of the reference market, not quote market.\n3. Control inventory by quoting around VAMP with baseline spread of 6 bps, and between 2bps and 6bps depending on holding inventory. Also, be strictly less aggressive than BBA on quote exchange.\n4. If the bid and ask level does not exist, submit new orders. If other price level orders exist, cancel.\n</code></pre> <p>We make no comment or assertions on the viability of said 'rules'. For specifics on how to pass the parameters to <code>oms</code> methods, refer to documentation and examples. gateway documentation and examples should be helpful. Let's continue with the <code>quote_markets</code> implementation: <pre><code>async def quote_markets(replayer,oms,feed,ticker):\n    #...\n    ticker_trades = feed.get_feed(ticker_trade_id)\n    #...code above\n\n    order_value = 200\n    last_print = time()\n    async def l2_handler(lob):\n        nonlocal last_print\n        stamp = time()\n        stamp = stamp - (stamp % print_interval)\n        if stamp != last_print:\n            print(datetime.fromtimestamp(time()/1000,tz=pytz.utc))\n            last_print = stamp\n\n        pos_amount = live_positions.get_ticker_amount(ticker=ticker)\n        inventory_notional = float(pos_amount) * lob.get_mid() \n        q = inventory_notional / order_value\n\n        order_bids = live_orders.get_bid_orders(ticker=ticker) \n        order_asks = live_orders.get_ask_orders(ticker=ticker)\n\n        tds = reference_trades.get_sample(n=15)\n        notional = 20000 if len(tds) == 0 else np.sum(tds[:,1] * tds[:,2])\n        ref_vamp = reference_lob.get_vamp(notional)\n        if np.isnan(ref_vamp):\n            return\n\n        bid = min(\n            ref_vamp - ((6 + np.tanh(q) * 4) * 1e-4) * ref_vamp,\n            lob.get_bids()[1,0]\n        )\n        ask = max(\n            ref_vamp + ((6 + np.tanh(-q) * 4) * 1e-4) * ref_vamp,\n            lob.get_asks()[1,0]\n        )\n\n        bid_price = Decimal(str(oms.rounded_price(exc=exc,ticker=ticker,price=bid)))\n        ask_price = Decimal(str(oms.rounded_price(exc=exc,ticker=ticker,price=ask)))\n\n        orders = []\n        if not any(bid.price == bid_price for bid in order_bids):\n            orders.append({\n                \"exc\":exc,\n                \"ticker\":ticker,\n                \"amount\":order_value/lob.get_mid(),\n                \"price\":bid_price,\n                \"round_to_specs\":True,\n            })\n        if not any(ask.price == ask_price for ask in order_asks):\n            orders.append({\n                \"exc\":exc,\n                \"ticker\":ticker,\n                \"amount\":order_value/lob.get_mid() * -1,\n                \"price\":ask_price,\n                \"round_to_specs\":True,\n            })\n\n        cancels = []\n        for order in order_bids:\n            if order.price != bid_price:\n                cancels.append({\n                    \"exc\":order.exc,\n                    \"ticker\":order.ticker,\n                    \"cloid\":order.cloid\n                })\n        for order in order_asks:\n            if order.price != ask_price:\n                cancels.append({\n                    \"exc\":order.exc,\n                    \"ticker\":order.ticker,\n                    \"cloid\":order.cloid\n                })\n        if orders:\n            try:\n                await asyncio.gather(*[\n                    oms.limit_order(**order) for order in orders\n                ])\n            except e:\n                logging.exception(e)\n        if cancels:\n            try:\n                await asyncio.gather(*[\n                    oms.cancel_order(**cancel) for cancel in cancels\n                ])\n            except:\n                logging.exception(e)\n\n    l2_feed = await feed.add_l2_book_feed(\n        exc=exc,\n        ticker=ticker,\n        depth=20,\n        buffer=100,\n        handler=l2_handler\n    )\n</code></pre> This quote market orderbook feed is subscribed to with the on-tick behaviour of <code>l2_handler</code>. The specified rules are then implemented. On the web-platform of selected exchange (bybit) we can see the quotes submitted (if live):</p> <p></p>"},{"location":"scripts/market_making/#simulation-report-ors","title":"Simulation Report (ORS)","text":"<p>If we were in simulation mode, the <code>Replayer</code> object contains very useful metrics and plots for the simulation events. We will demonstrate these - recall that in the <code>hft</code> method in the above section - we called the <code>sim_report</code> method.</p> <p>We will also demonstrate a new proposal, the Open Research Standard (ORS), <code>quantpylib</code>'s push towards replicable, shareable and effortless quantitative research with code. Quantitative research and papers are often extremely challenging to replicate either in part of the academic tendency for citation mining (lying with statistics) or variability in data, assumptions and implementation. The ORS promotes reliable research with the automatic logging of code results, parameters and implementation together with the <code>pdf_snapshot</code> method for report generation.</p> <pre><code>async def sim_report(replayer):\n    folder = './logs/reports'\n    exchange_plot = f'{folder}/exchange.png'\n    markouts_plot = f'{folder}/markouts.png'\n    prices_plot = '{folder}/prices_{ticker}.png'\n    counterparty_plot = f'{folder}/counterparty_pnl.png'\n    fairprices_plot = f'{folder}/fairprices.png'\n\n    #see plots and reports\n    report_data = []\n    report_data.append((\n        'configs',\n        {\n            'exc':exc,\n            'tickers':tickers,\n            '_start':start,\n            '_end':end,\n            'params':replayer_configs,\n        },\n        'dict'\n    ))\n\n    statistics = replayer.statistics()\n    report_data.append(('stats',statistics,'dict'))\n\n    df_exchange = replayer.df_exchange(exc=exc,save=exchange_plot,show=show)\n    report_data.append(('perf[inventory]',df_exchange,'df'))\n    report_data.append(('perf[inventory]',exchange_plot,'img'))\n\n    df_markouts = replayer.df_markouts(save=markouts_plot,show=show)\n    report_data.append(('markouts',markouts_plot,'img'))\n\n    for ticker in tickers:\n        save = prices_plot.format(folder=folder,ticker=ticker)\n        df_prices = replayer.df_prices(\n            ticker=ticker,exc=exc,show=show,save=save\n        )\n        report_data.append(('fills',save,'img'))\n\n    norm_pnls = replayer.df_counterparty_pnl(exc_tickers=stream_data,save=counterparty_plot,show=show)\n    report_data.append(('counterparty_pnl',counterparty_plot,'img'))\n\n    pdf_snapshot(\n        save=f'{folder}/{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}.pdf',\n        code_file=__file__,\n        report_data=report_data,\n        include_comments=False\n    )\n</code></pre> <p>The <code>replayer.statistics()</code> gives us simulation stats: <pre><code>{'binance': None,\n 'bybit': {'#trades': 59,\n           '0s Markouts':   0s   -0.000015\n                            0s   -0.000015\n                            dtype: float64,\n           '11s Markouts': -7.368662532822541e-06,\n           'Tick Markouts': -1.540771245685202e-05,\n           'flip_win_ratio': 0.6,\n           'interval_quartiles': ['0s', '0s', '11s'],\n           'inventory_flips': 5,\n           'max_leverage': 0.04,\n           'max_norm_beta': 0.04,\n           'maxdd(%)': 0.03,\n           'pnl': -0.14,\n           'roi': -0.0,\n           'sharpe': -7.76,\n           'terminal': 9999.86,\n           'turnover': 0.39,\n           'volume': Decimal('3899.41'),\n           'volume/s($)': Decimal('0.65')}}\n</code></pre></p> <p>The <code>replayer.df_exchange()</code> gives us dataframe and plot on exchange performance - the pnl, inventory breakdown (in our case, only one ticker was quoted so net inventory is just one market):  We can see that our inventory management was somewhat effective, and our pnl is flat.</p> <p>The <code>replayer.df_markouts()</code> gives us markouts on the next tick and more than a few minutes out. </p> <p>The <code>replayer.df_prices()</code> gives us prices overlayed with inventory and fills: </p> <p>The <code>replayer.df_counterparty_pnl()</code> gives us the normalized (across exchange and time axis) pnl from taking on all of the taker order flow on that exchange market. One might argue that the market maker's role is to aim to achieve a positively biased (or at least non-adverse) sample of this order flow.  </p>"},{"location":"scripts/market_making/#open-research-standard","title":"Open Research Standard","text":"<p>The code lines in the previous section help to generate an ORS report. It takes the file path to save, the implementation file, as well as report data which takes types of <code>df</code>, <code>img</code>, or <code>dict</code> to render. <pre><code>pdf_snapshot(\n    save=f'{folder}/{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}.pdf',\n    code_file=__file__,\n    report_data=report_data,\n    include_comments=False\n)\n</code></pre> Here is the ORS generated from the above script.</p>"},{"location":"scripts/market_making/#modelling","title":"Modelling","text":"<p>Please refer to the previous section on market making in simulation and live environments to get an appreciation of the replayer class. This would make modelling extremely simple. In fact, we only need to change one function.</p> <p>For demonstration, we would like to assess the effectiveness of VAMP (volume adjusted mid price) in short term price prediction - as well as compare between different notional values as parameter to the depth of order book pressure relevant in VAMP models.</p> <p>We begin with the imports: <pre><code>import os \nimport pytz\nimport asyncio \nimport logging \nimport argparse \nimport numpy as np\nfrom pprint import pprint \nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.hft.oms import OMS\nfrom quantpylib.hft.feed import Feed\nfrom quantpylib.gateway.master import Gateway \nfrom quantpylib.utilities.general import _time,pdf_snapshot\n\nshow = False\nsimulated = True\n\nconfig_keys = {\n    \"binance\":{},\n}\n\nexc = 'binance'\ntickers = [\"SOLUSDT\"]\nstream_data = {\n    \"binance\":[\"SOLUSDT\"],\n}\n\nrun = None\ntime = None\nreplayer = None\nprint_interval = 120 * 1000\n\nif simulated:\n    from quantpylib.hft.mocks import Replayer,Latencies\n    start='2025-01-10:01'\n    end='2025-01-10:05'\n    latencies={\n        Latencies.REQ_PUBLIC:0,\n        Latencies.REQ_PRIVATE:0,\n        Latencies.ACK_PUBLIC:0,\n        Latencies.ACK_PRIVATE:0,\n        Latencies.FEED_PUBLIC:0,\n        Latencies.FEED_PRIVATE:0,\n    }\n    replayer_configs = {\n        \"maker_fees\":0.000,\n        \"taker_fees\":0.000,\n        \"latencies\":latencies,\n    }\n\nelse:\n    run = lambda : asyncio.sleep(1e9)\n    time = lambda : _time()\n\ngateway = Gateway(config_keys=config_keys)\n</code></pre> The functions  <pre><code>async def hft(replayer,oms,feed):\n    pass\nasync def sim_prepare():\n    pass\nasync def main():\n    pass\n</code></pre> remain unchanged from the previous section. Obviously, we are not submitting order actions and backtesting a hft-strategy. Rather, we are doing some quantitative analysis on replayed tick data. We would have to modify the <code>quote_markets</code> function. Again, we can choose to act on trade ticks, orderbook ticks, or clock ticks. We will stay with the orderbook ticks. This is both extremely simple and self-explanatory: <pre><code>async def quote_markets(replayer,oms,feed,ticker):\n\n    last_print = time()\n    async def l2_handler(lob):\n        nonlocal last_print\n        stamp = time()\n        stamp = stamp - (stamp % print_interval)\n        if stamp != last_print:\n            print(datetime.fromtimestamp(time() / 1000,tz=pytz.utc))\n            last_print = stamp\n\n        for vamp in [10,30,50,100,200]:\n            replayer.declare(\n                key=f'vamp{vamp}k',\n                value=lob.get_vamp(vamp * 1000),\n                exc=exc,\n                ticker=ticker,\n                group='vamp'\n            )    \n\n    l2_feed = await feed.add_l2_book_feed(\n        exc=exc,\n        ticker=ticker,\n        depth=20,\n        buffer=100,\n        handler=l2_handler\n    )\n</code></pre> It is not difficult to understand this, if the last section has been perused. The additional method is the <code>declare</code> method, which takes in key-value arguments for arbitrary random variable and corresponding realised estimate. The <code>exc</code>, <code>ticker</code> and <code>group</code> are optional labels, and it would come in very handy.</p> <p>That's it! After the replay is done in the <code>hft</code> coroutine, we would do our analysis in the <code>sim_report</code> implementation: <pre><code>async def sim_report(replayer):\n    folder = './logs/reports'\n    fairprices_plot = f'{folder}/fairprices.png'\n    regression_plot = f'{folder}/regression.png'\n    regression_influence = f'{folder}/regression_influence.png'\n    price_plot = f'{folder}/prices.png'\n\n    #see plots and reports\n    report_data = []\n    report_data.append((\n        'configs',\n        {\n            'exc':exc,\n            'tickers':tickers,\n            '_start':start,\n            '_end':end,\n            'params':replayer_configs,\n        },\n        'dict'\n    ))\n</code></pre> In our very specific case, the VAMP is actually a fairprice estimator random variable (it is a predictor for future prices). The <code>Replayer</code> class provides utility functions to compare different fairprice estimators sharing the <code>group</code> label: <pre><code>metrics_df, declarations, error_dfs = replayer.df_fairprices(group='vamp',plot=False)\nreport_data.append(('fairprice metrics',metrics_df,'df'))\n</code></pre> <pre><code>                  Q1(e%)    Q3(e%)  MEDIAN(e%)  MEAN(e%)   MSE(e%)   MAD(e%) MSE* MAD*\nT+   Estimator\nt0   vamp100k  -0.003743  0.002893   -0.000325 -0.000447  0.000018  0.003568\n     vamp10k    0.000000  0.000000    0.000000  0.000001  0.000002  0.000679    *    *\n     vamp200k  -0.004440  0.002503   -0.000950 -0.001001  0.000022  0.003854\n     vamp30k   -0.001454  0.001460    0.000000 -0.000041  0.000007  0.001949\n     vamp50k   -0.002563  0.002393    0.000000 -0.000140  0.000011  0.002774\nt1   vamp100k  -0.004179  0.003159   -0.000457 -0.000401  0.000060  0.005186\n     vamp10k   -0.000214  0.000000    0.000000  0.000047  0.000059  0.003743         *\n     vamp200k  -0.004891  0.002762   -0.001088 -0.000955  0.000062  0.005395\n     vamp30k   -0.002253  0.001967    0.000000  0.000005  0.000057  0.004318    *\n     vamp50k   -0.003128  0.002764   -0.000100 -0.000094  0.000057  0.004751\nt10  vamp100k  -0.024027  0.023172   -0.000856  0.000551  0.001625  0.030386    *    *\n     vamp10k   -0.023463  0.023515    0.000000  0.000999  0.001644  0.030497\n     vamp200k  -0.024568  0.022738   -0.001454 -0.000003  0.001626  0.030429\n     vamp30k   -0.023469  0.023481   -0.000109  0.000957  0.001632  0.030412\n...TRUNCATED OUTPUT FOR DIFFERENT FORWARD INTERVALS T(SECONDS)\n</code></pre> The <code>*</code> represents the best estimator for that forward looking interval. We can see that the lowest notional vamp (closest to mid-price) is the best estimator for the next-tick mid price, and that deeper levels of orderbook pressure are favorable for longer-time horizons.</p> <p>We may also be working with non-fairprice estimators, and want to simply retrieve our declarations (arguments are optional filters) <pre><code>declarations = replayer.df_declarations(key='vamp100k',exc=exc,ticker='SOLUSDT',group='vamp')\n</code></pre> and we get: <pre><code>                  ts       key       value      exc   ticker group\n0      1736470799934  vamp100k  186.327409  binance  SOLUSDT  vamp\n1      1736470800444  vamp100k  186.341816  binance  SOLUSDT  vamp\n2      1736470800954  vamp100k  186.297270  binance  SOLUSDT  vamp\n3      1736470801458  vamp100k  186.264105  binance  SOLUSDT  vamp\n4      1736470801962  vamp100k  186.252672  binance  SOLUSDT  vamp\n...              ...       ...         ...      ...      ...   ...\n35006  1736488797277  vamp100k  189.794952  binance  SOLUSDT  vamp\n35007  1736488797865  vamp100k  189.794885  binance  SOLUSDT  vamp\n35008  1736488798422  vamp100k  189.794705  binance  SOLUSDT  vamp\n35009  1736488798942  vamp100k  189.794743  binance  SOLUSDT  vamp\n35010  1736488799447  vamp100k  189.787968  binance  SOLUSDT  vamp\n</code></pre> Often the thing we are interested is how the value of these random variables relate to future prices. We can pass to the replayer a dataframe with <code>ts</code> column to get our answer (works with multiple tickers and multiple exchanges): <pre><code>forward_prices = replayer.augment_forward_prices(declarations)\n</code></pre> for <pre><code>                  ts       key       value      exc  ...      t30      t60     t120     t300        \n0      1736470799934  vamp100k  186.327409  binance  ...  186.435  186.445  186.555  186.865        \n1      1736470800444  vamp100k  186.341816  binance  ...  186.435  186.445  186.555  186.865        \n2      1736470800954  vamp100k  186.297270  binance  ...  186.435  186.425  186.555  186.865        \n3      1736470801458  vamp100k  186.264105  binance  ...  186.435  186.425  186.575  186.865        \n4      1736470801962  vamp100k  186.252672  binance  ...  186.355  186.425  186.575  186.865        \n...              ...       ...         ...      ...  ...      ...      ...      ...      ...        \n34421  1736488497123  vamp100k  189.715000  binance  ...  189.565  189.605  189.555  189.785\n34422  1736488497635  vamp100k  189.715000  binance  ...  189.565  189.605  189.555  189.785\n34423  1736488498179  vamp100k  189.715000  binance  ...  189.565  189.605  189.565  189.785\n34424  1736488498701  vamp100k  189.715000  binance  ...  189.565  189.605  189.565  189.785\n34425  1736488499204  vamp100k  189.712113  binance  ...  189.565  189.605  189.565  189.785\n</code></pre> With this dataframe, we are free to build any statistical model with the regression variables. Let us perform a least-squares regression for future price changes against the vamp-to-mid ratio. Although we don't have to normalize by price (only a single market and short timeframe is considered) - we shall do so. Using the <code>GeneticRegression</code>: <pre><code>from quantpylib.simulator.models import GeneticRegression\nmodel = GeneticRegression(\n    formula='div(minus(t60,t0),t0) ~ div(minus(value,t0),t0)',\n    intercept=False,\n    df=forward_prices,\n)\nregression = model.ols()\nreport_data.append(('regression results',{'summary':regression.summary()},'dict'))\n</code></pre> gives us strong statistical significance: <pre><code>                                 OLS Regression Results\n=======================================================================================\nDep. Variable:                     b0   R-squared (uncentered):                   0.003\nModel:                            OLS   Adj. R-squared (uncentered):              0.003\nMethod:                 Least Squares   F-statistic:                              110.5\nDate:                Sun, 19 Jan 2025   Prob (F-statistic):                    8.20e-26\nTime:                        16:15:01   Log-Likelihood:                      1.8701e+05\nNo. Observations:               34426   AIC:                                 -3.740e+05\nDf Residuals:                   34425   BIC:                                 -3.740e+05\nDf Model:                           1\nCovariance Type:            nonrobust\n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nb1             1.4135      0.134     10.513      0.000       1.150       1.677\n==============================================================================\nOmnibus:                       80.864   Durbin-Watson:                   0.014\nProb(Omnibus):                  0.000   Jarque-Bera (JB):               81.384\nSkew:                           0.118   Prob(JB):                     2.13e-18\nKurtosis:                       3.036   Cond. No.                         1.00\n==============================================================================\n\nNotes:\n[1] R\u00b2 is computed without centering (uncentered) since the model does not contain a constant.\n[2] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n</code></pre> For our plots, we would like to do some aggregation for better readability of the plot - we do data binning and save regression and influence plots: <pre><code>model.ols(bins=50)\nmodel.plot(fit=True,show=show,save_fit=regression_plot,save_influence=regression_influence)\nreport_data.append(('regression (binned)',regression_plot,'img'))\nreport_data.append(('regression (binned)',regression_influence,'img'))\n</code></pre> which gives plot:  and other plots like the influence and residual plots.</p> <p>In this case, the 'indicator' share the same scale as prices themselves, so we can visualize them on the same axis. For other indicators with difference ranges (e.g. trade imbalance, returns, stochastic oscillator) we can overlay them on the price chart with a twin axis <code>share_index=False</code>  : <pre><code>df_prices = replayer.df_prices(ticker='SOLUSDT',exc=exc,show=show,save=price_plot,key='vamp100k',group='vamp',share_index=True)\nreport_data.append(('prices',price_plot,'img'))\n</code></pre> Last but not least - we can make a ORS report: <pre><code>pdf_snapshot(\n    save=f'{folder}/{datetime.now().strftime(\"%Y-%m-%d %H-%M-%S\")}.pdf',\n    code_file=__file__,\n    report_data=report_data,\n    include_comments=False\n)\n</code></pre> shown here.</p> <p>Happy making, makers.</p>"},{"location":"scripts/tick_archival/","title":"Tick Archival","text":"<p>This tutorial shows how to perform multi-exchange, multi-symbol tick data archival and restoration for maintaing your own historical database for research using <code>quantpylib</code>'s gateway connectors and data feeds. </p> <p>The sample scripts are placed inside <code>./scripts</code> folder in the <code>quantpylib</code> repo. This example works with exchanges implementing the <code>quantpylib.gateway.master.Gateway</code> endpoints, such as <code>binance</code>, <code>hyperliquid</code>,<code>bybit</code>,<code>paradex</code>,<code>woox</code>...the list goes on.</p> <p>The demonstration for using the archive-scheduler in the <code>quantpylib.hft.feed</code> class was presented in this section, as well as the specifications of this scheduler. The documentation for the <code>Feed</code> class is here.</p> <p>This demonstration builds on top of the examples presented to add the backup and restoration parts of the data management lifecycle. The code is self-explanatory and simple to follow, so we will go right into it.</p>"},{"location":"scripts/tick_archival/#data-archival","title":"Data Archival","text":"<p>The needed imports: <pre><code>import os\nimport asyncio\nimport logging \n\nfrom pprint import pprint\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.hft.feed import Feed\nfrom quantpylib.gateway.master import Gateway \n</code></pre></p> <p>Data we wish to archive: <pre><code>archive = {\n    \"binance\": [\"BTCUSDT\", \"ETHUSDT\", \"SOLUSDT\", \"DYDXUSDT\"],\n    \"hyperliquid\": [\"BTC\", \"ETH\", \"SOL\"],\n    \"bybit\": [\"BTCUSDT\", \"ETHUSDT\", \"SOLUSDT\"],\n}\n\nkeys = {\n    'binance':{},\n    'hyperliquid':{},\n    'bybit':{},\n}\n</code></pre></p> <p>The intializations of the classes and setting scheduler mode, as discussed in examples: <pre><code>async def main(): \n    #&gt; subscribe to data feeds here\n    pass \n\nif __name__ == \"__main__\":\n    #using our custom logger\n    from quantpylib.logger import Logger\n    Logger(\n        filename=\"archival.log\",\n        logs_dir=\"./logs/\",\n        register_handlers=[],\n        stdout_level=logging.INFO,\n        file_level=logging.INFO,\n        file_formatter_kwargs={\"include_attrs\":[\"filename\",\"funcName\"]},\n    )\n    asyncio.run(main())\n</code></pre> and so we subscribe to the data feeds:</p> <p><pre><code>async def main(): \n    exchanges = list(archive.keys())\n    gateway = Gateway(config_keys=keys)\n\n    await gateway.init_clients()\n    feed = Feed(gateway=gateway,exchanges=exchanges,archiver=True)\n    await feed.run_archive_scheduler(splits=1)\n\n    l2_feeds = {exchange : [] for exchange in exchanges}\n    for exc in exchanges:\n        l2_feeds[exc] = await asyncio.gather(*[\n            feed.add_l2_book_feed(\n                exc=exc,\n                ticker=ticker,\n                depth=20\n            ) for ticker in archive[exc]\n        ])\n    pprint(l2_feeds)\n\n    trade_feeds = {exchange : [] for exchange in exchanges}\n    for exc in exchanges:\n        trade_feeds[exc] = await asyncio.gather(*[\n            feed.add_trades_feed(\n                exc=exc,\n                ticker=ticker\n            ) for ticker in archive[exc]\n        ])\n    pprint(trade_feeds)\n\n    await asyncio.sleep(1e9) #run forever\n</code></pre> The logger and print information shows us our socket messages and feed ids: <pre><code>{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.222522+00:00\", \"message\": \"{'type': 'l2Book', 'coin': 'BTC'} subscribe\", \"exchange\": \"hyperliquid\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.222672+00:00\", \"message\": \"{'type': 'l2Book', 'coin': 'ETH'} subscribe\", \"exchange\": \"hyperliquid\"}\n... blah blah\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.466152+00:00\", \"message\": \"{'type': 'l2Book', 'symbol': 'SOLUSDT'} connected\", \"exchange\": \"binance\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.521773+00:00\", \"message\": \"{'type': 'l2Book', 'symbol': 'DYDXUSDT'} connected\", \"exchange\": \"binance\"}\n... blah blah\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.521903+00:00\", \"message\": \"orderbook.50.BTCUSDT subscribe\", \"exchange\": \"bybit\"}\n... blah blah\n\n&gt;&gt;l2book\n{'binance': ['binance/perp/l2book/BTCUSDT_depth20',\n             'binance/perp/l2book/ETHUSDT_depth20',\n             'binance/perp/l2book/SOLUSDT_depth20',\n             'binance/perp/l2book/DYDXUSDT_depth20'],\n 'bybit': ['bybit/perp/l2book/BTCUSDT_depth20',\n           'bybit/perp/l2book/ETHUSDT_depth20',\n           'bybit/perp/l2book/SOLUSDT_depth20'],\n 'hyperliquid': ['hyperliquid/perp/l2book/BTC_depth20',\n                 'hyperliquid/perp/l2book/ETH_depth20',\n                 'hyperliquid/perp/l2book/SOL_depth20']}\n\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:42:16.573811+00:00\", \"message\": \"{'type': 'trades', 'coin': 'BTC'} subscribe\", \"exchange\": \"hyperliquid\"}\n... blah blah\n\n&gt;&gt;trades\n{'binance': ['binance/perp/trades/BTCUSDT',\n             'binance/perp/trades/ETHUSDT',\n             'binance/perp/trades/SOLUSDT',\n             'binance/perp/trades/DYDXUSDT'],\n 'bybit': ['bybit/perp/trades/BTCUSDT',\n           'bybit/perp/trades/ETHUSDT',\n           'bybit/perp/trades/SOLUSDT'],\n 'hyperliquid': ['hyperliquid/perp/trades/BTC',\n                 'hyperliquid/perp/trades/ETH',\n                 'hyperliquid/perp/trades/SOL']}\n</code></pre> And at the turn of every hour, we will see logging information from our archivers the data written to disk: <pre><code>{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.944775+00:00\", \"message\": \"WRITE archives/binance/perp/l2book/2025/01/SOLUSDT_depth20_0618.parquet records: 2067 size: 151 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.956748+00:00\", \"message\": \"WRITE archives/binance/perp/l2book/2025/01/DYDXUSDT_depth20_0618.parquet records: 1915 size: 194 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.969286+00:00\", \"message\": \"WRITE archives/binance/perp/l2book/2025/01/ETHUSDT_depth20_0618.parquet records: 2040 size: 301 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.979822+00:00\", \"message\": \"WRITE archives/binance/perp/l2book/2025/01/BTCUSDT_depth20_0618.parquet records: 2018 size: 225 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.989928+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/l2book/2025/01/ETH_depth20_0618.parquet records: 1855 size: 351 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T18:59:59.999185+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/l2book/2025/01/BTC_depth20_0618.parquet records: 1855 size: 330 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.008760+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/l2book/2025/01/SOL_depth20_0618.parquet records: 1855 size: 264 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.115225+00:00\", \"message\": \"WRITE archives/bybit/perp/l2book/2025/01/ETHUSDT_depth20_0618.parquet records: 37493 size: 1750 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.219891+00:00\", \"message\": \"WRITE archives/bybit/perp/l2book/2025/01/BTCUSDT_depth20_0618.parquet records: 38033 size: 1733 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.337505+00:00\", \"message\": \"WRITE archives/bybit/perp/l2book/2025/01/SOLUSDT_depth20_0618.parquet records: 44103 size: 1539 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.443742+00:00\", \"message\": \"WRITE archives/binance/perp/trades/2025/01/BTCUSDT_0618.parquet records: 16956 size: 117 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.448196+00:00\", \"message\": \"WRITE archives/binance/perp/trades/2025/01/ETHUSDT_0618.parquet records: 13317 size: 105 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.449853+00:00\", \"message\": \"WRITE archives/binance/perp/trades/2025/01/SOLUSDT_0618.parquet records: 2585 size: 23 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.451086+00:00\", \"message\": \"WRITE archives/binance/perp/trades/2025/01/DYDXUSDT_0618.parquet records: 716 size: 10 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.452716+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/trades/2025/01/ETH_0618.parquet records: 1806 size: 19 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.453973+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/trades/2025/01/BTC_0618.parquet records: 1839 size: 20 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.454900+00:00\", \"message\": \"WRITE archives/hyperliquid/perp/trades/2025/01/SOL_0618.parquet records: 558 size: 7 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.458417+00:00\", \"message\": \"WRITE archives/bybit/perp/trades/2025/01/ETHUSDT_0618.parquet records: 11528 size: 61 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.463980+00:00\", \"message\": \"WRITE archives/bybit/perp/trades/2025/01/BTCUSDT_0618.parquet records: 17574 size: 95 KB\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:00:00.466282+00:00\", \"message\": \"WRITE archives/bybit/perp/trades/2025/01/SOLUSDT_0618.parquet records: 6645 size: 30 KB\"}\n</code></pre></p>"},{"location":"scripts/tick_archival/#data-backup","title":"Data Backup","text":"<p>Our data would be in the local disk. However, as we stream for days, weeks and months at a time - the size of storing high-frequency data becomes large. We would like to backup our files to a cloud datastore such as AWS S3 or Backblaze B2 buckets. We will demonstrate with Backblaze. Signing up and creating a data bucket on their UI takes a matter of minutes. Obtain your keys, and put them in the <code>.env</code> files.</p> <p><code>quantpylib.utilties.general</code> features a <code>backup_folder</code> method that walks a local path directory and checks local files against the file paths in your bucket. If it does not exist, it will make a copy of that in your data bucket.</p> <p>With this: <pre><code>async def backup_archives():\n    from quantpylib.utilities.general import get_boto_client, backup_folder\n    logging.info('BACKUP ARCHIVES')\n    try:\n        local = \"./archives\"\n        bucket = \"backblaze-archives\" #your bucket name\n        s3 = await get_boto_client(\n            endpoint_url=os.getenv(\"BACKBLAZE_ENDPOINT\"),\n            aws_access_key_id=os.getenv(\"BACKBLAZE_ID\"),\n            aws_secret_access_key=os.getenv(\"BACKBLAZE_KEY\"),\n        )\n        await backup_folder(s3=s3,local=local,bucket=bucket)\n    except:\n        logging.exception('backup error')\n        return\n\nasyncio.run(backup_archives())\n</code></pre> the local <code>./archives</code> folder is mirrored onto the Backblaze bucket:  with log information: <pre><code>{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:01.808975+00:00\", \"message\": \"BACKUP ARCHIVES\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.784779+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/trades/2025/01/BTC_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.784882+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/trades/2025/01/SOL_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.784947+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/trades/2025/01/ETH_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785062+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/l2book/2025/01/BTC_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785122+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/l2book/2025/01/ETH_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785173+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;hyperliquid/perp/l2book/2025/01/SOL_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785307+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/trades/2025/01/BTCUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785370+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/trades/2025/01/SOLUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785468+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/trades/2025/01/ETHUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785631+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/l2book/2025/01/SOLUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785718+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/l2book/2025/01/ETHUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785784+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;bybit/perp/l2book/2025/01/BTCUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.785952+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/trades/2025/01/BTCUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786010+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/trades/2025/01/SOLUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786066+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/trades/2025/01/ETHUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786122+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/trades/2025/01/DYDXUSDT_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786231+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/l2book/2025/01/SOLUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786282+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/l2book/2025/01/DYDXUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786335+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/l2book/2025/01/ETHUSDT_depth20_0618.parquet&gt;\"}\n{\"level\": \"INFO\", \"time\": \"2025-01-06T19:04:04.786387+00:00\", \"message\": \"File exists&lt;NO&gt; upload&lt;binance/perp/l2book/2025/01/BTCUSDT_depth20_0618.parquet&gt;\"}\n</code></pre></p>"},{"location":"scripts/tick_archival/#data-restoration","title":"Data Restoration","text":"<p>Suppose we have changed our workstation, and the local archives are empty. We would like to retrieve/restore data from our backblaze archive into local disk for tick-data modelling, research or backtesting. This is also incredibly easy - we just decide which ticker, exchange and date-range. The <code>Feed</code> class can generate file paths to search for, and <code>quantpylib.utilties.general</code> features a <code>restore_folder</code> method: <pre><code>async def restore_archives(exc,ticker,start,end,depth=20):\n    from quantpylib.utilities.general import get_boto_client, restore_folder    \n    logging.info('RESTORE ARCHIVES')\n    local = \"./archives\"\n    try:\n        local = \"./archives\"\n        bucket = \"backblaze-archives\"\n        s3 = await get_boto_client(\n            endpoint_url=os.getenv(\"BACKBLAZE_ENDPOINT\"),\n            aws_access_key_id=os.getenv(\"BACKBLAZE_ID\"),\n            aws_secret_access_key=os.getenv(\"BACKBLAZE_KEY\"),\n        )\n        lob_archives = Feed.load_lob_archives(\n            exc=exc,\n            ticker=ticker,\n            depth=depth,\n            start=start,\n            end=end,\n            path=local,\n            only_paths=True,\n        )\n        trade_archives = Feed.load_trade_archives(\n            exc=exc,\n            ticker=ticker,\n            start=start,\n            end=end,\n            path=local,\n            only_paths=True,\n        )\n        search_files = [os.path.relpath(archive_file, local) for archive_file in lob_archives + trade_archives]\n        pprint(search_files)\n        await restore_folder(s3=s3,local=local,bucket=bucket,match_files=search_files)\n    except:\n        logging.exception('restore error')\n        return\n</code></pre> and we can specify date ranges using <code>YYYY-MM-DD:HH</code>: <pre><code>asyncio.run(\n    restore_archives(\n        exc='binance',\n        ticker='BTCUSDT',\n        start='2025-01-05:22',\n        end='2025-01-06:02'\n    )\n)\n</code></pre> and the following files (if present) would be loaded from your cloud archive into the local <code>./archives</code> folder: <pre><code>{\"level\": \"INFO\", \"time\": \"2025-01-06T18:56:25.905379+00:00\", \"message\": \"RESTORE ARCHIVES\"}\n['binance/perp/l2book/2025/01/BTCUSDT_depth20_0522.parquet',\n 'binance/perp/l2book/2025/01/BTCUSDT_depth20_0523.parquet',\n 'binance/perp/l2book/2025/01/BTCUSDT_depth20_0600.parquet',\n 'binance/perp/l2book/2025/01/BTCUSDT_depth20_0601.parquet',\n 'binance/perp/l2book/2025/01/BTCUSDT_depth20_0602.parquet',\n 'binance/perp/trades/2025/01/BTCUSDT_0522.parquet',\n 'binance/perp/trades/2025/01/BTCUSDT_0523.parquet',\n 'binance/perp/trades/2025/01/BTCUSDT_0600.parquet',\n 'binance/perp/trades/2025/01/BTCUSDT_0601.parquet',\n 'binance/perp/trades/2025/01/BTCUSDT_0602.parquet']\n</code></pre> Once the data has beed loaded to disk, the same code with flag <code>only_paths=False</code> loads the actual data from disk into memory: <pre><code>lob_archives = Feed.load_lob_archives(\n    exc=exc,\n    ticker=ticker,\n    depth=depth,\n    start=start,\n    end=end,\n    path=local\n)\ntrade_archives = Feed.load_trade_archives(\n    exc=exc,\n    ticker=ticker,\n    start=start,\n    end=end,\n    path=local\n)\n</code></pre></p> <p>Has it ever been easier?</p>"},{"location":"simulator/alpha/","title":"quantpylib.simulator.alpha","text":"<p><code>quantpylib.simulator.alpha</code> is our core backtesting module, and exposes multiple abstract  base classes that can be easily extended to implement your own custom trading strategies. <code>quantpylib.simulator.alpha.BaseAlpha</code> encodes the underlying backtest logic, and <code>quantpylib.simulator.alpha.Alpha</code> extends <code>BaseAlpha</code> and implements important features such that the user only has to write code for generating relative forecasts/signals. Position-sizing, risk-management, volatility targeting, PnL accounting and trade simulation is then handled by the backtest logic.</p> <p>In addition, we provide simple but powerful access to an assortment of performance metrics and hypothesis tests (monte carlo permutation tests) on any instance of the <code>BaseAlpha</code> object to test for strategy effectiveness.</p> <p>Users would likely only have to interact with the abstract <code>quantpylib.simulator.alpha.Alpha</code> class, and implement the<code>compute_forecasts</code> and <code>compute_signals</code> function in custom-classes that extend the <code>Alpha</code> class. Additionally, users may opt to use our automatic formulaic parser and use <code>quantpylib.simulator.gene.GeneticAlpha</code> that extends the <code>Alpha</code> class to opt for a no-code backtest by just encoding their trading strategy as a simple Python <code>str</code>, for which all the abstract functions would be automatically implemented.</p>  Using the quantpylib.simulator.gene.GeneticAlpha is the simplest and recommended way of using our BaseAlpha and Alpha classes, as no additional code needs to be written. If the primitives supported by our gene module is not sufficient to encode your trading strategy, then the Alpha class should be sufficient for most needs."},{"location":"simulator/alpha/#alpha","title":"Alpha","text":"<code>     __init__     </code> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume min of OHLC dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume max of OHLC dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of traded instruments.</p> <code>[]</code> <code>execrates</code> <code>ndarray</code> <p>Execution rates for each instrument. Default is None.</p> <code>None</code> <code>commrates</code> <code>ndarray</code> <p>Commission rates for each instrument. Default is None.</p> <code>None</code> <code>longswps</code> <code>ndarray</code> <p>Long annualized swap/funding rates for each instrument. Positive swaps means long positions incur swap fees. Default is None.</p> <code>None</code> <code>shortswps</code> <code>ndarray</code> <p>Short annualized swap/funding rates for each instrument. Positive swaps means short positions incur swap fees. Default is None.</p> <code>None</code> <code>granularity</code> <code>Period</code> <p>The granularity of each trading signal evaluation.  Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>positional_inertia</code> <code>float</code> <p>Parameter controlling position change inertia. Default is 0.</p> <code>0</code> <code>portfolio_vol</code> <code>float</code> <p>Target portfolio volatility. Default is 0.20, representing 20% annualized volatility.</p> <code>0.2</code> <code>weekend_trading</code> <code>bool</code> <p>Indicates if there is weekend trading, such as in cryptocurrency markets. Defaults to False.</p> <code>False</code> <code>around_the_clock</code> <code>bool</code> <p>Indicates if there is 24H trading, such as in cryptocurrency and fx markets. Defaults to False.</p> <code>False</code> <code>currency_denomination</code> <code>str</code> <p>Currency denomination for the portfolio. Default is \"USD\".</p> <code>'USD'</code> <code>starting_capital</code> <code>float</code> <p>Amount to begins the backtest with. Defaults to 10000.0.</p> <code>10000.0</code> <p>Notes:     execrates, commrates, longswps, shortswps are presented in decimals. <code>execrates = [0.001, 0.005, ...]</code> encodes     that 0.1% of notional value transacted is deducted as execution costs for first instrument, second instrument...      commrates specify commisions in the same units (as percentage of notional value),      as for overnight swap rates for both long and short positions.</p>  For the dfs dictionary passed into BaseAlpha objects, it should contain the DataFrames for all data required in the trading strategy. Minimally, dfs should contain key-value pair of (ticker:pd.DataFrame) with OHLCV data for PnL accounting. The pd.DataFrame objects provided should have timezone aware DatetimeIndex properties. For instance: <pre><code>{\n    'BRKB':\n                                open      high       low        close        adj_close volume\n    datetime\n    2000-01-03 00:00:00+00:00  1825.0000  1829.0000  1741.0000  1765.0000    35.3000   873500     \n    2000-01-04 00:00:00+00:00  1725.0000  1733.0000  1695.0000  1704.0000    34.0800  1380000     \n    2000-01-05 00:00:00+00:00  1707.0000  1773.0000  1695.0000  1732.0000    34.6400   997000     \n    2000-01-06 00:00:00+00:00  1745.0000  1804.0000  1727.0000  1804.0000    36.0800   917000     \n    2000-01-07 00:00:00+00:00  1830.0000  1848.0000  1805.0000  1820.0000    36.4000  1001500     \n    ...                              ...        ...        ...        ...        ...      ...     \n    2009-12-24 00:00:00+00:00  3281.9999  3295.9899  3274.9999  3286.9999    65.7400   607600     \n    2009-12-28 00:00:00+00:00  3279.9999  3289.9999  3274.9999  3285.3699    65.7074  1080250     \n    2009-12-29 00:00:00+00:00  3284.9999  3289.6899  3269.9999  3279.9999    65.6000  1105300     \n    2009-12-30 00:00:00+00:00  3282.9999  3289.6499  3279.9999  3289.6499    65.7930   560350     \n    2009-12-31 00:00:00+00:00  3289.9999  3300.9899  3279.9999  3285.9999    65.7200   972900 \n} \n</code></pre> <code>     compute_signals     </code> <code>async, abstract</code> <p>Abstract function that should be implemented in child-class extending the <code>Alpha</code> class. This is where users can manipulate the dataframes in <code>dfs</code> dict passed by accessing  <code>self.dfs</code> to compute useful metrics such as technical indicators.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>DatetimeIndex</code> <p>datetime index for intervals at specified granularity.</p> required <code>     compute_forecasts     </code> <code>abstract</code> <p>Abstract function that should be implemented in child-class extending the <code>Alpha</code> class. Computes relative forecasts for <code>self.instruments</code> on <code>dt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_i</code> <p>Number of time intervals passed between date and backtest start.</p> required <code>dt</code> <code>datetime</code> <p>The datetime for which forecasts are to be computed.</p> required <code>eligibles_row</code> <code>ndarray</code> <p>An array mask of length <code>len(self.instruments)</code> that acts as a bit mask for eligible trading universe.</p> required <p>Returns:</p> Type Description <code>array</code> <p>An array representing the relative forecasts for each of instruments in <code>self.instruments</code> with length <code>len(self.instruments)</code>.</p> Notes <p>It is not required for the forecasts to be indicative of the number of contracts the strategy should trade. The values in the returned array need only be indicative of the relative strength in the signal forecast. For instance, <code>[-1, 1, 1.5]</code> means we want to be as short the first instrument as we are long the second instrument, and we want to be longer by a factor of 1.5 in the third instrument as we are in the second instrument. Position sizing in the underlying contracts are dealt with automatically in the backtest engine using volatility  targeting at the instrument and strategy level. <code>np.nan</code>, <code>np.inf</code> values are treated as zero.</p> <code>     instantiate_eligibilities_and_strat_variables     </code> <p>This is where the child class can instantiate object attributes that can be used in the <code>compute_forecasts</code> function. Optional to implement. <code>eligiblesdf</code> is the default bit mask DataFrame encoding trading universe on  each time point between <code>start</code> and <code>end</code>, but it may be modified in an overriding method to use a different universe set throughout the backtest. </p> <p>Parameters:</p> Name Type Description Default <code>eligiblesdf</code> <code>DataFrame</code> <p>Bit mask DataFrame. Value of 1 means the instrument is eligible to be considered  for trading on given date, and value of 0 means not eligible. Computed based on the market data given in <code>self.dfs</code>.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>eligiblesdf is returned to the caller, and is used as the updated (if modified) bit-mask. If the function is not  implemented, the default <code>eligiblesdf</code> is used.</p> Notes <p>This function is optional to implement. The default implemention is a one-liner returning <code>eligiblesdf</code>.</p> <p>The remaining functions are not abstract and no further implementation is required or warranted.</p> <code>     run_simulation     </code> <code>async</code> <p>Runs the entire backtest. Should only be called after concrete implementation of <code>compute_signals</code> and <code>compute_forecasts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>(boolean, optional) flag to print out backtest simulation information at runtime.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a DataFrame containing backtest statistics. Contains information about contracts held throughtout the backtest, portfolio weights, portfolio leverage, nominal exposusure, execution costs, commissions, swaps, PnL, portfolio capital and so on.</p> <code>     get_performance_measures     </code> <p>Computes the performance metrics for the trading strategy.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul> <code>     hypothesis_tests     </code> <code>async</code> <p>Conducts monte carlo permutation p-value hypothesis tests on the performance of the  trading strategy represented by the object instance.</p> <p>Parameters:</p> Name Type Description Default <code>num_decision_shuffles</code> <code>int</code> <p>Number of decision shuffles for monto carlo permutation tests. Default is 1000.</p> <code>1000</code> <code>num_data_shuffles</code> <code>int</code> <p>Number of data shuffles for permutation tests. Default is 10 (computationally expensive).</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of hypothesis tests.</p> <ul> <li>'timer_p': p-value from asset-timing test that shuffles time-series asset returns.</li> <li>'picker_p': p-value from asset-picking shuffler test that shuffles cross-sectional asset returns.</li> <li>'trader_p1': p-value from decision-making test that shuffles both time-series and cross-sectional asset returns.</li> <li>'trader_p2': p-value from decision-making test that shuffles market data.</li> </ul>"},{"location":"simulator/gene/","title":"quantpylib.simulator.gene","text":"<p><code>quantpylib.simulator.gene</code> houses powerful features for numerical computations involving market  and non-market variables, including a no-code mathematical parser-evaluator that computes trading signals/indicators from formulaic, well-defined Python <code>str</code> objects. The parser-evaluator is exposed via the  <code>quantpylib.simulator.gene.Gene</code> class APIs, which internally uses a tree-data structure to encode trading formulas. The <code>quantpylib.simulator.gene.GeneticAlpha</code> class leverages this parser-evaluator, as well as the backtest engine provided by our <code>quantpylib.simulator.alpha.Alpha</code>  class to provide a no-code solution to backtesting trading strategies. The <code>GeneticAlpha</code> class  extends the <code>Alpha</code>   class to implement all the necessary methods for signal computation, forecast generation, position sizing, risk-management, volatility targeting and backtest logic. All the performance metrics and hypothesis testing suites made available to the <code>Alpha</code>  objects are naturally available to any <code>GeneticAlpha</code> instance via the same function signatures.</p>"},{"location":"simulator/gene/#geneticalpha","title":"GeneticAlpha","text":"<p>(Bases: <code>quantpylib.simulator.alpha.Alpha</code>  )</p> <p>Parameters:</p> Name Type Description Default <code>genome</code> <code>Gene or str</code> <p>Genome representation as <code>Gene</code> object or in mathematical string format.   </p> required <code>**kwargs</code> <p>Backtest parameters required to instantiate <code>quantpylib.simulator.alpha.Alpha</code> objects.</p> <code>{}</code> <p>Parameters in <code>**kwargs</code> are required and passed into <code>quantpylib.simulator.alpha.Alpha</code>  and are as follows: </p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume min of OHLC dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>Start of backtest simulation. If not tz-aware, assumed UTC. If not given, assume max of OHLC dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of traded instruments.</p> <code>[]</code> <code>execrates</code> <code>ndarray</code> <p>Execution rates for each instrument. Default is None.</p> <code>None</code> <code>commrates</code> <code>ndarray</code> <p>Commission rates for each instrument. Default is None.</p> <code>None</code> <code>longswps</code> <code>ndarray</code> <p>Long annualized swap/funding rates for each instrument. Positive swaps means long positions incur swap fees. Default is None.</p> <code>None</code> <code>shortswps</code> <code>ndarray</code> <p>Short annualized swap/funding rates for each instrument. Positive swaps means short positions incur swap fees. Default is None.</p> <code>None</code> <code>granularity</code> <code>Period</code> <p>The granularity of each trading signal evaluation.  Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>positional_inertia</code> <code>float</code> <p>Parameter controlling position change inertia. Default is 0.</p> <code>0</code> <code>portfolio_vol</code> <code>float</code> <p>Target portfolio volatility. Default is 0.20, representing 20% annualized volatility.</p> <code>0.2</code> <code>weekend_trading</code> <code>bool</code> <p>Indicates if there is weekend trading, such as in cryptocurrency markets. Defaults to False.</p> <code>False</code> <code>around_the_clock</code> <code>bool</code> <p>Indicates if there is 24H trading, such as in cryptocurrency and fx markets. Defaults to False.</p> <code>False</code> <code>currency_denomination</code> <code>str</code> <p>Currency denomination for the portfolio. Default is \"USD\".</p> <code>'USD'</code> <code>starting_capital</code> <code>float</code> <p>Amount to begins the backtest with. Defaults to 10000.0.</p> <code>10000.0</code> <p>Notes:     execrates, commrates, longswps, shortswps are presented in decimals. <code>execrates = [0.001, 0.005, ...]</code> encodes     that 0.1% of notional value transacted is deducted as execution costs for first instrument, second instrument...      commrates specify commisions in the same units (as percentage of notional value),      as for overnight swap rates for both long and short positions.</p> <code>     run_simulation     </code> <code>async</code> <p>Runs the entire backtest. </p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <p>(boolean, optional) flag to print out backtest simulation information at runtime.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a DataFrame containing backtest statistics. Contains information about contracts held throughtout the backtest, portfolio weights, portfolio leverage, nominal exposusure, execution costs, commissions, swaps, PnL, portfolio capital and so on.</p> <code>     get_performance_measures     </code> <p>Computes the performance metrics for the trading strategy.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul> <code>     hypothesis_tests     </code> <code>async</code> <p>Conducts monte carlo permutation p-value hypothesis tests on the performance of the  trading strategy represented by the object instance.</p> <p>Parameters:</p> Name Type Description Default <code>num_decision_shuffles</code> <code>int</code> <p>Number of decision shuffles for monto carlo permutation tests. Default is 1000.</p> <code>1000</code> <code>num_data_shuffles</code> <code>int</code> <p>Number of data shuffles for permutation tests. Default is 10 (computationally expensive).</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of hypothesis tests.</p> <ul> <li>'timer_p': p-value from asset-timing test that shuffles time-series asset returns.</li> <li>'picker_p': p-value from asset-picking shuffler test that shuffles cross-sectional asset returns.</li> <li>'trader_p1': p-value from decision-making test that shuffles both time-series and cross-sectional asset returns.</li> <li>'trader_p2': p-value from decision-making test that shuffles market data.</li> </ul>"},{"location":"simulator/gene/#gene","title":"<code>Gene</code>","text":"<p>Represents a formulaic alpha expression used to encode trading rules.</p> <p>This class internally represents a trading rule as a tree data structure, where each node can either be a terminal (leaf) node or a functional node. Terminal nodes represent data points or constants, while functional nodes represent operations on their child nodes.</p> <code>     str_to_gene     </code> <code>staticmethod</code> <code>     __init__     </code> <p>Initializes a Gene object.</p> <p>Parameters:</p> Name Type Description Default <code>prim</code> <code>str</code> <p>The primary function/terminal of the gene.</p> required <code>space</code> <code>str</code> <p>The space value associated with the gene, specifying      details of the primitive. For example, in the context of financial     trading, this could represent parameters such as window size or lookback     period of a rolling correlation function. Defaults to None.</p> <code>None</code> <code>is_terminal</code> <code>bool</code> <p>Indicates whether the gene is terminal node.</p> required <code>parent</code> <code>Gene</code> <p>The parent gene. Defaults to None.</p> <code>None</code> <code>children</code> <code>list</code> <p>The list of child genes. Defaults to an empty list.</p> <code>[]</code> <p>The list of <code>prim</code> primitives supported by our library, their behavior and their interpretations can be found here.</p> <code>     evaluate_node     </code> <p>Recursively evaluates a node in the formulaic alpha expression. When called on the root node in the  gene representation, this function evaluates the entire formulaic expression.</p> <p>Parameters:</p> Name Type Description Default <code>insts</code> <code>list</code> <p>The list of instrument names.</p> required <code>dfs</code> <code>dict</code> <p>A dictionary containing pricing/alternative data DataFrames for each instrument.</p> required <code>idx</code> <code>Index</code> <p>The index for alignment.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The evaluated node with DataFrame.index=idx and DataFrame.columns=insts.</p>  dfs should contain DataFrames for all terminals required in the evaluation of the gene representation. For OHLCV terminals, dfs should contain key-value pair of (ticker:pd.DataFrame). pd.DataFrame objects provided should have timezone aware DatetimeIndex properties. For instance: <pre><code>{\n    'BRKB':\n                                open      high       low        close        adj_close volume\n    datetime\n    2000-01-03 00:00:00+00:00  1825.0000  1829.0000  1741.0000  1765.0000    35.3000   873500     \n    2000-01-04 00:00:00+00:00  1725.0000  1733.0000  1695.0000  1704.0000    34.0800  1380000     \n    2000-01-05 00:00:00+00:00  1707.0000  1773.0000  1695.0000  1732.0000    34.6400   997000     \n    2000-01-06 00:00:00+00:00  1745.0000  1804.0000  1727.0000  1804.0000    36.0800   917000     \n    2000-01-07 00:00:00+00:00  1830.0000  1848.0000  1805.0000  1820.0000    36.4000  1001500     \n    ...                              ...        ...        ...        ...        ...      ...     \n    2009-12-24 00:00:00+00:00  3281.9999  3295.9899  3274.9999  3286.9999    65.7400   607600     \n    2009-12-28 00:00:00+00:00  3279.9999  3289.9999  3274.9999  3285.3699    65.7074  1080250     \n    2009-12-29 00:00:00+00:00  3284.9999  3289.6899  3269.9999  3279.9999    65.6000  1105300     \n    2009-12-30 00:00:00+00:00  3282.9999  3289.6499  3279.9999  3289.6499    65.7930   560350     \n    2009-12-31 00:00:00+00:00  3289.9999  3300.9899  3279.9999  3285.9999    65.7200   972900 \n} \n</code></pre> For non-OHLCV terminals, dfs should be supplemented with key-value pair of (ticker_terminal:pd.Series). pd.Series objects provided should have timezone aware DatetimeIndex properties. <pre><code>{\n    'BRKB_earnings' : pd.Series(\n            index=[2000-01-03 00:00:00+00:00, ..., 2009-12-30 00:00:00+00:00],\n            data=[...]\n    ),\n    'BRKB_sentiment' : pd.Series(\n            index=[2010-01-03 00:00:00+00:00, ..., 2016-12-30 00:00:00+00:00],\n            data=[...]\n    )\n}\n</code></pre> <code>     make_dot     </code> <p>Generate a DOT language representation of the tree structure rooted at this node.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the DOT language representation of the tree.</p> Notes <p>This method uses pre-order traversal to generate the DOT representation of the tree rooted at the current node. Each node in the tree corresponds to a vertex in the DOT graph, and each edge represents the parent-child relationship between nodes.</p> <p>The generated DOT string can be rendered into a graphical visualization using graphviz or other tools that support the DOT language.</p> <code>     height     </code> <p>Return the maximium distance from current node to any leaf node that is a descendant.</p> <code>     depth     </code> <p>Return the distance from current node to the root node.</p> <code>     size     </code> <p>Return the number of nodes in the graphical respresentation of the formulaic alpha.</p> <code>     pre_ord_apply     </code> <p>Apply a function to each node in the tree using pre-order traversal.</p> <p>This method traverses the tree in a pre-order fashion, meaning it applies the function to the current node before recursively traversing its children. The function is applied to each node along with any additional keyword arguments provided.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>A function to be applied to each node in the tree.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the function.</p> <code>{}</code>"},{"location":"simulator/gene/#list-of-primitives","title":"List of Primitives","text":"<p>The Op value = <code>idx_op</code> can be taken to be default as <code>union_idx_op</code>, or when explicitly paired with the <code>un</code> Space value. It takes <code>intersect_idx_op</code> when paired with the <code>ix</code> Space value. Examples would be <code>plus(open,close)</code>, <code>plus_un(open,close)</code>, <code>plus_ix(open,close)</code>. The different operators and their behavior is documented here.</p> Primitive Space Op Terminal Args Meaning Example const int,float - Yes - represents a constant numerical value of x const_3.14 open - - Yes - open price open high - - Yes - high price high low - - Yes - low price low close - - Yes - close price close volume - - Yes - trade volume volume * - - Yes - custom variable * (e.g. epsEst, sentiment) abs - self_idx_op2 No 1 absolute value abs(minus(close,open)) neg - self_idx_op2 No 1 negation neg(minus(close,open)) log - self_idx_op2 No 1 natural logarithm (replacing inf with NaN) log(volume) sign - self_idx_op2 No 1 sign function sign(minus(close,open)) tanh - self_idx_op2 No 1 tanh function tanh(cszscre(logret_1())) sigmoid - self_idx_op2 No 1 sigmoid function sigmoid(cszscre(logret_1())) recpcal - self_idx_op2 No 1 reciprocal (replacing inf with NaN) recpcal(close) pow int self_idx_op2 No 1 power function (replacing inf with NaN) pow_2(close) csrank - all_idx_op No 1 cross-sectional rank (smallest=1, average draws) csrank(volume) cszscre - all_idx_op No 1 cross-sectional Z-score cszscre(volume) percentile - all_idx_op No 1 cross-sectional percentile values percentile(volume) ls int,float / int,float all_idx_op No 1 -1 for values below 25 percentile and +1 for values above 75 percentile ls_25/75(volume) delta int self_idx_op No 1 time-series change in variable over time delta_1(close) delay int self_idx_op No 1 time-series delay by specified number of periods delay_1(close) forward int self_idx_op No 1 time-series lookahead by specified number of periods forward_1(close) sum int self_idx_op No 1 sum of time-series values sum_5(volume) prod int self_idx_op No 1 product of time-series values prod_5(volume) mean, sma int self_idx_op No 1 simple mean of time-series values mean_5(volume) ema, ewma int self_idx_op No 1 exponentially weighted moving average ewma_5(volume) median int self_idx_op No 1 median of time-series values median_5(volume) std int self_idx_op No 1 standard deviation of time-series values std_5(volume) var int self_idx_op No 1 variance of time-series values var_5(volume) skew int self_idx_op No 1 skewness of time-series values skew_5(volume) kurt int self_idx_op No 1 kurtosis of time-series values kurt_5(volume) tsrank int self_idx_op No 1 time-series rank tsrank_5(volume) tsmax int self_idx_op No 1 maximum value over time tsmax_5(volume) tsmin int self_idx_op No 1 minimum value over time tsmin_5(volume) tsargmax int self_idx_op No 1 index of maximum value over time tsargmax_5(volume) tsargmin int self_idx_op No 1 index of minimum value over time tsargmin_5(volume) tszscre int self_idx_op No 1 time-series Z-score tszscre_5(volume) max -,un,ix idx_op No &gt;=2 maximum over arguments max_ix(open,close,high) plus -,un,ix idx_op No &gt;=2 sum over arguments plus_un(open,close,high) minus -,un,ix idx_op No 2 subtraction minus(high,low) mult -,un,ix idx_op No 2 multiplication mult(open,close) div -,un,ix idx_op No 2 division div(open,close) and -,un,ix idx_op No 2 logical AND and(gt(high,low),lt(high,low)) or -,un,ix idx_op No 2 logical OR or(gt(high,low),lt(high,low)) eq -,un,ix idx_op No 2 logical EQUALS eq(gt(high,low),lt(high,low)) gt -,un,ix idx_op No 2 greater-than comparison gt(open,close) gte -,un,ix idx_op No 2 greater-than-equals comparison gte(open,close) lt -,un,ix idx_op No 2 less-than comparison lt(open,close) lte -,un,ix idx_op No 2 less-than-equals comparison lte(open,close) ite -,un,ix idx_op No 3 if-then-else operation ite(or(gt(high,low),lt(high,low)),const_1,const_-1) cor int slow_idx_op No 2 rolling-correlation cor_12(volume,close) kentau int slow_idx_op No 2 rolling-Kendall's tau correlation kentau_12(volume,close) cov int slow_idx_op No 2 rolling-covariance cov_12(volume,close) dot int slow_idx_op No 2 rolling-dot product dot_12(volume,close) wmean, wma int slow_idx_op No 2 weighted moving average wmean_12(close,weights) grssret int - Pseudo 0 period gross returns grssret_12() logret int - Pseudo 0 period log returns logret_12() netret int - Pseudo 0 period net returns (gross returns - 1) netret_12() volatility int - Pseudo 0 volatility (standard deviation of log returns) volatility_12() rsi int - Pseudo 0 relative strength index indicator rsi_12() mvwap int - Pseudo 0 moving volume-weighted average price indicator mvwap_12() obv int - Pseudo 0 on-balance volume indicator obv_12() atr int - Pseudo 0 average true range indicator atr_12() tr - - Pseudo 0 true range indicator tr() adx int - Pseudo 0 average directional movement index adx_12() addv int - Pseudo 0 average daily dollar volume addv_12() mac int / int - No 1 moving average crossover indicator function for fast/slow mac_20/50 vma, vwma int - No 1 volume weighted moving average vma_20(close) vwvar int - No 1 volume weighted variance vmvar_20(logret_1()) vwstd int - No 1 volume weighted standard deviation vmstd_20(logret_1()) between int,float / int,float - No 1 indicator function for  a &lt;= x &lt;= b between_10/90(percentile(volume))"},{"location":"simulator/models/","title":"quantpylib.simulator.models","text":"<p><code>quantpylib.simulator.models</code> house powerful features for statistical analysis involving market and non-market variables. It features <code>quantpylib.simulator.models.GeneticRegression</code> class that is an abstraction layer written on top of the  <code>quantpylib.simulator.gene.Gene</code> class and <code>statsmodels.formula.api</code> to perform no-code  regression analysis using simple string specifications.</p> <p>An example scenario for quantitative analysis is a momentum study on the impact of standardized  returns on forward returns. We may specify such a regression study by the following regression formula: <pre><code>forward_1(logret_1()) ~ div(logret_25(),volatility_25()) + tsargmax_16(close)\n</code></pre> The <code>GeneticRegression</code> enables this in multiple steps:</p> <ul> <li>Parse the formula into blocks: <ul> <li><code>b0</code>: <code>forward_1(logret_1())</code></li> <li><code>b1</code>: <code>div(logret_25(),volatility_25())</code></li> <li><code>b2</code>: <code>tsargmax_16(close)</code></li> </ul> </li> <li>Construct the equivalent regression specification: <code>b0 ~ b1 + b2</code></li> <li>Evaluate each block using our evaluator-parser in the <code>Gene</code> class.</li> <li>Pass the evaluated blocks and regression specification into <code>statsmodels</code> for regression analysis.</li> </ul> <p>This allows the user to both leverage on the well-tested and familiar statistical package developed under <code>statsmodels</code>, while enhancing the expressive capabilities of the formulaic language specialized for trading analysis. The full list of primitives (constants and functions) are documented here.</p> <p>We also provide additional convenience methods for data binning and aggregation, diagnostics and plotting. The specifications are to be referred below.</p> <p>The following notations apply in the documentation:</p> <pre><code>- y, b0 : response variable\n- x[*], b[1..] : independent variable(s)\n- y^ : fitted response\n- uCI : upper confidence interval\n- lCI : lower confidence interval\n- res : residuals\n- res# : (z-score) normalized residuals\n- res+ : internally studentized residuals\n- res* : externally studentized residuals\n- PRP : partial regression plot\n- CCPR : component-component plus residual plot\n</code></pre>"},{"location":"simulator/models/#quantpylib.simulator.models.Bin","title":"<code>Bin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration representing different binning methods.</p> <p>Attributes:</p> Name Type Description <code>WIDTH</code> <p>Binning method where each bin has an equal interval length.</p> <code>OBSERVATIONS</code> <p>Binning method where each bin contains an equal number of observations.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression","title":"<code>GeneticRegression</code>","text":""},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.__init__","title":"<code>__init__(formula='forward_1(logret_1()) ~ div(logret_25(),volatility_25())', intercept=True, df=None, start=None, end=None, dfs={}, instruments=[], granularity=Period.DAILY, build=True)</code>","text":"<p>Initializes a GeneticRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The regression formula. The formula describes the statistical model being analysed, and is closely inspired by the formula mini-language used in R and S. The model formula should consist of valid string representations of <code>Gene</code> formula blocks as  dependent and independent variables delimited by the operators [ ~ + * : ] of the <code>patsy</code> language.</p> <code>'forward_1(logret_1()) ~ div(logret_25(),volatility_25())'</code> <code>start</code> <code>datetime</code> <p>Start period for regression analysis. If not tz-aware, assumed UTC. If not given, assume min of dataset in dfs. </p> <code>None</code> <code>end</code> <code>datetime</code> <p>End period for regression analysis. If not tz-aware, assumed UTC. If not given, assume max of dataset in dfs. </p> <code>None</code> <code>dfs</code> <code>dict</code> <p>inst : OHLCV/other Dataframes used for computations. Default is an empty dictionary.</p> <code>{}</code> <code>instruments</code> <code>list</code> <p>List of instruments used in the regression analysis.</p> <code>[]</code> <code>granularity</code> <code>Period</code> <p>The granularity of the regression analysis. Datapoints of lower granularity than specified are ignored. Last known datapoint of multiple entries in the same granularity interval is taken. Default is <code>Period.DAILY</code>.</p> <code>DAILY</code> <code>build</code> <code>bool</code> <p>Whether to evaluate the formulaic blocks upon initialization. Default is True.</p> <code>True</code>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.build","title":"<code>build()</code>","text":"<p>Evaluates the formulaic (dependent and independent) blocks to be used as regression  variables using the initialized formula and dataframes provided. If <code>build=False</code> at initialization, then  <code>build()</code> needs to be called before any of the regression methods, such as <code>ols</code>, are called.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.diagnose","title":"<code>diagnose()</code>","text":"<p>Diagnoses the regression model for multicollinearity and other issues.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the following:</p> <ul> <li>\"cond_num\": Condition number of the derived design matrix</li> <li>\"vif b[1..]\" : variance inflation factor for the relevant regressor variable.</li> </ul>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.ols","title":"<code>ols(axis='flatten', bins=0, binned_by=Bin.OBSERVATIONS, bin_block='b0', selector=None, aggregator=lambda x: np.mean(winsorize(x, limits=(0.05, 0.05))))</code>","text":"<p>Performs Ordinary Least Squares (OLS) regression analysis. </p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>The axis along which the regression analysis is performed. Possible values are <code>flatten</code>, <code>xs</code>, or <code>ts</code>. <code>flatten</code> uses all of the available data as regression input. <code>xs</code> uses cross sectional data on a particular date as regression input. <code>ts</code> uses time series data for a particular instrument as regression input.</p> <code>'flatten'</code> <code>bins</code> <code>int</code> <p>The number of bins for grouping the data. If 0, no binning is performed. Defaults to 0.</p> <code>0</code> <code>binned_by</code> <code>Bin</code> <p>The method used for binning the data. Possible values are <code>Bin.OBSERVATIONS</code> or <code>Bin.WIDTH</code>, corresponding to  equal number of observations in each bin and equal interval length in each bin respectiely.                </p> <code>OBSERVATIONS</code> <code>bin_block</code> <code>str</code> <p>The block used for binning the data. Defaults to <code>b0</code>, the dependent variable.</p> <code>'b0'</code> <code>selector</code> <code>str or datetime</code> <p><code>str</code> instrument when <code>axis=ts</code> and <code>datetime</code> index when <code>axis=xs</code> to perform regression on. Ignored when <code>axis=flatten</code>.</p> <code>None</code> <code>aggregator</code> <code>callable or dict</code> <p>Used for aggregating data within each bin. If callable is provided, then all of the blocks are aggregated using this  function. Different aggregators can be provided for different blocks, by providing dictionary containing <code>block : aggregator</code> such as <code>{\"b0\" : np.mean, \"b1\" : np.median}</code>. Defaults to <code>lambda x:np.mean(winsorize(x, limits=(0.05, 0.05)))</code>.</p> <code>lambda x: mean(winsorize(x, limits=(0.05, 0.05)))</code> <p>Returns:</p> Type Description <code>RegressionResults</code> <p>The statsmodels results  of the OLS regression analysis.</p>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.parse_formula","title":"<code>parse_formula(formula)</code>  <code>staticmethod</code>","text":"<p>Obtains the block-formula mapping and the derived <code>patsy</code> formula describing the regression model.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The regression formula. The formula describes the statistical model being analyzed and follows the syntax of the patsy formula. Supports [ ~ + * : ] operators.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing</p> <ul> <li>dict: Mapping of block names to their respective formula blocks.</li> <li>str: The derived patsy formula representing the regression model.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; GeneticRegression.parse_formula(\"forward_1(logret_1()) ~ div(logret_25(),volatility_25()) + tsargmax_16(close)\")\n({'b0': 'forward_1(logret_1())', 'b1': 'div(logret_25(),volatility_25())', 'b2': 'tsargmax_16(close)'}, 'b0~b1+b2')\n</code></pre>"},{"location":"simulator/models/#quantpylib.simulator.models.GeneticRegression.plot","title":"<code>plot(fit=True, diagnostics=True, influence=True, leverage=True, show=True, save_fit=None, save_diagnostics=None, save_influence=None, save_leverage=None)</code>","text":"<p>Plots various diagnostic plots for the regression model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>bool</code> <p>If <code>True</code>, plots, for each regressor x,</p> <ul> <li>uCI ~ x</li> <li>lCI ~ x</li> <li>y ~ x</li> <li>y^ ~ x</li> </ul> <code>True</code> <code>diagnostics</code> <code>bool</code> <p>If <code>True</code>, plots, for each regressor x,</p> <ul> <li>y ~ x, y^ ~ x, uCI ~ x, lCI ~ x</li> <li>res ~ x</li> <li>PRP</li> <li>CCPR</li> </ul> <code>True</code> <code>influence</code> <code>bool</code> <p>If <code>True</code>, plots</p> <ul> <li>res* ~ leverage</li> </ul> <code>True</code> <code>leverage</code> <code>bool</code> <p>If <code>True</code>, plots</p> <ul> <li>leverage ~ (res#)**2</li> </ul> <code>True</code>"},{"location":"simulator/operators/","title":"quantpylib.simulator.operators","text":"<p>The <code>quantpylib.simulator.operators</code> is a helper module consisting of operators that are used for data alignment in the evaluation of functions used by the <code>quantpylib.simulator.gene</code>'s Gene class. The semantics of the functions defined and how they operate on the arguments provided depend on the class of operators the primitive belongs to. See the list of primitives here.</p> <p>For example, we may be interested in using as our trading signal the sum of <code>facebook_sentiment</code> and <code>twitter_sentiment</code>, where the former is sampled everyday  and latter is sampled only weekly. The formula <code>plus(facebook_sentiment,twitter_sentiment)</code> can have different interpretations depending on how we want to align data for which one or both of the arguments is <code>nan</code>.</p> <p> last-known basis: this phrase can be construed as forward filling DataFrames and applying the relevant operation.</p> <code>     all_idx_op(op, chress, **kwargs)     </code> <p>Apply a specified operation to each row of the provided DataFrame. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to each row of the DataFrame. It must accept a pandas Series as input and return a pandas Series/numpy.ndarray of same length.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the result of the operation applied to each row of the provided DataFrame.</p> <p>Examples: <pre><code>def test_all_idx_op():\n    data = {'inst1': [3,      5, 2,  np.nan, 8,   np.nan, np.nan, 10, np.nan, 7],\n            'inst2': [np.nan, 5, 12, 9,      15,  np.nan, 8,      13, 14,     11]\n            }\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    result = all_idx_op(lambda x: scipy.stats.rankdata(x, method=\"average\", nan_policy=\"omit\"), [df])\n    expected_data = {'inst1':[1.0,    1.5, 1.0, 1.0, 1.0, 1.0, 1.5, 1.0, 1.0, 1.0],\n                    'inst2': [np.nan, 1.5, 2.0, 2.0, 2.0, 2.0, 1.5, 2.0, 2.0, 2.0]}\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(df.index)\n    assert result.columns.equals(df.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     intersect_idx_op(op, insts, aligner, chress, **kwargs)     </code> <p>Perform a intersection operation on index labels and apply a given operation across multiple arrays or pandas DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across arrays/DataFrames.</p> required <code>insts</code> <code>list</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the result DataFrame with.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames or numbers.Number containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the input arrays/DataFrames.</p> <p>Examples: <pre><code>def test_intersect_idx_op():\n    data1 = {'inst1': [np.nan, 2.0,    3,      np.nan, 5], \n             'inst2': [6,      np.nan, 8,      9,      10]}\n\n    data2 = {'inst1': [1.0,    2,      np.nan, np.nan, 5], \n             'inst2': [11,     12,     13,     np.nan, 15]}\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    result = intersect_idx_op(np.add, ['inst1', 'inst2'], aligner, [df1, df2])    \n    expected_data = {\n        'inst1': [np.nan, 4.0,    np.nan, np.nan, 10], \n        'inst2': [17.0,   np.nan, 21,     np.nan, 25]\n    }\n    expected_result = pd.DataFrame(\n        expected_data, index=pd.date_range(start='2022-01-01', periods=5,freq='D')\n    )\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     self_idx_op(op, insts, aligner, win, chress, **kwargs)     </code> <p>Apply a specified operation to each instance in the provided time series data, using a rolling window. Missing arguments are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to each instance in the time series data.  It must accept a pandas Series as input and return a scalar value.</p> required <code>insts</code> <code>list of str</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the results.</p> required <code>win</code> <code>int</code> <p>Window size for the rolling computation.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to each instance, aligned with the provided aligner.</p> <p>Examples: <pre><code>def test_self_idx_op():\n    data = {'inst1': [1, 2,      3, np.nan, 5,  np.nan, np.nan, 8,  np.nan, 10],\n            'inst2': [6, np.nan, 8, 9,      10, np.nan, 12,     13, 14,     15]}\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', end='2022-01-10', freq='D'))\n    result = self_idx_op(np.mean, ['inst1', 'inst2'], aligner, 3, [df])\n\n    expected_data = {\n        'inst1': [\n            np.nan, np.nan, 2.0,    np.nan,   3.333333, np.nan, np.nan,    5.333333,  np.nan, 7.666667\n        ],\n        'inst2': [\n            np.nan, np.nan, np.nan, 7.666667, 9.0,      np.nan, 10.333333, 11.666667, 13.0,   14.0\n        ]\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     self_idx_op2(op, chress, **kwargs)     </code> <p>Apply a specified unary transformation to the provided time series data.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied to the provided time series data. It must accept a pandas DataFrame as input and return a pandas DataFrame.</p> required <code>chress</code> <code>list</code> <p>singleton list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Result of applying the operation to the provided time series data. The output DataFrame will have the same index and columns as the input DataFrame.</p> <p>Examples: <pre><code>def test_self_idx_op2():\n    data = {'inst1': [1, 2,      3, np.nan, 5,  np.nan, np.nan, 8,  np.nan, 10],\n            'inst2': [6, np.nan, 8, 9,      10, np.nan, 12,     13, 14,     15]}\n    df = pd.DataFrame(data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    result = self_idx_op2(lambda x: -1 * x, [df])\n\n    expected_data = {'inst1':[-1, -2,     -3, np.nan, -5,  np.nan, np.nan, -8,  np.nan, -10],\n                    'inst2': [-6, np.nan, -8, -9,     -10, np.nan, -12,    -13, -14,    -15]\n                }\n    expected_result = pd.DataFrame(\n        expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D')\n    )\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(df.index)\n    assert result.columns.equals(df.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     slow_idx_op(op, insts, aligner, win, chress, **kwargs)     </code> <p>Apply a specified operation to aligned time series data, potentially handling unequal indices. The reference indices aligned to for each inst is the argument with the smallest number of data points. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across time series data. It must accept numpy arrays as input.</p> required <code>insts</code> <code>list of str</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to determine the common index for alignment.</p> required <code>win</code> <code>int</code> <p>Window size for rolling computation. Used for operations that involve a rolling window, such as rolling correlation.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the aligned time series data.</p> <p>Examples: <pre><code>def test_slow_idx_op():\n    data1 = {\n        'inst1': [np.nan, 2,      3,      np.nan, 5,  6,      np.nan, 8,  9,      10], #7 data points\n        'inst2': [6,      np.nan, 8,      9,      10, np.nan, 12,     13, np.nan, 15] #7 data points\n    }\n    data2 = {\n        'inst1': [1,      2,      np.nan, 4,      5,  6,      7,      8, 9,       10], #9 data points\n        'inst2': [11,     12,     13,     np.nan, 15, 16,     17,     18, np.nan, 20] #8 data points\n    }\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', end='2022-01-10', freq='D'))\n    result = slow_idx_op(lambda a,b:np.add(a,b)[0], ['inst1', 'inst2'], aligner, 1, [df1, df2])\n    expected_data = {\n        'inst1': [np.nan, 4.0,    5.0,  np.nan, 10.0, 12.0,   np.nan, 16.0, 18.0,   20.0], #min(7,9)=7, choose df1.inst1.index as reference\n        'inst2': [17.0,   np.nan, 21.0, 22.0,   25.0, np.nan, 29.0,   31.0, np.nan, 35.0] #min(7,8)=7, choose df1.inst2.index as reference\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=10, freq='D'))\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p> <code>     union_idx_op(op, insts, aligner, chress, **kwargs)     </code> <p>Perform a union operation on index labels and apply a given operation across multiple arrays or pandas DataFrames. Missing arguments applied on last-known basis.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>callable</code> <p>The operation to be applied across arrays/DataFrames.</p> required <code>insts</code> <code>list</code> <p>List of instance names or identifiers.</p> required <code>aligner</code> <code>DataFrame</code> <p>A DataFrame with a pandas datetime index property to align the result DataFrame with.</p> required <code>chress</code> <code>list</code> <p>list of DataFrames or numbers.Number containing time series data. Each DataFrame should have columns corresponding to the instance names provided in 'insts'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the result of the operation applied to the input arrays/DataFrames.</p> <p>Examples: <pre><code>def test_union_idx_op():\n    data1 = {'inst1': [np.nan, 2.0,    3,      np.nan, 5], \n             'inst2': [6,      np.nan, 8,      9,      10]}\n    data2 = {'inst1': [1.0,    2,      np.nan, np.nan, 5], \n             'inst2': [11,     12,     13,     np.nan, 15]}\n    df1 = pd.DataFrame(data1, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    df2 = pd.DataFrame(data2, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n    aligner = pd.DataFrame(index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n\n    result = union_idx_op(np.add, ['inst1', 'inst2'], aligner, [df1, df2])\n\n    expected_data = {\n        'inst1': [np.nan, 4.0, 5,  np.nan, 10], \n        'inst2': [17.0,   18,  21, 22,     25]\n    }\n    expected_result = pd.DataFrame(expected_data, index=pd.date_range(start='2022-01-01', periods=5, freq='D'))\n\n    assert isinstance(result, pd.DataFrame)\n    assert result.index.equals(aligner.index)\n    assert result.columns.equals(expected_result.columns)\n    pd.testing.assert_frame_equal(result, expected_result)\n</code></pre></p>"},{"location":"simulator/performance/","title":"quantpylib.simulator.performance","text":""},{"location":"simulator/performance/#quantpylib.simulator.performance.performance_measures","title":"<code>performance_measures(r, w, periods_in_year=252, plot=False, path='./output')</code>","text":"<p>Calculate and visualize various performance measures of a trading strategy.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Series</code> <p>Time series of returns.</p> required <code>w</code> <code>DataFrame</code> <p>DataFrame of weights corresponding to each asset over time, with same index as r.</p> required <code>periods_in_year</code> <code>int</code> <p>Number of time periods in a year for the granularity of return series passed in. Defaults to 252, the number of trading days in a year.</p> <code>252</code> <code>plot</code> <code>bool</code> <p>Whether to generate and save plots. Defaults to True.</p> <code>False</code> <code>path</code> <code>str</code> <p>Path to save generated plots, if plot=True</p> <code>'./output'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various performance metrics:</p> <ul> <li>\"cum_ret\": Cumulative returns over time.</li> <li>\"log_ret\": Logarithmic returns.</li> <li>\"max_dd\": Maximum drawdown.</li> <li>\"1y_roll_dd\": One-year rolling drawdown.</li> <li>\"1y_roll_max_dd\": One-year rolling maximum drawdown.</li> <li>\"sortino\": Sortino ratio.</li> <li>\"sharpe\": Sharpe ratio.</li> <li>\"mean_ret\": Mean return per annum.</li> <li>\"median_ret\": Median return per annum.</li> <li>\"stdev_ret\": Standard deviation of returns per annum.</li> <li>\"var_ret\": Variance of returns per annum.</li> <li>\"skew_ret\": Skewness of returns.</li> <li>\"kurt_exc\": Excess kurtosis of returns.</li> <li>\"cagr\": Compound annual growth rate.</li> <li>\"3y_roll_cagr\": Three-year rolling compound annual growth rate.</li> <li>\"3y_roll_calmar\": Three-year rolling Calmar ratio.</li> <li>\"omega(0)\": Omega ratio.</li> <li>\"ulcer\": Ulcer index.</li> <li>\"VaR95\": Value at Risk at 95% confidence level.</li> <li>\"cVaR95\": Conditional Value at Risk at 95% confidence level.</li> <li>\"gain_to_pain\": Gain-to-pain ratio.</li> <li>\"w_summary\": Summary statistics of weights.</li> <li>\"directionality\": Market long bias directionality.</li> <li>\"parity_distance\": Distance from a 1/n equal weight portfolio.</li> </ul>"},{"location":"simulator/simulator/","title":"simulator","text":"<p>This page describes how you may use our <code>quantpylib.simulator</code> module and the functionalities exposed by our APIs. This module provides comprehensive backtesting functionality and statistical tools to analyse your own trading strategies. The core backtesting engine is made available via the <code>quantpylib.simulator.alpha</code> module's <code>Alpha</code> class, which leverages in-house statistical packages such as monte-carlo permutation hypothesis tests and performance metrics computation. This feature is further enhanced by our evaluator-parser in the <code>quantpylib.simulator.gene</code> module's <code>Gene</code> class, which is leveraged by the <code>GeneticAlpha</code> class to bring simple, efficient, accurate and no-code 'batteries-included' backtesting functionality.</p> <p>A high-level walkthrough of the individual quant packages are presented in this page. Comprehensive documentation may be found in the respective pages. To follow along, make sure you have installed the necessary dependencies. Code example scripts are also provided in the repo. Suppose we would like to test some trading strategy ideas, as well as run some tests and performance metrics on them. The trading strategies may be encoded via the succinct rules as follows: <pre><code>example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\"\nexample2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\" \nexample3=\"mac_50/100(close)\"\n</code></pre> <code>example1</code> tests for some intraday-effects, <code>example2</code> tests for mean-reversionary effects on risk-adjusted returns, and <code>example3</code> is a simple trend following strategy. The first two-examples are long-short market neutral strategies and third-example is a long-only strategy.</p>"},{"location":"simulator/simulator/#examples","title":"Examples","text":""},{"location":"simulator/simulator/#backtesting","title":"Backtesting","text":"<p>In this section we demonstrate how to run backtesting with <code>quantpylib.simulator.alpha</code>. We would need the following imports:</p> <p><pre><code>import pytz\nimport yfinance\nimport requests\nimport threading\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom bs4 import BeautifulSoup\nimport matplotlib.pyplot as plt \n\nfrom quantpylib.simulator.alpha import Alpha\nfrom quantpylib.simulator.gene import GeneticAlpha\n</code></pre> First, determine the universe of instruments you would like to trade. Take for instance, the SP500 universe. We would poll this from wikipedia and take the first 100 tickers polled, and then get their  historical OHLCV data from <code>yfinance</code>. We would like to test for a period from 1 Jan 2000 to the current date.</p> <p>We write some code to poll data from the free open-source <code>yfinance</code> library:</p>  Code for Polling OHLCV Data  <pre><code>def get_sp500_tickers():\n    res = requests.get(\"https://en.wikipedia.org/wiki/List_of_S%26P_500_companies\")\n    soup = BeautifulSoup(res.content,'html')\n    table = soup.find_all('table')[0] \n    df = pd.read_html(str(table))\n    tickers = list(df[0].Symbol)\n    return tickers\n\ndef get_history(ticker,period_start,period_end,granularity=\"1d\",tries=0):\n    try:\n        df = yfinance.Ticker(ticker).history(\n            start=period_start,\n            end=period_end,\n            interval=granularity,\n            auto_adjust=True\n        ).reset_index()\n    except Exception as err:\n        if tries &lt; 5:\n            return get_history(ticker,period_start,period_end,granularity,tries+1)\n        return pd.DataFrame()\n\n    df = df.rename(columns={\n        \"Date\":\"datetime\",\n        \"Open\":\"open\",\n        \"High\":\"high\",\n        \"Low\":\"low\",\n        \"Close\":\"close\",\n        \"Volume\":\"volume\"\n    })\n    if df.empty:\n        return pd.DataFrame()\n    df.datetime = pd.DatetimeIndex(df.datetime.dt.date).tz_localize(pytz.utc)\n    df = df.drop(columns=[\"Dividends\", \"Stock Splits\"])\n    df = df.set_index(\"datetime\",drop=True)\n    return df\n\ndef get_histories(tickers, period_starts,period_ends, granularity=\"1d\"):\n    dfs = [None]*len(tickers)\n    def _helper(i):\n        print(tickers[i])\n        df = get_history(\n            tickers[i],\n            period_starts[i], \n            period_ends[i], \n            granularity=granularity\n        )\n        dfs[i] = df\n    threads = [threading.Thread(target=_helper,args=(i,)) for i in range(len(tickers))]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n    tickers = [tickers[i] for i in range(len(tickers)) if not dfs[i].empty]\n    dfs = [df for df in dfs if not df.empty]\n    return tickers, dfs\n\ndef get_ticker_dfs(start,end,tickers):\n    starts=[start]*len(tickers)\n    ends=[end]*len(tickers)\n    tickers,dfs = get_histories(tickers,starts,ends,granularity=\"1d\")\n    ticker_dfs = {ticker:df for ticker,df in zip(tickers,dfs)}    \n    return tickers, ticker_dfs \n</code></pre> <p>We now want to use our <code>quantpylib.simulator.alpha.Alpha</code> class engine to drive our backtest simulations. We would have to implement the abstract methods to test out our trading strategy. The abstract methods are  <code>compute_signals</code>, <code>compute_forecasts</code>. The documentation also suggests that we may optionally implement  <code>instantiate_eligibilities_and_strat_variables</code> to refine our trading universe. </p> <p>Let's create a class for that  <pre><code>class Example1(Alpha):\n    async def compute_signals(self,index=None):\n        pass\n\n    def instantiate_eligibilities_and_strat_variables(self, eligiblesdf):\n        pass\n\n    def compute_forecasts(self, portfolio_i, dt, eligibles_row):\n        pass\n</code></pre></p> <p>Let us fill in the blanks to get a concrete implementation:</p> <pre><code>class Example1(Alpha):\n    async def compute_signals(self,index=None):\n        '''\n        ls_10/90(\n            mult(\n                div(\n                    minus(low,close),\n                    minus(high,low)\n                ),\n                div(open,close)\n            )\n        )\n        '''\n        alphas = []\n        for inst in self.instruments:\n            alpha = (self.dfs[inst].low - self.dfs[inst].close) \\\n                / (self.dfs[inst].high - self.dfs[inst].low ) \\\n                * (self.dfs[inst].open / self.dfs[inst].close)\n            alphas.append(alpha.replace([np.inf, -np.inf], np.nan))\n\n        alphadf = pd.concat(alphas, axis=1) #outer join, take the union of the different datetime indices\n        alphadf.columns = self.instruments\n        alphadf = pd.DataFrame(index=index).join(alphadf).ffill()\n        is_short = lambda x: x &lt; np.nanpercentile(x,10)\n        is_long = lambda x: x &gt; np.nanpercentile(x,90)\n        self.alphadf = alphadf.apply(lambda row: (-1*(0+is_short(row)))+(0+is_long(row)),axis=1)\n\n    def instantiate_eligibilities_and_strat_variables(self, eligiblesdf):\n        eligblesdf = eligiblesdf &amp; (~pd.isna(self.alphadf))\n        return eligblesdf\n\n    def compute_forecasts(self, portfolio_i, dt, eligibles_row):\n        forecast = self.alphadf.loc[dt]\n        return forecast\n</code></pre> <p>We notice that the alpha forecast is an array of values consisting of elements of <code>[-1,0,1]</code>, representing short, neutral and long positions respectively. It should be noted that this alpha forecast is not restricted to any set of discrete values, or magnitude - only the relative scale of the forecasts w.r.t other values in the array matter. Our <code>Alpha</code> backtesting engine automatically adjusts for the position sizing cross sectionally and across time through a combination of forecast size, instrument volatility and strategy volatility, using volatility targeting as risk control. The volatility targeted may be set by a (optional) parameter <code>portfolio_vol</code> to an instance of the <code>Alpha</code> class in the constructor. Now, we can call the <code>async</code> <code>run_simulation</code> method to get backtest results.</p> <p>The <code>Alpha</code> class takes in some parameters for our backtest strategy, including backtest date ranges, tickers and ticker data. Let's try to run our strategy now:</p> <p><pre><code>async def main():\n    example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\n    example2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\"\n    example3=\"mac_50/100(close)\"\n\n    period_start = datetime(2000,1,1, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = get_sp500_tickers()[:100]\n    tickers, ticker_dfs = get_ticker_dfs(start=period_start,end=period_end,tickers=tickers)\n    configs={\n        \"start\":period_start,\n        \"end\":period_end,\n        \"instruments\":tickers,\n        \"dfs\":ticker_dfs,\n    }\n\n    alpha1 = Example1(**configs)\n    df1 = await alpha1.run_simulation()\n    print(df1)\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())    \n</code></pre> We obtain an output in our console a dataframe consisting of the details of our backtest simulations: <pre><code>terminal value 1237397.022956312\n                           MMM units  AOS units    ABT units  ADBE units  AES units  AFL units  A units  ...  exec_penalty  comm_penalty  swap_penalty  cost_penalty  nominal_ret  capital_ret       capital\n2000-01-01 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-02 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-03 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-04 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n2000-01-05 00:00:00+00:00        0.0        0.0     0.000000    0.000000  -2.207572   8.323184      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.000000e+04\n...                              ...        ...          ...         ...        ...        ...      ...  ...           ...           ...           ...           ...          ...          ...           ...\n2024-02-02 00:00:00+00:00        0.0        0.0  2491.717072 -296.303782   0.000000   0.000000      0.0  ...           0.0           0.0          -0.0           0.0     0.004586     0.005435  1.235953e+06\n2024-02-03 00:00:00+00:00        0.0        0.0  2540.356454 -302.087758   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.235953e+06\n2024-02-04 00:00:00+00:00        0.0        0.0  2540.356454 -302.087758   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.235953e+06\n2024-02-05 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0          -0.0           0.0     0.001004     0.001168  1.237397e+06\n2024-02-06 00:00:00+00:00        0.0        0.0     0.000000    0.000000   0.000000   0.000000      0.0  ...           0.0           0.0           0.0           0.0     0.000000     0.000000  1.237397e+06\n</code></pre> From this dataframe, we are able to see our pnl, individual positions held, portfolio allocation, notional exposure, leverage, trading costs (swap/execution/commissions if defined) and more.</p>"},{"location":"simulator/simulator/#no-code-backtesting","title":"No-Code Backtesting","text":"<p>Continuing with our code from the Backtesting section, although all we had to do was to implement a couple or so abstract methods for signal computation and forecasts depending our strategy/formula, we want to take an even more hands-off approach and skip implementing the signal logic all together. A no-code solution gives us a more robust approach, as we may make errors in the implementation of the signal compute. For instance, since the division operator involved in the formula for <code>Example1</code> may cause <code>ZeroDivisionError</code>, without the line <code>alphas.append(alpha.replace([np.inf, -np.inf], np.nan))</code>, we would be making logical errors.</p> <p>The functionality to parse mathematical/formulaic strings and evaluate them is implemented in our <code>quantpylib.simulator.gene.Gene</code> class and made accessible as an <code>Alpha</code> instance via the <code>quantpylib.simulator.gene.GeneticAlpha</code> module. The <code>GeneticAlpha</code> class inherits from the <code>Alpha</code> class like <code>Example1</code>, but instead of having to implement the three functions, all the computation is done via an automatic evaluator and the abstract methods are implemented internally.</p> <p>The <code>GeneticAlpha</code> takes a <code>str</code> or <code>Gene</code> object in addition to the parameters in the <code>Alpha</code> object. The formulaic representation, syntax and primitives supported by our <code>Gene</code> parser is given here.</p> <p>Continuing from the previous code, <pre><code>async def main():\n\n    '''\n    ...\n    '''\n\n    _alpha1 = GeneticAlpha(genome=example1,**configs)\n    _df1 = await _alpha1.run_simulation()\n    print(_df1)\n\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3,**configs, portfolio_vol=0.10)\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    print(df2)    \n    print(df3)\n</code></pre> All three examples are well defined by our list-of-primitives and supported by our parser-evaluator, so we can get the backtest results without having to write logic code. We may plot their logarithmic wealth: <pre><code>    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> </p>"},{"location":"simulator/simulator/#crypto-currencies-fees-and-customization","title":"Crypto, Currencies, Fees and Customization","text":"<p>The <code>Alpha</code> library backtesting example from the Backtesting section used daily data, but it is capable of performing backtest logic on finer granularities and on weekends/holidays. If the trading intervals are finer than daily periods, it should also be specified whether trading is around the clock (24 hours, as in currency and crypto) or RTH (6.5 hours standard). This is to adjust the internal accounting for volatility and performance metric computation. Currently, hourly and daily granularities are supported. </p> <p>We may specify parameters such as the execution fees, commission fees, swap/funding rates, granularity period, portfolio volatility, positional inertia, availability of weekend and around-the-clock trading and starting capital.</p> <p>We shall demonstrate with examples. To aid us in the data retrieval, we will use our <code>quantpylib.datapoller</code> module. Although we can use <code>str</code> alias <code>d</code>, <code>h</code> to indicate daily and hourly granularities, for clarity, we use <code>quantpylib.standards.Period</code>.</p> <p>We will use the no-code backtesting discussed in the previous section for brevity, but all the changes apply to both <code>Alpha</code> and <code>GeneticAlpha</code> instances. We will need the following imports: <pre><code>import pytz\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\nfrom quantpylib.standards import Period\nfrom quantpylib.datapoller.master import DataPoller\nfrom quantpylib.simulator.gene import GeneticAlpha\n</code></pre> We instantiate the data poller with just the <code>binance</code> client: <pre><code>keys = {\"binance\": {}}\ndatapoller = DataPoller(config_keys=keys)\ninterval = Period.HOURLY\n\nasync def main():\n    #...examples as before\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> Let's set up the data and alpha formulas, which we also used to backtest equities: <pre><code>    example1=\"ls_10/90(mult(div(minus(low,close),minus(high,low)),div(open,close)))\"\n    example2=\"ls_10/90(neg(mean_5(csrank(div(logret_5(),volatility_12())))))\"\n    example3=\"mac_50/100(close)\"\n\n    period_start = datetime(2010,10,2, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = [\"BTCUSDT\",\"ETHUSDT\",\"SOLUSDT\"]\n    ticker_dfs = await asyncio.gather(*[datapoller.crypto.get_trade_bars(\n        ticker=ticker,\n        start=period_start,\n        end=period_end,\n        granularity=interval,\n        granularity_multiplier=1,\n        src=\"binance\"\n    ) for ticker in tickers])\n    dfs = {ticker:df for ticker,df in zip(tickers,ticker_dfs)}\n</code></pre> Even though the Binance API allows default of 500 and maximum of 1000 candles per request, our <code>DataPoller</code> gracefully strings together multiple requests and paces out the requests to get us the required interval data. The specifics of these should be referred to in the <code>quantpylib.datapoller</code> module.</p> <p>Let us make this fit to the crypto market configuratons and time intervals. We first examine zero-cost performance, specify 24/7 trading and use <code>Period.HOURLY</code> interval. Instead of specifying start and end backtest dates, we can actually let the <code>Alpha</code> engine guess these parameters from the range of the dataframes provided in <code>dfs</code>, if we want the maximum possible range. Other than specifying the config arguments differently, all other code remains the same. <pre><code>    configs={\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"execrates\": [0] * len(tickers),\n        \"longswps\": [0] * len(tickers),\n        \"shortswps\": [0] * len(tickers),\n        \"granularity\": interval,\n        \"around_the_clock\":True,\n        \"weekend_trading\":True\n    }\n\n    alpha1 = GeneticAlpha(genome=example1,**configs)\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3 ,**configs, portfolio_vol=0.10)\n    df1 = await alpha1.run_simulation()\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> We see that <code>alpha1</code> and <code>alpha2</code> performed reasonably in the crypto markets too. </p> <p>However, for a more realistic modelling, we would need to model the costs of transacting. In practice, we are also unlikely to fully rebalance to the optimal portfolio due to transaction costs. Let us try to take these into consideration. First, a reasonable execution fee is <code>0.0003</code> (this sits slightly higher than the maker-fees for trading USDT perpetuals on Binance for Regular User status). For simplicity, we assume a <code>10%</code> APR funding rate for  perps. To restrict constant rebalancing, we rebalance each position only when held position sits at distance greater than <code>20%</code> from its optimal position. Let's run a new config: <pre><code>    configs={\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"execrates\": [0.0003] * len(tickers),\n        \"longswps\": [0.1] * len(tickers), #annualized\n        \"shortswps\": [-0.1] * len(tickers),\n        \"granularity\": interval,\n        \"around_the_clock\":True,\n        \"weekend_trading\":True,\n        \"positional_inertia\": 0.20,\n    }\n\n    alpha1 = GeneticAlpha(genome=example1,**configs)\n    alpha2 = GeneticAlpha(genome=example2,**configs)\n    alpha3 = GeneticAlpha(genome=example3 ,**configs)\n    df1 = await alpha1.run_simulation()\n    df2 = await alpha2.run_simulation()\n    df3 = await alpha3.run_simulation()\n    plt.plot(np.log(df1.capital),label=\"1\")\n    plt.plot(np.log(df2.capital),label=\"2\")\n    plt.plot(np.log(df3.capital),label=\"3\")\n    plt.legend()\n    plt.show()\n</code></pre> We see that with exception of the trend-following model, the other two alphas are abysmal under the consideration of costs. This is because the trend-following model has a signal that innately rebalances slower. To reduce costs, we need to employ one or more of (i) finding slower updating alpha forecasts, (ii) increase inertia to trade, (iii) improve the actual execution model, or (iv) trade on larger timeframes. This of course must be performed relative to the EV of the position rebalanced to. </p>  As of date, the starting capital specified does not affect the strategy returns. We are looking for contribution on incorporation of impact and reality modelling extensions in relation to transacted size, for a more advanced backtest approach and institutional size."},{"location":"simulator/simulator/#performance-metrics-and-hypothesis-tests","title":"Performance Metrics and Hypothesis Tests","text":"<p>Our batteries-included feature gives us an access to powerful statistical tools to evaluate our trading strategy with a simple function call. This is supported by any <code>BaseAlpha</code> instance, which is indeed sufficed by both <code>Alpha</code> and <code>GeneticAlpha</code> instances.</p> <p><pre><code>async def main():\n\n    '''\n    ...\n    '''\n    print(alpha1.get_performance_measures())\n    print(await alpha1.hypothesis_tests())\n\n    print(_alpha1.get_performance_measures())\n    print(await _alpha1.hypothesis_tests())\n</code></pre> We get access to a wide array of performance measures, including sharpe ratio, sortino ratio, cagr, rolling-cagr, drawdown, VaR and more. The full list should be referenced here. We also get access to monte-carlo permutation hypothesis tests for asset picking, asset timing and overall decision making skills in the trading strategy.</p>"},{"location":"simulator/simulator/#regression-analysis","title":"Regression Analysis","text":"<p>In the no-code backtesting, we used <code>quantpylib.simulator.gene.Gene</code> class functionalities for parsing mathematical/formulaic strings and evaluating them to perform backtest simulations. This parser-evaluator can also be leveraged to provide extremely simple interfaces for powering  regression analysis, as in common-practice in the R, S-like languages. Any regression model involving variables supported by the list-of-primitives can be used. <code>quantpylib.simulator.models</code> features an abstraction layer written on top of this <code>Gene</code> class and <code>statsmodels</code> to perform no-code regression analysis using simple string specifications.</p> <p>An example scenario for quantitative analysis is a momentum study on the impact of normalized  returns on forward one-period daily returns. <pre><code>forward_1(logret_1()) ~ div(logret_25(),volatility_25())\n</code></pre> Let us take the following setup: <pre><code>import pytz\nfrom datetime import datetime\n\nfrom quantpylib.standards import Period\nfrom quantpylib.datapoller.master import DataPoller\nfrom quantpylib.simulator.models import GeneticRegression\n\nkeys = {\"binance\":{}}\ndatapoller = DataPoller(config_keys=keys)\ninterval = Period.DAILY\n\nasync def main():\n    pass\n    #code here\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> We will use our datapoller and run regression tests on some of the 10-biggest coins, using daily intervals and taking data from 2010: <pre><code>    period_start = datetime(2010,1,1, tzinfo=pytz.utc)\n    period_end = datetime.now(pytz.utc)\n    tickers = [\"BTCUSDT\",\"ETHUSDT\",\"BNBUSDT\",\"SOLUSDT\",\"XRPUSDT\",\"DOGEUSDT\",\"ADAUSDT\",\"DOTUSDT\",\"LINKUSDT\",\"MATICUSDT\"]\n    ticker_dfs = await asyncio.gather(*[datapoller.crypto.get_trade_bars(\n        ticker=ticker,\n        start=period_start,\n        end=period_end,\n        granularity=interval,\n        src=\"binance\"\n    ) for ticker in tickers])\n    dfs = {ticker:df for ticker,df in zip(tickers,ticker_dfs)}\n    configs = {\n        \"dfs\":dfs,\n        \"instruments\":tickers,\n        \"granularity\":interval\n    }\n</code></pre> Since each of the regressors are valid formulas under the list-of-primitives,  we can specify a regression formula and pass it into <code>GeneticRegression</code>: <pre><code>    model = GeneticRegression(\n        formula=\"forward_1(logret_1()) ~ div(logret_25(),volatility_25())\",\n        **configs\n    )\n</code></pre> We will map the formula into blocks, each block being a variable in the regression model: <pre><code>print(model.blockmap) #{'b0': 'forward_1(logret_1())', 'b1': 'div(logret_25(),volatility_25())'}\nprint(model.smf) #b0~b1\nres = model.ols() #statsmodels.regression.linear_model.RegressionResults\nprint(res.summary()) \n</code></pre> The regression output is as follows: <pre><code>                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                     b0   R-squared:                       0.001\nModel:                            OLS   Adj. R-squared:                  0.001\nMethod:                 Least Squares   F-statistic:                     28.11\nDate:                Wed, 01 May 2024   Prob (F-statistic):           1.16e-07\nTime:                        16:48:36   Log-Likelihood:                 28193.\nNo. Observations:               19648   AIC:                        -5.638e+04\nDf Residuals:                   19646   BIC:                        -5.637e+04\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      0.0011      0.000      2.567      0.010       0.000       0.002\nb1             0.0004   7.73e-05      5.301      0.000       0.000       0.001\n==============================================================================\nOmnibus:                     8766.454   Durbin-Watson:                   1.010\nProb(Omnibus):                  0.000   Jarque-Bera (JB):          1610674.284\nSkew:                           1.041   Prob(JB):                         0.00\nKurtosis:                      47.307   Cond. No.                         5.37\n==============================================================================\n</code></pre> The regression results suggest that twenty-five day volatility adjusted returns is statistically significant predictor for forward returns. We may obtain graphs such as fit, confidence intervals, leverage plots, influence plots, PRP and CCPR. Here are some fits:</p> <p></p> <p>and a leverage plot:</p> <p></p> <p>We see that the although we had strong outliers in the standardized residuals, those with extreme residuals tended to have lower leverage values w.r.t the regressor variable hull. We had 19648 observations for the regression, hence the influence plots and other diagnostics may be difficult to interpret. Also, the leverage values indicate how much the model fit depends on these outlier points, but we would like to see for ourself how the models perform when extremes are smoothed/muted out.</p> <p>We also want to create more interpretive analysis and plots. The <code>ols</code> method takes in the number of bins, the block identifier to bin by, bin-method and aggregating method. By default, the binning is done on the response variable axis <code>b0</code>, and binned by equal observation-cardinality intervals. The aggregator defaults to the 0.05-quantile-winsorized-means on both tails, to mute tails common in market contexts. </p> <p>For our sceneario, let us take 100 bins over the <code>b1</code> axis, which is our normalized returns, and take the remaining default options. <pre><code>    res = model.ols(bins=100,bin_block=\"b1\")\n    print(res.summary())\n    model.plot()\n</code></pre> This is our regression summary: <pre><code>                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                     b0   R-squared:                       0.184\nModel:                            OLS   Adj. R-squared:                  0.176\nMethod:                 Least Squares   F-statistic:                     22.11\nDate:                Wed, 01 May 2024   Prob (F-statistic):           8.45e-06\nTime:                        18:03:49   Log-Likelihood:                 418.85\nNo. Observations:                 100   AIC:                            -833.7\nDf Residuals:                      98   BIC:                            -828.5\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      0.0008      0.000      2.259      0.026       0.000       0.002\nb1             0.0003   6.98e-05      4.702      0.000       0.000       0.000\n==============================================================================\nOmnibus:                        4.233   Durbin-Watson:                   1.528\nProb(Omnibus):                  0.120   Jarque-Bera (JB):                4.101\nSkew:                           0.444   Prob(JB):                        0.129\nKurtosis:                       2.559   Cond. No.                         5.36\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n</code></pre> and we get much more interpretive plots:  </p> <p>and all regression studies suggest that momentum exists in cryptocurrency returns over daily timescales. Of course, since the data has been transformed, the interpretation of the regression results and analysis needs to be adjusted in relation to the binning and aggregation techniques employed.</p> <p>The library also supports methods to study multivariable regression, as in the <code>statsmodels</code> package, as well as convenience methods to obtain diagnostics for common issues such as multicollinearity concerns with statistics like condition number and variance-inflation-factors.</p>"},{"location":"simulator/simulator/#simulatoralpha","title":"simulator.alpha","text":""},{"location":"simulator/simulator/#simulatorgene","title":"simulator.gene","text":""},{"location":"simulator/simulator/#simulatormodels","title":"simulator.models","text":""},{"location":"simulator/simulator/#simulatoroperators","title":"simulator.operators","text":""},{"location":"simulator/simulator/#simulatorperformance","title":"simulator.performance","text":""},{"location":"standards/intervals/","title":"quantpylib.standards.intervals","text":"<p>Repo standards for time period intervals.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration representing different time periods for supported data granularity.</p> <p>Attributes:</p> Name Type Description <code>SECOND</code> <p>Represents a second. Value <code>s</code>.</p> <code>MINUTE</code> <p>Represents a minute. Value <code>m</code>.</p> <code>HOURLY</code> <p>Represents an hour. Value <code>h</code>.</p> <code>DAILY</code> <p>Represents a day. Value <code>d</code>.</p> <code>WEEKLY</code> <p>Represents a week. Value <code>w</code>.</p> <code>MONTHLY</code> <p>Represents a month. Value <code>M</code>.</p> <code>YEARLY</code> <p>Represents a year. Value <code>y</code>.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.get_span","title":"<code>get_span(granularity, granularity_multiplier, period_start=None, period_end=None, periods=None)</code>","text":"<p>Get the time span based on the specified granularity and parameters. granularity, granularity_multipler and periods determine the span duration, if provided.</p> <p>Parameters:</p> Name Type Description Default <code>granularity</code> <code>Period</code> <p>The granularity of time period.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The multiplier for the granularity.</p> required <code>period_start</code> <code>datetime</code> <p>The start of the time period. Defaults to None.</p> <code>None</code> <code>period_end</code> <code>datetime</code> <p>The end of the time period. Defaults to None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the (start,end) of timespan.</p> <p>Raises:</p> Type Description <code>InvalidPeriodConfig</code> <p>If the period configuration is invalid.</p> <code>AssertionError</code> <p>If the provided parameters are invalid.</p>"},{"location":"standards/intervals/#quantpylib.standards.intervals.map_granularity_to_relativedelta","title":"<code>map_granularity_to_relativedelta(granularity, periods)</code>","text":"<p>Map granularity and number of periods to <code>dateutil.relativedelta.relativedelta</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>granularity</code> <code>Period</code> <p>The granularity of time period.</p> required <code>periods</code> <code>int</code> <p>The number of periods.</p> required <p>Returns:</p> Name Type Description <code>relativedelta</code> <p>Relative delta representing the time period.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the granularity is not a supported type.</p>"},{"location":"standards/markets/","title":"quantpylib.standards.markets","text":"<p>Repo standards relating to markets.</p>"},{"location":"standards/markets/#trading-system-constants","title":"Trading System Constants","text":"<p>This module defines various constants used throughout the trading system. These constants are used for defining fields in transaction records, account details, order types, and more.</p>"},{"location":"standards/markets/#general-constants","title":"General Constants","text":"<ul> <li><code>TIMESTAMP</code> (int): \"timestamp\"</li> <li><code>TICKER</code> (str): \"ticker\"</li> <li><code>AMOUNT</code> (Decimal): \"amount\"</li> <li><code>PRICE</code> (float): \"price\"</li> <li><code>ENTRY</code> (Decimal): \"entry\"</li> <li><code>LEVERAGE</code> (float): \"leverage\"</li> <li><code>LIQUIDATION</code> (float): \"liquidation\"</li> <li><code>MARGIN</code> (float): \"margin\"</li> <li><code>VALUE</code> (Decimal): \"value\"</li> <li><code>REALIZED_PNL</code> (float): \"realized_pnl\"</li> <li><code>UNREALIZED_PNL</code> (float): \"unrealized_pnl\"</li> </ul>"},{"location":"standards/markets/#account-constants","title":"Account Constants","text":"<ul> <li><code>ACCOUNT_EQUITY</code> (float): \"equity_total\"</li> <li><code>ACCOUNT_WITHDRAWABLE</code> (float): \"equity_withdrawable\"</li> <li><code>ACCOUNT_NOTIONAL_POS</code> (float): \"notional_position\"</li> <li><code>MARGIN_MAINTENANCE</code> (float): \"margin_maintenance\"</li> <li><code>MARGIN_TOTAL</code> (float): \"margin_total\"</li> </ul>"},{"location":"standards/markets/#order-constants","title":"Order Constants","text":"<ul> <li><code>LIMIT_PRICE</code> (float): \"limit_price\"</li> <li><code>ORDER_ID</code> (str): \"order_id\"</li> <li><code>ORDER_TAG</code> (str): \"order_tag\"</li> <li><code>ORDER_TOFILL</code> (Decimal): \"amount_left\"</li> <li><code>ORDER_AMOUNT</code> (Decimal): \"amount_total\"</li> </ul>"},{"location":"standards/markets/#order-types","title":"Order Types","text":"<ul> <li><code>ORDER_TYPE</code> (str): \"order_type\"</li> <li><code>ORDER_TYPE_MARKET</code> (str): \"market\"</li> <li><code>ORDER_TYPE_LIMIT</code> (str): \"limit\"</li> <li><code>ORDER_TYPE_STOP_MARKET</code> (str): \"stop_market\"</li> <li><code>ORDER_TYPE_STOP_LIMIT</code> (str): \"stop_limit\"</li> <li><code>ORDER_TYPE_TWAP</code> (str): \"twap\"</li> </ul>"},{"location":"standards/markets/#price-match-types","title":"Price Match Types","text":"<ul> <li><code>PRICE_MATCH_OPPONENT_1</code> (str): \"OPPONENT\"</li> <li><code>PRICE_MATCH_OPPONENT_5</code> (str): \"OPPONENT_5\"</li> <li><code>PRICE_MATCH_OPPONENT_10</code> (str): \"OPPONENT_10\"</li> <li><code>PRICE_MATCH_OPPONENT_20</code> (str): \"OPPONENT_20\"</li> <li><code>PRICE_MATCH_QUEUE_1</code> (str): \"QUEUE\"</li> <li><code>PRICE_MATCH_QUEUE_5</code> (str): \"QUEUE_5\"</li> <li><code>PRICE_MATCH_QUEUE_10</code> (str): \"QUEUE_10\"</li> <li><code>PRICE_MATCH_QUEUE_20</code> (str): \"QUEUE_20\"</li> </ul>"},{"location":"standards/markets/#time-in-force-constants","title":"Time In Force Constants","text":"<ul> <li><code>TIME_IN_FORCE</code> (str): \"tif\"</li> <li><code>TIME_IN_FORCE_GTC</code> (str): 'GTC'</li> <li><code>TIME_IN_FORCE_IOC</code> (str): 'IOC'</li> <li><code>TIME_IN_FORCE_FOK</code> (str): 'FOK'</li> <li><code>TIME_IN_FORCE_GTD</code> (str): 'GTD'</li> <li><code>TIME_IN_FORCE_MOC</code> (str): 'MOC'</li> <li><code>TIME_IN_FORCE_MOO</code> (str): 'MOO'</li> <li><code>TIME_IN_FORCE_ALO</code> (str): \"ALO\"</li> </ul>"},{"location":"standards/markets/#contract-constants","title":"Contract Constants","text":"<ul> <li><code>SYMBOL_MIN_QTY</code> (Decimal): \"min_qty\"</li> <li><code>SYMBOL_PRICE_PRECISION</code> (int): \"price_precision\"</li> <li><code>SYMBOL_QUOTE_PRECISION</code> (int): \"quote_precision\"</li> <li><code>SYMBOL_QUANTITY_PRECISION</code> (int): \"quantity_precision\"</li> <li><code>SYMBOL_MIN_NOTIONAL</code> (float): \"min_notional\"</li> </ul>"},{"location":"standards/portfolio/","title":"quantpylib.standards.portfolio","text":""},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Order","title":"<code>Order</code>","text":""},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Order.__init__","title":"<code>__init__(exc=None, oid=None, cloid=None, ticker=None, amount=None, price=None, price_match=None, tif=None, ord_type=None, reduce_only=None, tp=None, sl=None, ord_status=None, filled_sz=Decimal('0'), last_fill_sz=None, timestamp=_time(units='ms'), **kwargs)</code>","text":"<p>Initialize an Order object.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>str</code> <p>Alias for the exchange client.</p> <code>None</code> <code>oid</code> <code>str</code> <p>The order id. Defaults to None.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>The client order id. Defaults to None.</p> <code>None</code> <code>ticker</code> <code>str</code> <p>The ticker symbol. Defaults to None.</p> <code>None</code> <code>amount</code> <code>Decimal</code> <p>The quantity of contracts. Defaults to None.</p> <code>None</code> <code>price</code> <code>Decimal</code> <p>The price of the order. Defaults to None.</p> <code>None</code> <code>price_match</code> <code>Decimal</code> <p>The price of the order that was matched. Defaults to None.</p> <code>None</code> <code>tif</code> <code>str</code> <p>The time in force. Defaults to None.</p> <code>None</code> <code>ord_type</code> <code>str</code> <p>The order type. Defaults to None.</p> <code>None</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order is a reduce-only order. Defaults to None.</p> <code>None</code> <code>tp</code> <code>Decimal</code> <p>The take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>Decimal</code> <p>The stop loss price. Defaults to None.</p> <code>None</code> <code>ord_status</code> <code>str</code> <p>The order status. Defaults to None.</p> <code>None</code> <code>filled_sz</code> <code>Decimal</code> <p>The filled size. Defaults to Decimal('0').</p> <code>Decimal('0')</code> <code>last_fill_sz</code> <code>Decimal</code> <p>The last filled size. Defaults to None.</p> <code>None</code> <code>timestamp</code> <code>int</code> <p>The timestamp of the order. Defaults to _time(units='ms').</p> <code>_time(units='ms')</code>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Order.as_dict","title":"<code>as_dict(test=False)</code>","text":"<p>Convert the Order object to a dictionary.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Order.is_alive","title":"<code>is_alive()</code>","text":"<p>Check if the order is alive.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders","title":"<code>Orders</code>","text":""},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.__init__","title":"<code>__init__(orders=None, delta_handlers=None, default_args=None)</code>","text":"<p>Initialize an Orders object.</p> <p>Parameters:</p> Name Type Description Default <code>orders</code> <code>list</code> <p>The list of orders. Defaults to None.</p> <code>None</code> <code>delta_handlers</code> <code>list</code> <p>List of coroutine handlers for order updates. Defaults to None.</p> <code>None</code> <code>default_args</code> <code>dict</code> <p>Default arguments for orders. Defaults to None.</p> <code>None</code>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.as_dict","title":"<code>as_dict(test=False)</code>","text":"<p>Convert the Orders object to a dictionary where oid is known.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.as_list","title":"<code>as_list(test=False)</code>","text":"<p>Convert the Orders object to a list.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.ask_level_exists","title":"<code>ask_level_exists(ticker, price)</code>","text":"<p>Check if an ask level exists.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>price</code> <code>Decimal</code> <p>The price level.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.bid_level_exists","title":"<code>bid_level_exists(ticker, price)</code>","text":"<p>Check if a bid level exists.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>price</code> <code>Decimal</code> <p>The price level.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.cloid_query","title":"<code>cloid_query(cloid)</code>","text":"<p>Get the order by client order id.</p> <p>Parameters:</p> Name Type Description Default <code>cloid</code> <code>str</code> <p>The client order id.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.get_ask_orders","title":"<code>get_ask_orders(ticker, sort=True, include_pending=True, copy=True, as_dict=False, test=False)</code>","text":"<p>Get the ask orders for a ticker sorted with head of list being closest to top of book</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.get_bid_orders","title":"<code>get_bid_orders(ticker, sort=True, include_pending=True, copy=True, as_dict=False, test=False)</code>","text":"<p>Get the bid orders for a ticker sorted with head of list being closest to top of book</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.get_orders","title":"<code>get_orders(ticker=None, copy=True)</code>","text":"<p>Get the snapshot of alive orders.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.get_total_ask_amount","title":"<code>get_total_ask_amount(ticker, include_pending=True)</code>","text":"<p>Get the total ask amount for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.get_total_bid_amount","title":"<code>get_total_bid_amount(ticker, include_pending=True)</code>","text":"<p>Get the total bid amount for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.oid_query","title":"<code>oid_query(oid)</code>","text":"<p>Get the order by order id.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>str</code> <p>The order id.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.pending_asks","title":"<code>pending_asks(ticker)</code>","text":"<p>Get the pending ask orders for a ticker sorted with head of list being closest to top of book</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Orders.pending_bids","title":"<code>pending_bids(ticker)</code>","text":"<p>Get the pending bid orders for a ticker sorted with head of list being closest to top of book</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Position","title":"<code>Position</code>","text":""},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Position.__init__","title":"<code>__init__(ticker, amount, entry, **kwargs)</code>","text":"<p>Initialize a Position object.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>amount</code> <code>Decimal</code> <p>The quantity of contracts.</p> required <code>entry</code> <code>Decimal</code> <p>The entry price.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Position.as_dict","title":"<code>as_dict()</code>","text":"<p>Convert the Position object to a dictionary.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Position.get_amount","title":"<code>get_amount()</code>","text":"<p>Get the signed size of position held.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Position.get_entry","title":"<code>get_entry()</code>","text":"<p>Get the entry price.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions","title":"<code>Positions</code>","text":""},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.__init__","title":"<code>__init__(positions=None, delta_handlers=None, default_args=None)</code>","text":"<p>Initialize a Positions object.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>dict</code> <p>The dictionary of positions. Defaults to None.</p> <code>None</code> <code>delta_handlers</code> <code>list</code> <p>List of coroutine handlers for position updates. Defaults to None.</p> <code>None</code>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.add_delta_handler","title":"<code>add_delta_handler(handler)</code>","text":"<p>Add a handler for position updates.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>The handler for position updates.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.add_positions","title":"<code>add_positions(pos_dict, reset=True)</code>","text":"<p>Add a dictionary of positions.</p> <p>Parameters:</p> Name Type Description Default <code>pos_dict</code> <code>dict</code> <p>The dictionary of positions.</p> required <code>reset</code> <code>bool</code> <p>Whether to reset the current positions. Defaults to True.</p> <code>True</code>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.as_dict","title":"<code>as_dict()</code>","text":"<p>Convert the Positions object to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The dictionary of positions.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.as_list","title":"<code>as_list()</code>","text":"<p>Convert the Positions object to a list.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of positions.</p>"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.get_ticker_amount","title":"<code>get_ticker_amount(ticker)</code>","text":"<p>Get the signed size of a position.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.get_ticker_position","title":"<code>get_ticker_position(ticker)</code>","text":"<p>Get the position object of a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required"},{"location":"standards/portfolio/#quantpylib.standards.portfolio.Positions.update_position","title":"<code>update_position(ticker, amount=None, fill_amount=None, entry=None, fill_entry=None, **kwargs)</code>  <code>async</code>","text":"<p>Update a position and broadcast the change to the delta handlers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>amount</code> <code>Decimal</code> <p>The new position size. Defaults to None.</p> <code>None</code> <code>fill_amount</code> <code>Decimal</code> <p>The filled size. Defaults to None.</p> <code>None</code> <code>entry</code> <code>Decimal</code> <p>The new entry price. Defaults to None.</p> <code>None</code> <code>fill_entry</code> <code>Decimal</code> <p>The filled entry price. Defaults to None.</p> <code>None</code>"},{"location":"standards/standards/","title":"quantpylib.standards","text":"<p>Repo standards and constants.</p>"},{"location":"throttler/aiohttp/","title":"quantpylib.throttler.aiohttp","text":""},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.NetworkException","title":"<code>NetworkException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception class for network errors, capturing the status code, error message, function name, and class name.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>str</code> <p>The HTTP status code of the error. Defaults to an empty string.</p> <code>''</code> <code>message</code> <code>str</code> <p>The error message. Defaults to 'Network error occurred'.</p> <code>'Network error occurred'</code> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>str</code> <p>The HTTP status code of the error.</p> <code>message</code> <code>str</code> <p>The error message.</p> <code>function_name</code> <code>str</code> <p>The name of the function where the error occurred.</p> <code>class_name</code> <code>str</code> <p>The name of the class where the error occurred.</p> <code>descriptive_message</code> <code>str</code> <p>The complete error message including function and class name.</p>"},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.asession_requests_get","title":"<code>asession_requests_get(urls, asemaphore=None, costs=None, refunds_in=None)</code>  <code>async</code>","text":"<p>Perform asynchronous HTTP GET requests.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>A list of URLs to request.</p> required <code>asemaphore</code> <code>AsyncRateSemaphore</code> <p>An asynchronous semaphore to limit concurrent requests. Defaults to None.</p> <code>None</code> <code>costs</code> <code>list</code> <p>A list of costs for each request in terms of semaphore credits. Defaults to None.</p> <code>None</code> <code>refunds_in</code> <code>list</code> <p>A list of refund times for each request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of responses, with exceptions if any occurred.</p> <p>Raises:</p> Type Description <code>NetworkException</code> <p>If a request fails with a non-200 status code.</p>"},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.asession_requests_post","title":"<code>asession_requests_post(urls, payloads, asemaphore=None, costs=None, refunds_in=None)</code>  <code>async</code>","text":"<p>Perform asynchronous HTTP POST requests.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>A list of URLs to request.</p> required <code>payloads</code> <code>list</code> <p>A list of payloads to send in the POST requests.</p> required <code>asemaphore</code> <code>AsyncRateSemaphore</code> <p>An asynchronous semaphore to limit concurrent requests. Defaults to None.</p> <code>None</code> <code>costs</code> <code>list</code> <p>A list of costs for each request in terms of semaphore credits. Defaults to None.</p> <code>None</code> <code>refunds_in</code> <code>list</code> <p>A list of refund times for each request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of responses, with exceptions if any occurred.</p> <p>Raises:</p> Type Description <code>NetworkException</code> <p>If a request fails with a non-200 status code.</p>"},{"location":"throttler/aiohttp/#quantpylib.throttler.aiohttp.request","title":"<code>request(**request_args)</code>  <code>async</code>","text":"<p>Perform an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>request_args</code> <code>dict</code> <p>A dictionary of request arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response JSON.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the request fails with a non-200 status code.</p>"},{"location":"throttler/aiosonic/","title":"quantpylib.throttler.aiosonic","text":""},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>An asynchronous HTTP aiosonic client for fast network requests and (de)serialization  of data packets. Automatic retries and error handling.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for all requests. Defaults to an empty string.</p> <code>''</code> <code>json_decoder</code> <code>callable</code> <p>The JSON decoder function to use. Defaults to <code>orjson.loads</code>.</p> <code>loads</code>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Clean up the HTTP client session, ensuring proper resource deallocation.</p> <p>Returns:</p> Type Description <p>None</p>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.handler","title":"<code>handler(response, cargs={})</code>  <code>async</code>","text":"<p>Handle the HTTP response, returning the JSON-decoded content or raising an HTTPException on error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>HTTPResponse</code> <p>The HTTP response object to handle.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON-decoded response if the status code is less than 400.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/aiosonic/#quantpylib.throttler.aiosonic.HTTPClient.request","title":"<code>request(url='', endpoint='', method='GET', headers={'content-type': 'application/json'}, params=None, data=None, return_exceptions=False, aiohttp_fallback=False, retries=2)</code>  <code>async</code>","text":"<p>Make an HTTP request and handle retries on failure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The full URL for the request. If not provided, <code>base_url</code> + <code>endpoint</code> is used. Defaults to an empty string.</p> <code>''</code> <code>endpoint</code> <code>str</code> <p>The endpoint to append to the base URL. Defaults to an empty string.</p> <code>''</code> <code>method</code> <code>str</code> <p>The HTTP method to use. Defaults to 'GET'.</p> <code>'GET'</code> <code>headers</code> <code>dict</code> <p>The headers to include in the request. Defaults to {\"content-type\": \"application/json\"}.</p> <code>{'content-type': 'application/json'}</code> <code>params</code> <code>dict</code> <p>The URL parameters to include in the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict or str</code> <p>The data to include in the request body. Defaults to None.</p> <code>None</code> <code>return_exceptions</code> <code>bool</code> <p>Whether to return exceptions instead of raising them. Defaults to False. No retries if True.</p> <code>False</code> <code>retries</code> <code>int</code> <p>The number of retries if the request fails. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The parsed JSON response if the request is successful.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/decorators/","title":"quantpylib.throttler.decorators","text":"<p>Examples for both decorator usage, and synchronous, asynchronous semaphores are given here.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.aconsume_credits","title":"<code>aconsume_credits(_func=None, *, costs, refund_in, attrname='rate_semaphore', timeout=0, verbose=False)</code>","text":"<p>Decorator to wrap an asynchronous instance-level coroutine as an asynchronous transaction within a rate-limited semaphore. The return value is the return value of the decorated coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>coroutine</code> <p>The asynchronous coroutine to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the AsyncRateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>timeout</code> <code>float</code> <p>The maximum time in seconds to wait for the transaction to complete. Defaults to 0, which waits indefinitely.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>False</code> <p>Returns:</p> Type Description <code>any</code> <p>The return value of the decorated coroutine.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p> <code>TimeoutError</code> <p>If wrapped transaction takes longer than the specified timeout.</p> Notes <p>For a timed-out transaction that does not get a chance to run due to it sitting  behind other transactions that are opportunistically processed,  a <code>RuntimeWarning: Enable tracemalloc to get the object allocation traceback</code>  may be seen together with the <code>asyncio.TimeoutError</code>. This is because the transaction  contains the coroutine, and the transact is wrapped in an asyncio <code>task</code>.  If it is unable to enter the semaphore by timeout,  the coroutine is never awaited and complains when garbage collected.  If the timeout occurs after the coroutine has acquired the semaphore,  this warning will not be seen but the <code>asyncio.TimeoutError</code> will still  be thrown.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.consume_credits","title":"<code>consume_credits(_func=None, *, costs, refund_in, attrname='rate_semaphore', verbose=False)</code>","text":"<p>Decorator to wrap an synchronous instance-level method as an synchronous transaction within a rate-limited semaphore. The return value is the return value of the decorated method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>callable</code> <p>The method to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the RateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>False</code> <p>Returns:</p> Type Description <code>any</code> <p>The return value of the decorated method.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p>"},{"location":"throttler/decorators/#quantpylib.throttler.decorators.wrap_in_thread","title":"<code>wrap_in_thread(_func=None, *, costs, refund_in, attrname='rate_semaphore', daemon=False, verbose=True)</code>","text":"<p>Decorator to wrap a synchronous instance-level method into a transaction, and that transaction into a thread.  The return value is a thread, that is not yet alive, and can be activated by invoking the  <code>threading.Thread.start</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>callable</code> <p>The function to be wrapped.</p> <code>None</code> <code>costs</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_in</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>attrname</code> <code>str</code> <p>The attribute name to access the RateSemaphore belonging to the object instance. Defaults to \"rate_semaphore\".</p> <code>'rate_semaphore'</code> <code>daemon</code> <code>bool</code> <p>Whether the thread should be a daemon thread. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Thread</code> <p>The thread with the transaction as target function, where the transaction wraps the decorated function. Not yet alive.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the instance does not have the specified attribute or if costs is less than 0.</p>"},{"location":"throttler/httpx/","title":"quantpylib.throttler.httpx","text":""},{"location":"throttler/httpx/#quantpylib.throttler.aiosonic.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>An asynchronous HTTP aiosonic client for fast network requests and (de)serialization  of data packets. Automatic retries and error handling.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for all requests. Defaults to an empty string.</p> <code>''</code> <code>json_decoder</code> <code>callable</code> <p>The JSON decoder function to use. Defaults to <code>orjson.loads</code>.</p> <code>loads</code>"},{"location":"throttler/httpx/#quantpylib.throttler.aiosonic.HTTPClient.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Clean up the HTTP client session, ensuring proper resource deallocation.</p> <p>Returns:</p> Type Description <p>None</p>"},{"location":"throttler/httpx/#quantpylib.throttler.aiosonic.HTTPClient.handler","title":"<code>handler(response, cargs={})</code>  <code>async</code>","text":"<p>Handle the HTTP response, returning the JSON-decoded content or raising an HTTPException on error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>HTTPResponse</code> <p>The HTTP response object to handle.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON-decoded response if the status code is less than 400.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/httpx/#quantpylib.throttler.aiosonic.HTTPClient.request","title":"<code>request(url='', endpoint='', method='GET', headers={'content-type': 'application/json'}, params=None, data=None, return_exceptions=False, aiohttp_fallback=False, retries=2)</code>  <code>async</code>","text":"<p>Make an HTTP request and handle retries on failure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The full URL for the request. If not provided, <code>base_url</code> + <code>endpoint</code> is used. Defaults to an empty string.</p> <code>''</code> <code>endpoint</code> <code>str</code> <p>The endpoint to append to the base URL. Defaults to an empty string.</p> <code>''</code> <code>method</code> <code>str</code> <p>The HTTP method to use. Defaults to 'GET'.</p> <code>'GET'</code> <code>headers</code> <code>dict</code> <p>The headers to include in the request. Defaults to {\"content-type\": \"application/json\"}.</p> <code>{'content-type': 'application/json'}</code> <code>params</code> <code>dict</code> <p>The URL parameters to include in the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict or str</code> <p>The data to include in the request body. Defaults to None.</p> <code>None</code> <code>return_exceptions</code> <code>bool</code> <p>Whether to return exceptions instead of raising them. Defaults to False. No retries if True.</p> <code>False</code> <code>retries</code> <code>int</code> <p>The number of retries if the request fails. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The parsed JSON response if the request is successful.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the response status code is 400 or higher.</p>"},{"location":"throttler/rate_semaphore/","title":"quantpylib.throttler.rate_semaphore","text":"<p><code>quantpylib.throttler.rate_semaphore</code> is our core rate-limiting and throttling module, and exposes two synchronization tools, the  <code>quantpylib.throttler.rate_semaphore.AsyncRateSemaphore</code> and <code>quantpylib.throttler.rate_semaphore.RateSemaphore</code> classes.</p> <p>Instead of having to write server-dependent code on rate-limiting based on error messages and response headers (say, of a HTTP 429 response), the rate-semaphores make rate-limiting on the client side seamless and easy  by wrapping native Python objects and synchronization primitives. Any Python  function can be rate-limited (with <code>RateSemaphore</code>) and any Python coroutine  can be rate-limited (with <code>AsyncRateSemaphore</code>) by submitting transactions to the semaphores through the <code>transact</code> method. The module is flexible enough to handle both fixed-cost endpoints (specs such as '20 API requests/min') or  variable-cost endpoints (specs such as `5 API credits/getTick', '15 API credits/getOHLCV' with '100 credits/min per client').</p> <p>Users would likely only have to interact with the <code>transact</code> method in both classes to use the synchronization features. Additionally, users may opt to decorate request-functions with our <code>quantpylib.throttler.decorators</code> on instance methods that makes interacting with the semaphores a one-liner.</p> <p>Examples for both decorator usage, and synchronous, asynchronous semaphores are given here.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore","title":"<code>AsyncRateSemaphore</code>","text":"<p>An asynchronous semaphore implementation that limits access to coroutines (known as transactions) based on available credits, and manages credit-debit accounting of a common resource pool. Coroutines to be executed are submitted to the <code>AsyncRateSemaphore.transact</code>  method along with the number of credits it consumes and the time it takes for those credits to be refunded to the resource pool.  Can be used to throttle asynchronous work such as non-blocking API requests or database operations. In most cases, users would only need to interact with the <code>AsyncRateSemaphore.transact</code> method.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.__init__","title":"<code>__init__(credits=1, greedy_entry=False, greedy_exit=True)</code>","text":"<p>Initialize the <code>AsyncRateSemaphore</code> with an initial number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>credits</code> <code>float</code> <p>The initial number of credits the semaphore starts with. Defaults to 1.</p> <code>1</code> <code>greedy_entry</code> <code>bool</code> <p>Determines whether to enforce a FIFO or greedy policy for pending coroutines                             on semaphore entry. Defaults to False.</p> <code>False</code> <code>greedy_exit</code> <code>bool</code> <p>Determines whether to enforce a FIFO or greedy policy for waking up pending coroutines                             on credit refund. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credits</code> is less than 0.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.acquire","title":"<code>acquire(require_credits, refund_time)</code>  <code>async</code>","text":"<p>Acquire the semaphore, decrementing the resource pool by specified number of credits. If the existing resource pool is larger than credits required, decrement the credits and return immediately. If there is not enough credits on entry, do a non-blocking wait until enough resources are freed up. Additionally, if <code>greedy_entry=False</code>, then  the executing transaction will wait behind the earlier pending transactions regardless of the resource  pool availability.</p> <p>Parameters:</p> Name Type Description Default <code>require_credits</code> <code>float</code> <p>The number of credits required to enter the semaphore.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True when the credits were successfully acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.release","title":"<code>release(taken_credits)</code>","text":"<p>Refund the specified number of credits and wake up pending transactions that  are able to execute on the state of the resource pool. Additionally, if <code>greedy_exit=False</code>, then the number of pending transactions  woken up will respect the FIFO order until the resource pool is insufficient for the earliest transaction.</p> <p>Parameters:</p> Name Type Description Default <code>taken_credits</code> <code>float</code> <p>The number of credits to release.</p> required"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.AsyncRateSemaphore.transact","title":"<code>transact(coroutine, credits, refund_time, transaction_id=None, verbose=False)</code>  <code>async</code>","text":"<p>Execute an asynchronous coroutine object using the semaphore for synchronization, utilizing the <code>AsyncRateSemaphore.acquire</code> and <code>AsyncRateSemaphore.release</code> methods for proper synchronization. The refund mechanism is scheduled on the running event loop and the transact method returns without waiting for credits to be refunded. Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> <p>Parameters:</p> Name Type Description Default <code>coroutine</code> <code>coroutine function</code> <p>The coroutine to execute as part of the transaction.</p> required <code>credits</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>transaction_id</code> <code>str</code> <p>Identifier for the transaction. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the executed coroutine.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the coroutine raises any exception.</p> Notes <p>The argument <code>coroutine</code> should NOT be a <code>asyncio.Task</code> object, since any <code>await</code> statements will trigger  its execution on the event loop before the semaphore is acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore","title":"<code>RateSemaphore</code>","text":"<p>A semaphore implementation that limits the access to method/requests (known as transactions) based on available credits, and manages credit-debit accounting of a common resource pool. Functions to be executed are submitted to the <code>RateSemaphore.transact</code>  method along with the number of credits it consumes and the time it takes for those credits to be refunded to the resource pool. Can be used to throttle API requests, database operations and so on. In most cases, the user would only need to interact with the  <code>RateSemaphore.transact</code> method.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.__init__","title":"<code>__init__(credits=1)</code>","text":"<p>Initialize the <code>RateSemaphore</code> with an initial number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>credits</code> <code>float</code> <p>The initial number of credits the semaphore starts with. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credits</code> is less than 0.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.acquire","title":"<code>acquire(require_credits)</code>","text":"<p>Acquire the semaphore, decrementing the resource pool by specified number of credits. If the existing resource pool is larger than credits required, decrement the credits and return immediately. If there is not enough credits on entry, block, wait until  some other thread has called release() until enough resources are freed up. This is done with proper interlocking so that if multiple acquire() calls are blocked,  release() will wake exactly one of them up. The implementation may pick one at random,  so the order in which blocked threads are awakened should not be relied  on and is OS-scheduler dependent.</p> <p>Parameters:</p> Name Type Description Default <code>require_credits</code> <code>float</code> <p>The number of credits required to enter the semaphore.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True when the credits were successfully acquired.</p>"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.release","title":"<code>release(taken_credits)</code>","text":"<p>Refund the specified number of credits.</p> <p>Parameters:</p> Name Type Description Default <code>taken_credits</code> <code>float</code> <p>The number of credits to release.</p> required"},{"location":"throttler/rate_semaphore/#quantpylib.throttler.rate_semaphore.RateSemaphore.transact","title":"<code>transact(lambda_func, credits, refund_time, transaction_id=None, verbose=False)</code>","text":"<p>Execute a parameter-less function using the semaphore for synchronization, using the <code>RateSemaphore.acquire</code> and <code>RateSemaphore.release</code> methods for proper synchronization. The refund mechanism is scheduled in a worker  thread and the transact method returns without waiting for credits to be refunded. Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> <p>Parameters:</p> Name Type Description Default <code>lambda_func</code> <code>callable</code> <p>The function to execute as part of the transaction. Should not take in any parameters.</p> required <code>credits</code> <code>float</code> <p>The number of credits required for the transaction.</p> required <code>refund_time</code> <code>float</code> <p>The time in seconds after which the credits should be refunded.</p> required <code>transaction_id</code> <code>str</code> <p>Identifier for the transaction. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose transaction information. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the transaction function.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the transaction function raises any exception.</p> Notes <p>Any function <code>func</code> that takes in <code>*args</code>, <code>**kwargs</code> can easily be used with  the semaphore by passing in <code>lambda_func = lambda : func(*args,**kwargs)</code>.</p>"},{"location":"throttler/throttler/","title":"throttler","text":"<p>This page describes how you may use our <code>quantpylib.throttler</code> module and the functionalities exposed by our APIs. This module contains classes meant for synchronizing, throttling and handling tasks such as network requests efficiently.</p> <p><code>quantpylib.throttler.aiosonic</code> features a HTTP client written on top of <code>aiosonic</code> and <code>orjson</code>, acting as an asynchronous HTTP library optimizing the speed of HTTP requests and handling of data packets.</p> <p><code>quantpylib.throttler.rate_semaphore</code> features both synchronous and asynchronous support for rate-limiting access to function calls via a credit-based semaphore synchronization tool. A simple but common use would be to maximise throughput of API requests to an external server that places rate-limits on the number of API requests per minute/hour with request credits charged against a resource pool. This is made available through the <code>RateSemaphore</code> and <code>AsyncRateSemaphore</code> classes - and can be seen as an extension of the synchronization  primitives <code>threading.Semaphore</code> and <code>asyncio.locks.Semaphore</code> in the Python standard library respectively. The <code>quantpylib.throttler.decorators</code> module provides decorators for instance methods that wraps threads and coroutines to provide seamless integration with the synchronization features.</p> <p><code>quantpylib.throttler.aiohttp</code> features utility functions to batch asynchronous network requests using <code>aiohttp</code> client sessions and optionally, semaphores.</p> <p>A high-level walkthrough of the individual quant packages are presented in this page. Comprehensive documentation may be found in the respective pages. To follow along, make sure you have installed the necessary dependencies. Code example scripts are also provided in the repo.</p>"},{"location":"throttler/throttler/#examples","title":"Examples","text":""},{"location":"throttler/throttler/#aiosonic-client","title":"Aiosonic Client","text":"<p>The module is an efficiency-optimized HTTP request library. The usage is extremely simple. Let's import some HTTP clients for comparison: <pre><code>import asyncio, aiohttp, requests\nfrom quantpylib.throttler.aiosonic import HTTPClient\nfrom quantpylib.utilities.general import stopwatch\n</code></pre> It is simple to create our <code>HTTPClient</code>. Let's set up some parameters for request: <pre><code>url = \"https://api.hyperliquid.xyz\"\nhttp_client = HTTPClient(base_url=url)\n\nrequest = {\n    \"endpoint\":\"/info\",\n    \"method\":\"POST\",\n    \"data\":{\"type\":\"meta\"}\n}\n</code></pre> We want to poll for perpeutals metadata on hyperliquid server. It is as simple as: <pre><code>async def main():\n    print(await http_client.request(**request))\n</code></pre> The client knows to take base url and endpoint provided to send a POST request to the hyperliquid server. The data payload  can be sent as dictionary or string - if sent as dictionary the payload is serialized using the efficient <code>orjson</code> package, as is deserialization of the returned data packet. Of course, all methods such as GET, POST, PUT and DELETE are supported. Let's compare how this fares against other HTTP clients, using the timer from <code>quantpylib.utilities.general</code>. <pre><code>async def _aiohttp_request(session,url,payload):\n    async with session.post(url, json=payload, headers={\"Content-Type\": \"application/json\"}) as response:\n        return await response.json()\n\nasync def main():\n    print(await http_client.request(**request))\n    await timers()\n\nasync def timers():\n    async with aiohttp.ClientSession() as session:\n        for i in range(30):        \n            print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')\n            await stopwatch(units=\"ms\")(http_client.request)(**request),\n            stopwatch(units=\"ms\")(requests.post)(\n                url + request[\"endpoint\"], \n                json=request[\"data\"], \n                headers={\"content-type\": \"application/json\"}\n            ).json()   \n            await stopwatch(units=\"ms\")(_aiohttp_request)(\n                session=session,\n                url=url + request[\"endpoint\"],\n                payload=request[\"data\"]\n            )\n            print('&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;')\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> An example of the timing results look like this: <pre><code>...\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::69ms\npost::225ms\n_aiohttp_request::69ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::75ms\npost::221ms\n_aiohttp_request::87ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::67ms\npost::230ms\n_aiohttp_request::82ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nrequest::77ms\npost::226ms\n_aiohttp_request::67ms\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n...\n</code></pre> It is clear that the blocking, no-cache <code>requests.post</code> method is least performant. Both our requests  using the <code>throttler</code> client and <code>aiohttp</code> client are comparative due to cacheing and maintenance of  the handshake - but the <code>throttler</code> library should edge out  small performance gains due to efficient (de)serialization of messages. This is important if we are working with  large packets. The network latency dominates in most cases, however. It is clear which library is easiest to use.</p>"},{"location":"throttler/throttler/#rate-semaphore","title":"Rate Semaphore","text":"<p>The module is flexible enough to handle both fixed-cost endpoints (specs such as '20 API requests/min') or  variable-cost endpoints (specs such as `5 API credits/getTick', '15 API credits/getOHLCV' with '100 credits/min per client').</p> <p>Suppose we have a financial API endpoint that has rate limits as such:</p> Period Credits Awarded / app 10 seconds 40 <p>The API gives us 40 credits to use every 10 seconds (capped at 40 credits max). Different endpoints can have variable credit costs, depending on the server load. </p> <p>Suppose we have the following endpoints and their respective costs:</p> Endpoint Cost (credits / req) getTick 20 getOHLCV 5..30 getPrice 12.5 ... ... <p>Both synchronous and asynchronous semaphores expose their synchronization features through the <code>semaphore.transact(...)</code> method, which have the same function signature, except  that the first parameter to a synchronous transaction is a parameter-less function, and the first parameter to the asynchronous transaction is a coroutine. Their detailed documentations are defined here.</p> <p>For the demonstration, we require the following imports: <pre><code>import time\nimport random\nimport asyncio\nimport threading\n\nfrom datetime import datetime\nfrom quantpylib.throttler.decorators import wrap_in_thread, aconsume_credits\nfrom quantpylib.throttler.rate_semaphore import RateSemaphore,AsyncRateSemaphore\n</code></pre></p>"},{"location":"throttler/throttler/#synchronous-example","title":"Synchronous Example","text":"<p>Let's begin with the example for the synchronous semaphore, given by the <code>RateSemaphore</code> class. Our objective is to maximise the throughput to a bunch of blocking requests that consume credits on some external server. To simulate blocking requests, such as a <code>requests.get</code> method, we use the <code>time.sleep</code> method. Note that this generalizes to any blocking method. <pre><code>def getTick(work, id):\n    print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n    time.sleep(work)\n    print(f\"{datetime.now()}:: getTick processed {id}\")\n    return True\n\ndef getOHLCV(work, id):\n    print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n    time.sleep(work)\n    print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n    return True\n</code></pre></p> <p>Since we want to maximise throughput, and the function calls block the main thread, we want to create the requests in multiple threads. But since sending all of these requests simultaneously in different threads would overload the market data server (giving us errors/downgraded/blacklisted), we would wrap them in rate-limited transactions and submit them to the semaphore. Let's create some script to run some requests through the semaphore with the <code>transact</code> method : <pre><code>def sync_example():\n    print(\"-----------------------sync with thread-----------------------\")\n    sem = RateSemaphore(40)\n    tick_req = lambda x: getTick(random.randint(1, 5), x)\n    ohlcv_req = lambda x: getOHLCV(random.randint(1, 5), x)\n\n    threads = [\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: tick_req(1), \n            \"credits\":20, \n            \"refund_time\":10, \n            \"transaction_id\":1, #optional\n            \"verbose\":True #optional\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: ohlcv_req(2), \n            \"credits\":30, \n            \"refund_time\":10, \n            \"transaction_id\":2, #optional\n            \"verbose\":True #optional\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: ohlcv_req(3), \n            \"credits\":5, \n            \"refund_time\":10, \n            \"transaction_id\":3, \n            \"verbose\":True\n        }),\n        threading.Thread(target=sem.transact,kwargs={\n            \"lambda_func\":lambda: tick_req(4), \n            \"credits\":20, \n            \"refund_time\":10, \n            \"transaction_id\":4, \n            \"verbose\":True\n        }),\n    ]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n\nif __name__ == \"__main__\":\n    sync_example()\n</code></pre> We set the verbosity flag to give us information on when the semaphore executed the transactions, so let us observe the printed information log: <pre><code>-----------------------sync with thread-----------------------\n2024-03-28 19:16:27.105953:: TXN 1 acquiring CreditSemaphore\n2024-03-28 19:16:27.106051:: TXN 2 acquiring CreditSemaphore\n2024-03-28 19:16:27.106083:: TXN 1 entered CreditSemaphore...\n2024-03-28 19:16:27.106161:: TXN 3 acquiring CreditSemaphore\n2024-03-28 19:16:27.106303:: TXN 4 acquiring CreditSemaphore\n2024-03-28 19:16:27.106367:: TXN 3 entered CreditSemaphore...\n2024-03-28 19:16:27.106426:: getOHLCV processing 3 takes 4 seconds\n2024-03-28 19:16:27.106449:: getTick processing 1 takes 5 seconds\n2024-03-28 19:16:31.106689:: getOHLCV processed 3\n2024-03-28 19:16:31.106877:: TXN 3 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:32.107982:: getTick processed 1\n2024-03-28 19:16:32.108390:: TXN 1 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:41.109162:: TXN 4 entered CreditSemaphore...\n2024-03-28 19:16:41.109260:: getTick processing 4 takes 2 seconds\n2024-03-28 19:16:43.110862:: getTick processed 4\n2024-03-28 19:16:43.111243:: TXN 4 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:53.113011:: TXN 2 entered CreditSemaphore...\n2024-03-28 19:16:53.113060:: getOHLCV processing 2 takes 3 seconds\n2024-03-28 19:16:56.115643:: getOHLCV processed 2\n2024-03-28 19:16:56.115815:: TXN 2 exits CreditSemaphore, schedule refund in 10...\n</code></pre> It is not difficult to reason with the output. For instance, transactions 1 and 3 entered the semaphore first, while 2, 4 was placed on hold, leaving 40 - 20 - 5 = 15 credits. No other transaction can enter the semaphore. Transaction 3 processes and completes at 31 seconds,  but the credit is only refunded 10 seconds later. We can see that at 41 seconds, the (5) credits from transaction 3 is refunded, giving us 15 + 5 = 20 credits, enough for transaction 4 to enter the semaphore but not 2. The rest of printed log statements are easy to rationalize.</p>"},{"location":"throttler/throttler/#easy-with-decorators","title":"Easy with Decorators","text":"<p>The example given is nice but somewhat unwiedly due to having to wrap the method/function of interest first in a semaphore  transaction, then followed by a <code>threading.Thread</code> object. In many software applications, we have a data-service layer with a poller object/SDK for API calls made to  external servers. A simulated example looks something like this:</p> <p><pre><code>class _Throttler():\n    def __init__(self):\n        self.rate_semaphore=RateSemaphore(31)\n\n    @wrap_in_thread(costs=20,refund_in=10)#,attrname=\"rate_semaphore\",verbose=True (optional-defaults)\n    def _getTick(self, work, id):\n        print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n        time.sleep(work)\n        print(f\"{datetime.now()}:: getTick processed {id}\")\n        return True\n\n    @wrap_in_thread(costs=10,refund_in=10,attrname=\"rate_semaphore\",verbose=True)\n    def _getOHLCV(self, work, id):\n        print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n        time.sleep(work)\n        print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n        return True\n</code></pre> The data-access object is given one or more <code>RateSemaphore</code>  objects corresponding to a unique credit/resource pool. For each  method that makes a resource-consuming request, we can decorate the function using <code>wrap_in_thread</code> with the costs and refund timers as parameters. The decorated function calls then directly return <code>threading.Thread</code> instances wrapping transactions that contain the function request, which can be activated using the <code>threading.Thread.start</code> method. <pre><code>def sync_example():\n    print(\"-----------------------sync with thread-----------------------\")\n    #... previous example\n\n    print(\"-----------------------sync with decorator-----------------------\")\n    throttler = _Throttler()\n    threads = [\n        throttler._getTick(3, 1),\n        throttler._getOHLCV(1, 2),\n        throttler._getTick(3, 3),\n        throttler._getOHLCV(1, 4),\n    ]\n    [thread.start() for thread in threads]\n    [thread.join() for thread in threads]\n</code></pre> The behavior of the semaphore is similar to the example explored in the previous example.  The printed log statements are hence presented without commentary, but may be rationalized easily. <pre><code>----------------------sync with decorator-----------------------\n2024-03-28 19:16:56.116058:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116154:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116220:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:16:56.116302:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116555:: getTick processing 1 takes 3 seconds\n2024-03-28 19:16:56.116366:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:16:56.116515:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:16:56.116691:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:16:57.120664:: getOHLCV processed 2\n2024-03-28 19:16:57.120879:: TXN {'fn': '_getOHLCV', 'args': (1, 2), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:16:59.117150:: getTick processed 1\n2024-03-28 19:16:59.117323:: TXN {'fn': '_getTick', 'args': (3, 1), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:07.123469:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:07.123532:: getOHLCV processing 4 takes 1 seconds\n2024-03-28 19:17:08.125678:: getOHLCV processed 4\n2024-03-28 19:17:08.126219:: TXN {'fn': '_getOHLCV', 'args': (1, 4), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:09.118384:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:09.118482:: getTick processing 3 takes 3 seconds\n2024-03-28 19:17:12.119387:: getTick processed 3\n2024-03-28 19:17:12.119741:: TXN {'fn': '_getTick', 'args': (3, 3), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n</code></pre></p>"},{"location":"throttler/throttler/#asynchronous-example","title":"Asynchronous Example","text":"<p>We now move onto the asynchronous semaphore, given by the <code>AsyncRateSemaphore</code> class. Our objective is to maximise the throughput to a bunch of non-blocking requests that consume credits on some external server. To simulate non-blocking requests, such as an  <code>async with session.get</code> method of an <code>aiohttp.ClientSession</code> object or asynchronous database requests, we use the  <code>asyncio.sleep</code> method. Note that this generalizes to any non-blocking coroutine.</p> <pre><code>async def agetTick(work, id):\n    print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n    await asyncio.sleep(work)\n    print(f\"{datetime.now()}:: getTick processed {id}\")\n    return True\n\nasync def agetOHLCV(work, id):\n    print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n    await asyncio.sleep(work)\n    print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n    return True\n</code></pre> <p>Since we want to maximise throughput, and the function calls are coroutines that do not block  the main thread, we want to create the requests concurrently and place them on the event loop. But since sending all of these requests simultaneously in different coroutines would overload the market data server (giving us errors/downgraded/blacklisted), we would wrap them in rate-limited transactions and submit them to the semaphore. Let's create some script to run some request transactions through the semaphore:</p> <p><pre><code>async def async_example():\n    print(\"-----------------------async with transactions-----------------------\")\n    sem = AsyncRateSemaphore(40, greedy_entry=True, greedy_exit=True)\n\n    tick_req = lambda x: agetTick(random.randint(1, 5), x)\n    ohlcv_req = lambda x: agetOHLCV(random.randint(1, 5), x)\n\n    transactions = [\n        sem.transact(coroutine=tick_req(1), credits=20, refund_time=10, transaction_id=1, verbose=True),\n        sem.transact(coroutine=ohlcv_req(2), credits=30, refund_time=10, transaction_id=2, verbose=True),\n        sem.transact(coroutine=ohlcv_req(3), credits=5, refund_time=10, transaction_id=3, verbose=True),\n        sem.transact(coroutine=tick_req(4), credits=20, refund_time=10, transaction_id=4, verbose=True),\n    ]\n    await asyncio.gather(*transactions)\n\nif __name__ == \"__main__\":\n    sync_example() #previous example\n    asyncio.run(async_example())\n</code></pre> We set the verbosity flag to give us information on when the semaphore executed the transactions, so let us observe the printed information log: <pre><code>-----------------------async with transactions-----------------------\n2024-03-28 19:17:12.120864:: TXN 1 acquiring CreditSemaphore\n2024-03-28 19:17:12.120915:: TXN 1 entered CreditSemaphore...\n2024-03-28 19:17:12.120927:: getTick processing 1 takes 4 seconds\n2024-03-28 19:17:12.120964:: TXN 2 acquiring CreditSemaphore\n2024-03-28 19:17:12.120988:: TXN 3 acquiring CreditSemaphore\n2024-03-28 19:17:12.121006:: TXN 3 entered CreditSemaphore...\n2024-03-28 19:17:12.121016:: getOHLCV processing 3 takes 5 seconds\n2024-03-28 19:17:12.121044:: TXN 4 acquiring CreditSemaphore\n2024-03-28 19:17:16.121665:: getTick processed 1\n2024-03-28 19:17:16.121740:: TXN 1 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:17.122353:: getOHLCV processed 3\n2024-03-28 19:17:17.122462:: TXN 3 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:26.123119:: TXN 2 entered CreditSemaphore...\n2024-03-28 19:17:26.123192:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:17:27.123519:: getOHLCV processed 2\n2024-03-28 19:17:27.123633:: TXN 2 exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:37.124999:: TXN 4 entered CreditSemaphore...\n2024-03-28 19:17:37.125077:: getTick processing 4 takes 3 seconds\n2024-03-28 19:17:40.126377:: getTick processed 4\n2024-03-28 19:17:40.126493:: TXN 4 exits CreditSemaphore, schedule refund in 10...\n</code></pre> It is not difficult to reason with the output. For instance, transactions 1 and 3 entered the semaphore first, while 2, 4 was placed on hold, leaving 40 - 20 - 5 = 15 credits. No other transaction can enter the semaphore. Transaction 1 processes and completes at 16 seconds,  but the credit is only refunded 10 seconds later. We can see that at 26 seconds, the (20) credits from transaction 1 is refunded, giving us 15 + 20 = 35 credits, enough for transaction 2 to enter the semaphore but not both 2 and 4. 2 is admitted first, and the rest of printed log statements are easy to rationalize.</p>"},{"location":"throttler/throttler/#easy-with-decorators_1","title":"Easy with Decorators","text":"<p>The example given is nice but somewhat unwiedly due to having to wrap the method/function of interest in semaphore transactions. We would like to hide  the throttling intricacies at the caller level, such that a user of said data-access layer  or SDKs do not need to be aware of the presence of a semaphore. For instance: <pre><code>class _Throttler():\n    def __init__(self):\n        #... previous example\n        self.arate_semaphore=AsyncRateSemaphore(31)\n\n    #... previous example\n\n    @aconsume_credits(costs=20,refund_in=10,attrname=\"arate_semaphore\") #we want the asynchronous semaphore, and since the default name is not rate_semaphore, we pass in attrname\n    async def _agetTick(self, work, id):\n        print(f\"{datetime.now()}:: getTick processing {id} takes {work} seconds\")\n        await asyncio.sleep(work)\n        print(f\"{datetime.now()}:: getTick processed {id}\")\n        return True\n\n    @aconsume_credits(costs=10,refund_in=10,attrname=\"arate_semaphore\",verbose=True)\n    async def _agetOHLCV(self, work, id):\n        print(f\"{datetime.now()}:: getOHLCV processing {id} takes {work} seconds\")\n        await asyncio.sleep(work)\n        print(f\"{datetime.now()}:: getOHLCV processed {id}\")\n        return True\n</code></pre> The data-access object is given one or more <code>AsyncRateSemaphore</code> objects corresponding to a unique credit/resource pool. For each  method that makes a resource-consuming request, we can decorate the function using <code>aconsume_credits</code> with the costs and refund timers as parameters. The decorated function calls then are submitted through the object attribute's asynchronous semaphore instance. <pre><code>async def async_example():\n    print(\"-----------------------async with transactions-----------------------\")\n    #... previous example\n\n    print(\"-----------------------async with decorator-----------------------\")\n    throttler = _Throttler()\n    transactions = [\n        throttler._agetTick(3, 1),\n        throttler._agetOHLCV(1, 2),\n        throttler._agetTick(3, 3),\n        throttler._agetOHLCV(1, 4),\n    ]\n    await asyncio.gather(*transactions)\n</code></pre> The behavior of the semaphore is similar to the example explored in the previous example.  The printed log statements are hence presented without commentary, but may be rationalized easily. <pre><code>-----------------------async with decorator-----------------------\n2024-03-28 19:17:40.126936:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127015:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:40.127044:: getTick processing 1 takes 3 seconds\n2024-03-28 19:17:40.127110:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127149:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:40.127170:: getOHLCV processing 2 takes 1 seconds\n2024-03-28 19:17:40.127217:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:40.127266:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} acquiring CreditSemaphore\n2024-03-28 19:17:41.127912:: getOHLCV processed 2\n2024-03-28 19:17:41.128021:: TXN {'fn': '_agetOHLCV', 'args': (1, 2), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:43.127485:: getTick processed 1\n2024-03-28 19:17:43.127539:: TXN {'fn': '_agetTick', 'args': (3, 1), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:51.129270:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:51.129314:: getOHLCV processing 4 takes 1 seconds\n2024-03-28 19:17:52.130482:: getOHLCV processed 4\n2024-03-28 19:17:52.130534:: TXN {'fn': '_agetOHLCV', 'args': (1, 4), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n2024-03-28 19:17:53.128193:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} entered CreditSemaphore...\n2024-03-28 19:17:53.128281:: getTick processing 3 takes 3 seconds\n2024-03-28 19:17:56.129573:: getTick processed 3\n2024-03-28 19:17:56.129683:: TXN {'fn': '_agetTick', 'args': (3, 3), 'kwargs': {}} exits CreditSemaphore, schedule refund in 10...\n</code></pre></p>"},{"location":"throttler/throttler/#notes-on-behavior","title":"Notes on Behavior","text":"<ul> <li> <p> Entry Behavior  </p> <ol> <li><code>AsyncRateSemaphore</code> acquires the semaphore if there are enough resources, but if <code>greedy_entry=False</code>, then the submitted transaction will wait behind the earlier pending transactions regardless of the resource pool availability. Otherwise, any submitted transaction that can run immediately will run without consideration for existing waiters.</li> <li><code>RateSemaphore</code> acquires the semaphore immediately if there are enough resources, and  otherwise waits. The order in which blocked threads are awakened should not be relied on and is OS-scheduler dependent.</li> </ol> </li> <li> <p> Exit Behavior   Requests submitted to both semaphore types exit from their respective <code>transact</code> method without waiting for the credits to be refunded. The credits are scheduled to be refunded separately on a thread (for synchronous implementations) or the event loop (for asynchronous implementations). When the credit is refunded </p> <ol> <li> <p><code>AsyncRateSemaphore</code> wakes up pending transactions that are able to execute on the state of the resource pool. If <code>greedy_exit=False</code>, then the number of pending transactions woken up will respect the FIFO order until the resource pool is insufficient for the earliest transaction. Otherwise, when credits are refunded with &gt;=2 waiting transactions with arrival time <code>txn A</code> &lt; <code>txn B</code>. If the semaphore has not enough credits to execute <code>txn A</code>, it can first run <code>txn B</code>. This helps to maximise throughput.</p> </li> <li> <p><code>RateSemaphore</code> wakes up pending transactions that are able to execute on the state of the resource pool. The order in which blocked threads are awakened should not be relied on and is OS-scheduler dependent.</p> </li> </ol> </li> <li> <p> Exception Behavior   Failed transactions (raised Exceptions) consume and refund credit in the same way as successful transactions.</p> </li> </ul>  Note that non-greedy entry and greedy exit can cause resource-expensive transactions to sit behind cheaper transactions which are constantly being submitted to the semaphore at a fast rate, preventing the expensive transaction from acquiring the semaphore."},{"location":"throttler/throttler/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Wrap unstable networks and expensive requests in a timeout transaction. This is to prevent the coroutine from 'await'-ing forever and hogging the semaphore.</p> </li> <li> <p>Since the transactions wrap native Python functions and coroutines, it does not know when the code actually performs the credit-costing request. The <code>transact</code> functions should be closest to the costful logic as possible. It should not perform heavy compute or multiple requests so that the credits can refunded as quickly as possible for other transactions. </p> </li> </ul>"},{"location":"throttler/throttler/#throttlerratesemaphore","title":"throttler.rate_semaphore","text":""},{"location":"throttler/throttler/#throttlerratedecorator","title":"throttler.decorators","text":""},{"location":"utilities/general/","title":"quantpylib.utilities.general","text":""},{"location":"utilities/general/#quantpylib.utilities.general.backup_folder","title":"<code>backup_folder(s3, local, bucket, ignore=['.*', '*.parquet.*'])</code>  <code>async</code>","text":"<p>Backup a local folder to an S3 bucket.</p> <p>Parameters:</p> Name Type Description Default <code>s3</code> <code>object</code> <p>The async S3 client.</p> required <code>local</code> <code>str</code> <p>The local folder path.</p> required <code>bucket</code> <code>str</code> <p>The S3 bucket name.</p> required <code>ignore</code> <code>list</code> <p>List of patterns to ignore. Defaults to ['.','.parquet.*'].</p> <code>['.*', '*.parquet.*']</code>"},{"location":"utilities/general/#quantpylib.utilities.general.get_boto_client","title":"<code>get_boto_client(endpoint_url, aws_access_key_id, aws_secret_access_key)</code>  <code>async</code>","text":"<p>Get an async boto3 client.</p>"},{"location":"utilities/general/#quantpylib.utilities.general.list_s3_files","title":"<code>list_s3_files(s3, bucket)</code>  <code>async</code>","text":"<p>List all files in an S3 bucket.</p>"},{"location":"utilities/general/#quantpylib.utilities.general.load_pickle","title":"<code>load_pickle(path)</code>","text":"<p>Loads a Python object from a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the pickle file.</p> required"},{"location":"utilities/general/#quantpylib.utilities.general.next_hr","title":"<code>next_hr(utc=True, timestamp=True)</code>","text":"<p>Get the next hour timestamp.</p>"},{"location":"utilities/general/#quantpylib.utilities.general.pdf_snapshot","title":"<code>pdf_snapshot(save, code_file=None, include_comments=True, squeeze=True, report_data=[])</code>","text":"<p>Generates a PDF report with high-resolution images and a snapshot of <code>code_file</code> if given.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>str</code> <p>Path to save the PDF report.</p> required <code>code_file</code> <code>str</code> <p>Path to the script file for code snapshot inclusion. Defaults to None.</p> <code>None</code> <code>include_comments</code> <code>bool</code> <p>Whether to include comments in the code snapshot. Defaults to <code>True</code>.</p> <code>True</code> <code>report_data</code> <code>list</code> <p>List of tuples containing the data to include in the report. Defaults to <code>[]</code>. Each tuple is of the form (section,data,dtype). dtype can be 'dict', 'df', or 'img'. If dtype is 'img', data should be the path to the image file.</p> <code>[]</code>"},{"location":"utilities/general/#quantpylib.utilities.general.resolve_path","title":"<code>resolve_path(path, make_dir=False, *args, **kwargs)</code>","text":"<p>Resolves a path and returns the directory and file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to resolve.</p> required <code>make_dir</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to False.</p> <code>False</code>"},{"location":"utilities/general/#quantpylib.utilities.general.restore_folder","title":"<code>restore_folder(s3, local, bucket, remote_subpaths=[''], match_files=[])</code>  <code>async</code>","text":"<p>Restore a folder from an S3 bucket.</p> <p>Parameters:</p> Name Type Description Default <code>s3</code> <code>object</code> <p>The async S3 client.</p> required <code>local</code> <code>str</code> <p>The local folder path.</p> required <code>bucket</code> <code>str</code> <p>The S3 bucket name.</p> required <code>remote_subpaths</code> <code>list</code> <p>List of remote subpaths to restore. Defaults to [''] (all).</p> <code>['']</code> <code>match_files</code> <code>list</code> <p>List of files to restore. Defaults to <code>[]</code> (all).</p> <code>[]</code>"},{"location":"utilities/general/#quantpylib.utilities.general.save_pickle","title":"<code>save_pickle(path, obj)</code>","text":"<p>Saves a Python object to a pickle.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the pickle file.</p> required <code>obj</code> <code>object</code> <p>The Python object to save.</p> required"},{"location":"utilities/general/#quantpylib.utilities.general.stopwatch","title":"<code>stopwatch(_func=None, *, units='ms', return_time=False)</code>","text":"<p>A decorator that measures the time taken for a function to execute.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>Callable</code> <p>The function/coroutine to decorate. Defaults to None.</p> <code>None</code> <code>units</code> <code>str</code> <p>The units to return the time in. Options are 's', 'ms', and 'ns'. Defaults to 'ms'.</p> <code>'ms'</code> <code>return_time</code> <code>bool</code> <p>Whether to return the time taken or result of function execution. Defaults to False.</p> <code>False</code>"},{"location":"utilities/math/","title":"quantpylib.utilities.math","text":""},{"location":"wrappers/binance/","title":"quantpylib.wrappers.binance","text":""},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance","title":"<code>Binance</code>","text":""},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to account fill updates - in Binance, this just calls  the <code>order_updates_subscribe</code> method.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe to account fill updates - in Binance, this just calls  the <code>order_updates_unsubscribe</code> method.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up open sessions with Binance server</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.contract_specifications","title":"<code>contract_specifications(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_all_marks","title":"<code>get_all_marks(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mark-price for all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mark-prices (Decimal) as values.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_all_mids","title":"<code>get_all_mids(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_funding_info","title":"<code>get_funding_info(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the funding rate for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the funding rate.</p> <code>None</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, kline_close=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the exchange client.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_get","title":"<code>l2_book_get(ticker, depth=1000, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve L2 Order Book data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of order book data to retrieve. Defaults to 1000.</p> <code>1000</code> <code>standardize_schema</code> <code>bool</code> <p>Whether to standardize the schema of the retrieved data. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the order book data.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=20, stream_depth=20, buffer_size=100, as_dict=True, on_update=None, refresh_sec=300, speed_ms=500, apply_shadow_depth=False, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of order book data to retrieve. Defaults to 20.</p> <code>20</code> <code>stream_depth</code> <code>int</code> <p>Depth of order book data to stream. Defaults to 20.</p> <code>20</code> <code>buffer_size</code> <code>int</code> <p>The size of the buffer to store order book history. Defaults to 100.</p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for the order book updates. Defaults to None.</p> <code>None</code> <code>refresh_sec</code> <code>int</code> <p>The time interval in seconds to refresh the order book snapshot. Defaults to 300.</p> <code>300</code> <code>speed_ms</code> <code>int</code> <p>The speed of stream update. Allowed values are <code>[None,100,250,500]</code>. Defaults to 500.</p> <code>500</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the local mirror copy of the L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>bool</code> <p>Whether to return the order book data as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, depth=5, speed_ms=None, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>depth</code> <code>Optional[int]</code> <p>Depth of order book data received. Defaults to 5.</p> <code>5</code> <code>speed_ms</code> <code>Optional[int]</code> <p>Speed of stream update. Allowed values are <code>[None,100,250,500]</code>.</p> <code>None</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of perpetuals with open subscription.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.limit_order","title":"<code>limit_order(ticker, amount, price=None, price_match=None, tif=markets.TIME_IN_FORCE_GTC, reduce_only=False, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Submit limit order. If both price and price_match is specified, then the price_match is prioritized.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long/short.</p> required <code>price</code> <code>Optional[float]</code> <p>The price at which to execute the order. Defaults to None.</p> <code>None</code> <code>price_match</code> <code>Optional[str]</code> <p>The price matching rule at which to execute the order. Defaults to None. Allowed values are <code>[OPPONENT,OPPONENT_5,OPPONENT_10,OPPONENT_20,QUEUE,QUEUE_5,QUEUE_10]</code> </p> <code>None</code> <code>tif</code> <code>str</code> <p>The time in force. Defaults to \"GTC\". Allowed values are <code>[GTC,IOC,FOK,GTX,GTD]</code>.</p> <code>TIME_IN_FORCE_GTC</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should reduce an existing position only. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.market_order","title":"<code>market_order(ticker, amount, reduce_only=False, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Submit market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive/negative quantity of contracts to long/short.</p> required <code>reduce_only</code> <code>bool</code> <p>Whether the order should reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_query","title":"<code>order_query(ticker, oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <code>oid</code> <code>(str, int)</code> <p>Order ID in exchange</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order updates.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order updates.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_get","title":"<code>orders_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_get","title":"<code>positions_get()</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> required"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generate a random string (cloid) consisting of hexadecimal characters.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A random hexadecimal string with a total length of 32 characters,  including the optional 'start' and 'end' strings.</p>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>(ts,price,sz,dir)</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/binance/#quantpylib.wrappers.binance.Binance.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/","title":"quantpylib.wrappers.bybit","text":"<p><code>quantpylib.wrappers.bybit</code> module is our official Bybit wrapper SDK implementing the endpoints for perpetuals trading. The library supports a fully asynchronous endpoint for efficiency and lightweight  concurrency. The websocket manager handles reconnections and resubsriptions under network errors and upgrades.</p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions - such as merging data from paginated responses.</p>"},{"location":"wrappers/bybit/#examples","title":"Examples","text":"<p>We would demonstrate some endpoints. Refer to full documentation for details. <pre><code>import os \nimport pytz\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.standards import Period\nfrom quantpylib.wrappers.bybit import Bybit\n\nasync def print_handler(msg): \n    print(msg)\n\nasync def main():\n    '''using the SDK'''\n    bybit = Bybit(\n        key=os.getenv(\"BYBIT_KEY\"),\n        secret=os.getenv(\"BYBIT_SECRET\"),\n    )\n    '''quantpylib.gateway endpoints'''\n    await bybit.init_client()\n    print(bybit.get_price_precision(\"BTCUSDT\"))\n    print(bybit.get_lot_precision(\"BTCUSDT\"))\n\n    '''ACCOUNT ENDPOINTS'''\n    pprint(await bybit.account_balance())\n    await bybit.account_fill_subscribe(handler=print_handler)\n\n    '''EXCHANGE ENDPOINTS'''\n    pprint(await bybit.contract_specifications())\n\n    '''EXECUTOR ENDPOINTS'''\n    cloid = bybit.rand_cloid()\n    print(cloid)\n    pprint(await bybit.get_all_mids())\n    pprint(await bybit.limit_order(ticker=\"SOLUSDT\",amount=1,price=99.99,cloid=cloid))\n    pprint(await bybit.cancel_open_orders()) #or use ticker=\"SOLUSDT\"\n    pprint(await bybit.cancel_order(ticker=\"SOLUSDT\",cloid=cloid)) #or use oid\n    pprint(await bybit.market_order(ticker=\"SOLUSDT\",amount=-0.5))\n    pprint(await bybit.l2_book_get(ticker=\"BTCUSDT\"))\n    await bybit.l2_book_mirror(ticker=\"BTCUSDT\",on_update=print_handler)\n    await bybit.l2_book_subscribe(ticker=\"BTCUSDT\",handler=print_handler)\n    await bybit.trades_subscribe(ticker=\"BTCUSDT\",handler=print_handler)\n\n    '''ORDERS ENDPOINTS'''\n    pprint(await bybit.order_query(oid='1234'))\n    pprint(await bybit.orders_get())\n    await bybit.orders_mirror(on_update=print_handler)\n    await bybit.order_updates_subscribe(handler=print_handler)\n\n    '''POSITIONS ENDPOINTS'''\n    pprint(await bybit.positions_get())\n    await bybit.positions_mirror(on_update=print_handler)\n\n    '''DATAPOLLER ENDPOINTS'''\n    pprint(await bybit.get_trade_bars(\n        ticker='BTCUSDT',\n        start=datetime(2021,1,1, tzinfo=pytz.utc),\n        end=datetime.now(pytz.utc),\n        granularity=Period.HOURLY,\n        granularity_multiplier=1,\n    ))\n\n    '''raw exchange endpoints API - refer to docs for the other method implementations'''\n    pprint(await bybit.instruments_info())\n    await asyncio.sleep(1e9)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit","title":"<code>Bybit</code>","text":""},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.__init__","title":"<code>__init__(key='', secret='', env='prod', key_self_generated=False, **kwargs)</code>","text":"<p>Initializes the Bybit instance.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>API key for authentication. Defaults to empty string.</p> <code>''</code> <code>secret</code> <code>str</code> <p>API secret for authentication. Defaults to empty string.</p> <code>''</code> <code>key_self_generated</code> <code>bool</code> <p>Flag to indicate if RSA authentication is used. Defaults to False.</p> <code>False</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to account fill updates.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe to account fill updates.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.account_info","title":"<code>account_info()</code>  <code>async</code>","text":"<p>Retrieves general account information.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The account information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Not supported by Bybit.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Not supported by Bybit.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.batch_orders_cancel","title":"<code>batch_orders_cancel(category='linear', cancel_wires=[])</code>  <code>async</code>","text":"<p>Cancels multiple orders in a single batch request.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>cancel_wires</code> <code>list</code> <p>A list of cancel wire dictionaries to be canceled.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the batch order cancellation.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.batch_orders_create","title":"<code>batch_orders_create(category='linear', order_wires=[])</code>  <code>async</code>","text":"<p>Creates multiple orders in a single batch request.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>order_wires</code> <code>list</code> <p>A list of order wire dictionaries to be created.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the batch order creation.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for further customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the cancel to the exchange, else returns the cancel order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up the client sessions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.contract_specifications","title":"<code>contract_specifications(include_prelists=False, contract_type='LinearPerpetual', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>include_prelists</code> <code>bool</code> <p>Specifies whether to include prelistings.</p> <code>False</code> <code>contract_type</code> <code>str</code> <p>Type of contracts to retrieve. Defaults to <code>LinearPerpetual</code>.</p> <code>'LinearPerpetual'</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.funding_history","title":"<code>funding_history(ticker, category='linear', startTime=None, endTime=None, limit=None)</code>  <code>async</code>","text":"<p>Retrieves the funding rate history for a given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading ticker symbol (e.g., 'BTCUSDT').</p> required <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>startTime</code> <code>int</code> <p>The start time for the funding history in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>endTime</code> <code>int</code> <p>The end time for the funding history in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of records to retrieve. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The funding rate history data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_all_mids","title":"<code>get_all_mids(ticker=None, category='linear', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the contract. Defaults to 'linear'.</p> <code>'linear'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_funding_info","title":"<code>get_funding_info(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the funding rate and interval for all contracts.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_lot_precision","title":"<code>get_lot_precision(ticker)</code>","text":"<p>Retrieves the lot size precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for lot size precision.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_order_wire","title":"<code>get_order_wire(symbol, amount, orderType, price=None, timeInForce='GTC', reduceOnly=False, orderLinkId=None, **kwargs)</code>","text":"<p>Creates the wire for placing an order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade.</p> required <code>orderType</code> <code>str</code> <p>The type of order (e.g., 'Limit', 'Market').</p> required <code>price</code> <code>float</code> <p>The price for the order. Defaults to None.</p> <code>None</code> <code>timeInForce</code> <code>str</code> <p>The time-in-force for the order (e.g., 'GTC', 'FOK'). Defaults to \"GTC\".</p> <code>'GTC'</code> <code>reduceOnly</code> <code>bool</code> <p>Whether the order is reduce-only. Defaults to False.</p> <code>False</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the order.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order wire data.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.get_price_precision","title":"<code>get_price_precision(ticker)</code>","text":"<p>Retrieves the price precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for price precision.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.index_kline","title":"<code>index_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves index price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The index price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the client by fetching contract specifications and setting up precision mappings.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.instruments_info","title":"<code>instruments_info(category='linear', status='Trading', basecoin=None, symbol=None, limit=1000, cursor='')</code>  <code>async</code>","text":"<p>Retrieves information about trading instruments.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>status</code> <code>str</code> <p>The status of the instrument (e.g., 'Trading'). Defaults to \"Trading\".</p> <code>'Trading'</code> <code>basecoin</code> <code>str</code> <p>The base coin (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of instruments to retrieve. Defaults to 1000.</p> <code>1000</code> <code>cursor</code> <code>str</code> <p>The cursor for pagination. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about trading instruments from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.kline","title":"<code>kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves kline (candlestick) data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., 'D', 'M'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_get","title":"<code>l2_book_get(ticker, depth=25, category='linear', standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the L2 Order Book for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order book. Defaults to 25.</p> <code>25</code> <code>category</code> <code>str</code> <p>Category of the contract. Defaults to 'linear'.</p> <code>'linear'</code> <code>standardize_schema</code> <code>bool</code> <p>If True, returns the order book in a standardized schema. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=50, stream_depth=50, buffer_size=100, as_dict=True, on_update=None, apply_shadow_depth=False, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code></p> <code>50</code> <code>stream_depth</code> <code>int</code> <p>Depth of the l2 stream used to maintain internal order book.</p> <code>50</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code></p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, depth=200, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream updates. Defaults to 200.</p> <code>200</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, depth=200, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream update subscribed. Defaults to 200.</p> <code>200</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.limit_order","title":"<code>limit_order(ticker, amount, price, tif='GTC', reduce_only=False, cloid=None, round_price=False, round_size=False, category='linear', submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>Contract categroy. Defaults to <code>linear</code>.</p> <code>'linear'</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.mark_kline","title":"<code>mark_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves mark price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The mark price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.market_order","title":"<code>market_order(ticker, amount, tif='GTC', reduce_only=False, cloid=None, round_size=False, category='linear', submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>tif</code> <code>str</code> <p>Time in force. Defaults to <code>GTC</code>. Valid values are <code>GTC</code>, <code>IOC</code>, <code>FOK</code>.</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>Contract categroy. Defaults to <code>linear</code>.</p> <code>'linear'</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement. This typically includes a confirmation of the placed order, or an error message if the order could not be placed.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_cancel","title":"<code>order_cancel(symbol, orderId=None, orderLinkId=None, category='linear', orderFilter=None, submit=True)</code>  <code>async</code>","text":"<p>Cancels an existing order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>orderId</code> <code>str</code> <p>The order ID to cancel. Defaults to None.</p> <code>None</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID to cancel. Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>orderFilter</code> <code>str</code> <p>The order filter to apply. Defaults to None.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the cancellation to the exchange. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange if <code>submit</code> is True, otherwise the cancellation payload.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_create","title":"<code>order_create(symbol, amount, orderType, price=None, timeInForce='GTC', reduceOnly=False, category='linear', orderLinkId=None, submit=True, **kwargs)</code>  <code>async</code>","text":"<p>Creates a new order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade.</p> required <code>orderType</code> <code>str</code> <p>The type of order (e.g., 'Limit', 'Market').</p> required <code>price</code> <code>float</code> <p>The price for the order. Defaults to None.</p> <code>None</code> <code>timeInForce</code> <code>str</code> <p>The time-in-force for the order (e.g., 'GTC', 'FOK'). Defaults to \"GTC\".</p> <code>'GTC'</code> <code>reduceOnly</code> <code>bool</code> <p>Whether the order is reduce-only. Defaults to False.</p> <code>False</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>orderLinkId</code> <code>str</code> <p>The client order ID. Defaults to None.</p> <code>None</code> <code>submit</code> <code>bool</code> <p>If True, submits the order to the exchange, else returns the order wire. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the order.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange if <code>submit</code> is True, otherwise the order wire.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_history","title":"<code>order_history(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves the order history for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order history from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_query","title":"<code>order_query(oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>str</code> <p>Order ID in exchange</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orderbook_depth","title":"<code>orderbook_depth(symbol, category='linear', limit=25)</code>  <code>async</code>","text":"<p>Retrieves the order book depth for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>limit</code> <code>int</code> <p>The number of order book levels to retrieve. Defaults to None.</p> <code>25</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The order book depth data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_cancel_all","title":"<code>orders_cancel_all(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancels all open orders for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the exchange for the cancellation request.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_get","title":"<code>orders_get(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Get open order details.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>optional</code> <p>Retrieve orders for ticker only.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open orders.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_get_realtime","title":"<code>orders_get_realtime(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves real-time information about orders.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The real-time order information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_get","title":"<code>positions_get(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Get open position details.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>optional</code> <p>Retrieve position for ticker only.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open positions.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_info","title":"<code>positions_info(category='linear', symbol=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieves information about open positions.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to 'linear'.</p> <code>'linear'</code> <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The position information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.premium_index_kline","title":"<code>premium_index_kline(symbol, start=None, end=None, limit=None, interval='D', category='linear')</code>  <code>async</code>","text":"<p>Retrieves premium index price kline data for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT').</p> required <code>start</code> <code>int</code> <p>The start time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>end</code> <code>int</code> <p>The end time for the kline data in UNIX timestamp format. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of klines to retrieve. Defaults to None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval for the kline data (e.g., '1m', '1h'). Defaults to \"D\".</p> <code>'D'</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The premium index price kline data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generates a random client order ID (CLOID).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A randomly generated CLOID.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.server_time","title":"<code>server_time()</code>  <code>async</code>","text":"<p>Retrieves the current server time from the exchange.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The server time data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.signed_payload","title":"<code>signed_payload(payload=None, params=None, recv_window=5000)</code>","text":"<p>Signs the payload or query parameters for an authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The payload to be signed. Defaults to None.</p> <code>None</code> <code>params</code> <code>dict</code> <p>The query parameters to be signed. Defaults to None.</p> <code>None</code> <code>recv_window</code> <code>int</code> <p>The receive window for the request. Defaults to 5000.</p> <code>5000</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the request headers and the signed payload as a JSON string.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.ticker_subscribe","title":"<code>ticker_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to Ticker stream. Args:     ticker (str): Ticker symbol.     handler (coroutine): A coroutine handler for the message received.     **kwargs: Exchange wrapper specific keyword arguments.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.tickers_summary","title":"<code>tickers_summary(symbol=None, category='linear', baseCoin=None, expDate=None)</code>  <code>async</code>","text":"<p>Retrieves a summary of tickers for a given symbol or base coin.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The trading symbol (e.g., 'BTCUSDT'). Defaults to None.</p> <code>None</code> <code>category</code> <code>str</code> <p>The category of the market (e.g., 'linear', 'inverse'). Defaults to \"linear\".</p> <code>'linear'</code> <code>baseCoin</code> <code>str</code> <p>The base coin (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <code>expDate</code> <code>str</code> <p>The expiration date for futures contracts. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The ticker summary data from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to trade updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>(ts,price,sz,dir)</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from the trade stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.typed_payload","title":"<code>typed_payload(payload)</code>","text":"<p>Converts the payload's parameters to their correct data types.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The payload containing the request parameters.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The payload with corrected data types.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.Bybit.wallet_balance","title":"<code>wallet_balance(accountType='UNIFIED', coin=None)</code>  <code>async</code>","text":"<p>Retrieves the wallet balance for the specified account type.</p> <p>Parameters:</p> Name Type Description Default <code>accountType</code> <code>str</code> <p>The account type (e.g., 'UNIFIED'). Defaults to 'UNIFIED'.</p> <code>'UNIFIED'</code> <code>coin</code> <code>str</code> <p>The specific coin to retrieve the balance for (e.g., 'BTC'). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The wallet balance information from the exchange.</p>"},{"location":"wrappers/bybit/#quantpylib.wrappers.bybit.generate_signature","title":"<code>generate_signature(is_rsa, secret, param_str)</code>","text":"<p>Generates a cryptographic signature using either HMAC or RSA based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>is_rsa</code> <code>bool</code> <p>If True, uses RSA for signature generation.  If False, uses HMAC for signature generation.</p> required <code>secret</code> <code>str</code> <p>The secret key used for generating the signature.  For HMAC, this is a shared secret key.  For RSA, this is the private RSA key in PEM format.</p> required <code>param_str</code> <code>str</code> <p>The string of parameters to be signed.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The generated signature in hexadecimal format (for HMAC) or Base64-encoded string (for RSA).</p>"},{"location":"wrappers/eodhd/","title":"quantpylib.wrappers.eodhd","text":""},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd","title":"<code>Eodhd</code>","text":""},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.__init__","title":"<code>__init__(eod_key, **kwargs)</code>","text":"<p>Initialize the Eodhd instance with the API key.</p> <p>Parameters:</p> Name Type Description Default <code>eod_key</code> <code>str</code> <p>API key for accessing the Eodhd API.</p> required"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.check_exchange_open","title":"<code>check_exchange_open(exchange, **kwargs)</code>","text":"<p>Check if a specific exchange is open.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the exchange is open, False otherwise.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_delisted_tickers_in_exchange","title":"<code>get_delisted_tickers_in_exchange(exchange, **kwargs)</code>","text":"<p>Get the list of delisted tickers for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of delisted tickers for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_holidays","title":"<code>get_exchange_holidays(exchange, **kwargs)</code>","text":"<p>Get the list of holidays for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of holidays for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_hours","title":"<code>get_exchange_hours(exchange, **kwargs)</code>","text":"<p>Get the trading hours for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Trading hours for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_exchange_tz","title":"<code>get_exchange_tz(exchange, **kwargs)</code>","text":"<p>Get the timezone for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Timezone of the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_supported_exchanges","title":"<code>get_supported_exchanges(**kwargs)</code>","text":"<p>Get the list of supported exchanges.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of supported exchanges.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_dividends","title":"<code>get_ticker_dividends(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve dividend data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing dividend data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_earnings_history","title":"<code>get_ticker_earnings_history(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve earnings history data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing earnings history data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_earnings_trend","title":"<code>get_ticker_earnings_trend(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve earnings trend data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing earnings trend data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_financials","title":"<code>get_ticker_financials(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve financial statements data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing financial statements data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_fundamentals","title":"<code>get_ticker_fundamentals(ticker, exchange='US', **kwargs)</code>","text":"<p>Get fundamental data for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Fundamental data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_historical_mcap","title":"<code>get_ticker_historical_mcap(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve historical market capitalization data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing historical market capitalization data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_insider_txn","title":"<code>get_ticker_insider_txn(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve insider transaction data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing insider transaction data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve metadata for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata information for the ticker.</p> Notes <p>If the exchange is \"CC\", the metadata will be retrieved using the 'get_ticker_fundamentals' function.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_shares_stats","title":"<code>get_ticker_shares_stats(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve shares statistics for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing shares statistics for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_splits","title":"<code>get_ticker_splits(ticker, exchange, **kwargs)</code>","text":"<p>Retrieve split data for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing split data for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_ticker_stat_snapshot","title":"<code>get_ticker_stat_snapshot(ticker, exchange='US', **kwargs)</code>","text":"<p>Retrieve a snapshot of various statistics for a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>exchange</code> <code>str</code> <p>The exchange where the asset is traded. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Snapshot of various statistics for the ticker.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(exchange, **kwargs)</code>","text":"<p>Get the list of tickers for a specific exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Exchange name.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the list of tickers for the exchange.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, exchange='US', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.get_trade_ticks","title":"<code>get_trade_ticks(ticker, start, end, exchange='US', **kwargs)</code>","text":"<p>Retrieve ticker ticks data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>exchange</code> <code>str</code> <p>Exchange name. Defaults to \"US\".</p> <code>'US'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the ticker ticks data.</p>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Stream market data for a given ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>endpoint</code> <p>Endpoint for streaming. Valid values are: <code>[\"us\", \"us-quote\", \"forex\", \"crypto\"]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Terminate stream for ticker data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>endpoint</code> <p>Endpoint for streaming. Valid values are: <code>[\"us\", \"us-quote\", \"forex\", \"crypto\"]</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/eodhd/#quantpylib.wrappers.eodhd.Eodhd.query_engine","title":"<code>query_engine(query, **kwargs)</code>","text":"<p>Perform a query using the Eodhd search engine.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the results of the query.</p>"},{"location":"wrappers/hyperliquid/","title":"quantpylib.wrappers.hyperliquid","text":"<p><code>quantpylib.wrappers.hyperliquid</code> module is our official Hyperliquid wrapper SDK implementing the endpoints for perpetuals and spot trading. The library supports a fully asynchronous endpoint for efficiency and lightweight  concurrency. The websocket manager handles reconnections and resubsriptions under network errors and upgrades.</p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions.</p>"},{"location":"wrappers/hyperliquid/#examples","title":"Examples","text":"<p>We would demonstrate some endpoints. Refer to full documentation for details. For demonstrations, let us first make some imports we would like to use <pre><code>import os \nimport time\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.standards import Period\nfrom quantpylib.wrappers.hyperliquid import Hyperliquid\n\nasync def print_handler(msg): print(msg)\n\nasync def main():\n    hyp = Hyperliquid(\n        key=os.getenv(\"HYP_DEMO\"), #should be your vault address, if trading for a vault\n        secret=os.getenv(\"HYP_KEY\"), #secret key\n    )\n    await hyp.init_client()\n    #...examples go here\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#navigating-assets","title":"Navigating Assets","text":"<p>Note that perpeutals and their asset identifiers are the same. That is, <code>SOL</code> has the identifier <code>SOL</code> - this is not true of spot pairs. In most of the endpoints, the canonical name is not recognised, and their recognised identifier  shall be given the moniker <code>accredited_name</code>. We may convert between the two: <pre><code>hyp.get_accredited_name(\"JEFF/USDC\")\nhyp.get_canonical_name(\"@3\")\n</code></pre></p> <p>Most of our endpoints that may benefit from this  conversion automatically allows this with the flag <code>is_canonical</code> and <code>as_canonical</code> to interact and parse hpl server requests and responses respectively. </p>"},{"location":"wrappers/hyperliquid/#account","title":"Account","text":"<p>We may get account balances, subscribe to fill events, get rate limits easily <pre><code>bal = await hyp.account_balance()\nawait hyp.account_fill_subscribe(handler=print_handler)\nlimits = await hyp.account_rate_limits()\n</code></pre> We can get perpeutals contract specs: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=True)\n</code></pre> or spot contract specs: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=False)\n</code></pre> which gives: <pre><code>{'@1': {'price_precision': 6, 'quote_precision': 8, 'quantity_precision': 2, 'min_notional': 10.0}, '@2': {'price_precision': 8, 'quote_precision': 8, 'quantity_precision': 0, 'min_notional': 10.0}, ... }\n</code></pre> The spot endpoints by default assume <code>accredited_name</code> as identifiers, but we can request: <pre><code>specs = await hyp.contract_specifications(is_perpetuals=False,as_canonical=True)\n</code></pre> and get instead: <pre><code>{'HFUN/USDC': {'price_precision': 6, 'quote_precision': 8, 'quantity_precision': 2, 'min_notional': 10.0}, 'LICK/USDC': {'price_precision': 8, 'quote_precision': 8, 'quantity_precision': 0, 'min_notional': 10.0}, ... }\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#positions","title":"Positions","text":"<p>We can get account perp-positions or spot-positions/balances: <pre><code>pos = await hyp.positions_get()\npos = await hyp.positions_get(is_perpetuals=False)\nprint(pos)\n</code></pre> which gives something like: <pre><code>{'USDC': {'ticker': 'USDC', 'amount': Decimal('12412.04185909'), 'entry': 1, 'value': Decimal('12412.04185909'), 'unrealized_pnl': 0}, 'PURR': {'ticker': 'PURR', 'amount': Decimal('12345.24577'), 'entry': Decimal('0.123456'), 'value': Decimal('7890.1234'), 'unrealized_pnl': Decimal('347.25542313685')}, ... }\n</code></pre> or force it to look like usdc-positions: <pre><code>pos = await hyp.positions_get(is_perpetuals=False,as_usdc_pair=True)\n</code></pre> <pre><code>{'PURR/USDC': {'ticker': 'PURR/USDC', 'amount': Decimal('dadas.gsdg'), 'entry': Decimal('0.dasdas'), 'value': Decimal('gdfsf.das'), 'unrealized_pnl': Decimal('sa.242113')}, 'HFUN/USDC': {'ticker': 'HFUN/USDC', 'amount': Decimal('3.1415926535'), 'entry': Decimal('dasd.dfasdf'), 'value': Decimal('DAD.ASF'), 'unrealized_pnl': Decimal('245.32242')}, ...}\n</code></pre> This gives us a snapshot of our positions from a HTTP-request, but we can also keep a local copy of the position state using: <pre><code>await hyp.positions_mirror()\nawait hyp.positions_mirror(on_update=print_handler)\n</code></pre> the <code>on_update</code> is optional, and the alive, local copy of positions can be retrieved here: <pre><code>pos = hyp.positions_peek()\n</code></pre> This is handled internally by the websocket subscriptions made available. All <code>get-mirror-peek</code> trio's work similarly. <code>get</code> is the HTTP request-response, <code>mirror</code> is the mirror-copy maintained using socket subscriptions and <code>peek</code> requires a <code>mirror</code> request and just echoes the internal copy.</p>"},{"location":"wrappers/hyperliquid/#orders","title":"Orders","text":"<p>Of course you can make orders: <pre><code>ord = await hyp.limit_order(ticker=\"SOL\",amount=-1,price=1000)\nord = await hyp.limit_order(ticker=\"@1\",amount=10,price=5)\nord = await hyp.limit_order(ticker=\"HFUN/USDC\",is_canonical=True,amount=10,price=5)\n</code></pre> We also give options to submit parent-child orders involving tp-sl triggers, as in their web-interface: <pre><code>ord = await hyp.limit_order(ticker=\"SOL\",amount=-1,price=1000,tp=400,sl=1200)\n</code></pre> And the market-order: <pre><code>ord = await hyp.market_order(ticker=\"SOL\",amount=-1)\n</code></pre></p> <p>Order states can be <code>get-mirror-peek</code>-ed: <pre><code>print(await hyp.orders_get(as_canonical=False))\nawait hyp.orders_mirror(as_canonical=False, on_update=print_handler)\nawait asyncio.sleep(10)\nhyp.orders_peek()\n</code></pre></p> <p>or simply subscribed to for custom handling: <pre><code>await hyp.order_updates_subscribe(handler=print_handler)\n</code></pre></p> <p>Of course you can cancel the orders (by ticker and id, all for some ticker, or all tickers): <pre><code>await hyp.cancel_open_orders(ticker=\"SOL\",is_canonical=False)\nawait hyp.cancel_order(\"JEFF/USDC\", oid=1234, is_canonical=True)\n</code></pre></p>"},{"location":"wrappers/hyperliquid/#data","title":"Data","text":"<p>You can of course retrieve data. You can get all mids as snapshot or as subscription: <pre><code>mids = await hyp.get_all_mids()\nawait hyp.all_mids_subscribe(handler=print_handler)\n</code></pre> The subscriptions give response like this: <pre><code>{'@1': '22.253', '@10': '0.00043966', '@11': '0.00054', '@12': '0.00060734', '@13': '0.012098', '@14': '0.00057891', '@15': '0. ...\n'ARK': '0.361', 'ATOM': '5.7538', 'AVAX': '25.343', 'BADGER': '3.1786', 'BANANA': '48.7905', 'BCH': '419.195', 'BIGTIME': '0.094512', 'BLAST': '0.013506', 'BLUR': '0.17726', 'BLZ': '0.164115', 'BNB': '569.025', ... }\n</code></pre> but again you can ask for canonical schema: <pre><code>await hyp.all_mids_subscribe(handler=print_handler,as_canonical=True)\n</code></pre> <pre><code>{'HFUN/USDC': '22.236', 'GMEOW/USDC': '0.00043966', 'PEPE/USDC': '0.00054', 'XULIAN/USDC': '0.00060734', ... }\n</code></pre></p> <p>You can unsubscribe (you can do this for all websocket subscriptions): <pre><code>await hyp.all_mids_unsubscribe()\n</code></pre></p> <p>The l2-book also has a <code>get-mirror-peek</code> functionality, as well as the <code>subscribe</code> functionality. You probably get the hang of it: <pre><code>await hyp.l2_book_get(ticker=\"BTC\")\nawait hyp.l2_book_mirror(ticker=\"BTC\",on_update=print_handler)\nhyp.l2_book_peek()\nawait hyp.l2_book_subscribe(\"SOL\",handler=print_handler)\n</code></pre> In hpl cases, the subscription actually returns a book snapshot rather than incremental updates, so the mirror states and subscription  updates are similar. However, the <code>l2_book_mirror</code> has powerful add-ons: <pre><code>ob = await hyp.l2_book_mirror(\"SOL\",depth=20,buffer_size=1000,as_dict=False)\nawait asyncio.sleep(15)\nprint(ob.buffer_len()) #26\n</code></pre> By specifying <code>as_dict=False</code>, we get a instance of the <code>quantpylib.hft.lob.LOB</code> object. This object is 'live', in that  it is collecting a buffer of orderbook states in the background. There are utility functions we can call on <code>LOB</code> object instances, such as  <code>get_spread</code>, <code>get_vol</code>, <code>get_vamp</code> that are useful for market modelling.</p> <p>We have other endpoints, of course: <pre><code>candles = await hyp.candle_historical( #candles for `BTC` on `15m` intervals for the past hour\n    \"BTC\",\n    interval=\"15m\",\n    start=int(time.time()) * 1000 - 60 * 60 * 1000,\n    end=int(time.time()) * 1000\n)\ndf = await hyp.get_trade_bars( #OHLCV DF\n    ticker=\"BTC\",\n    start=datetime(2022,12,14),\n    end=datetime.now(),\n    granularity=Period.DAILY,\n    granularity_multiplier=1\n)\nprint(df)\n</code></pre> A host of other endpoints such as user-funding,transactions, funding rates, transfers, account leverage updates and so on are supported...refer to docs.</p>"},{"location":"wrappers/hyperliquid/#documentation","title":"Documentation","text":""},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Channel","title":"<code>Channel</code>","text":"<p>Represents various socket subscription channels.</p> <p>Attributes:</p> Name Type Description <code>ALL_MIDS</code> <code>str</code> <p>The \"allMids\" channel.</p> <code>NOTIFICATION</code> <code>str</code> <p>The \"notification\" channel.</p> <code>WEBDATA</code> <code>str</code> <p>The \"webData2\" channel.</p> <code>CANDLE</code> <code>str</code> <p>The \"candle\" channel.</p> <code>L2BOOK</code> <code>str</code> <p>The \"l2Book\" channel.</p> <code>TRADES</code> <code>str</code> <p>The \"trades\" channel.</p> <code>ORDER_UPDATES</code> <code>str</code> <p>The \"orderUpdates\" channel.</p> <code>USER_EVENTS</code> <code>str</code> <p>The \"user\" channel for user events.</p> <code>USER_FILLS</code> <code>str</code> <p>The \"userFills\" channel.</p> <code>USER_FUNDINGS</code> <code>str</code> <p>The \"userFundings\" channel.</p> <code>USER_LEDGER_UPDATES</code> <code>str</code> <p>The \"userNonFundingLedgerUpdates\" channel.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid","title":"<code>Hyperliquid</code>","text":""},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.__init__","title":"<code>__init__(key='', secret='', **kwargs)</code>","text":"<p>Initializes the Hyperliquid instance.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The public or vault address.</p> <code>''</code> <code>secret</code> <code>str</code> <p>The secret key.</p> <code>''</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order fill events.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.account_rate_limits","title":"<code>account_rate_limits()</code>  <code>async</code>","text":"<p>Get the rate limits for the user's account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the current rate limits and usage statistics for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids","title":"<code>all_mids()</code>  <code>async</code>","text":"<p>Retrieve the mid-prices of all assets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the mid-prices of all assets available on the exchange.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, standardize_schema=True, as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid prices.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to standard schema.</p> <code>True</code> <code>as_canonical</code> <code>(bool, False)</code> <p>If True, the mid prices are returned with canonical names.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid prices.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. If <code>is_canonical</code> is True, this should be the canonical name. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for further customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cancel_order","title":"<code>cancel_order(ticker, oid=None, cloid=None, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.candle_historical","title":"<code>candle_historical(ticker, interval, start, end)</code>  <code>async</code>","text":"<p>Retrieve historical candlestick data for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>interval</code> <code>str</code> <p>The time interval for each candlestick (e.g., '1m', '1h').</p> required <code>start</code> <code>int</code> <p>The start time for the data range in UNIX ms timestamp format.</p> required <code>end</code> <code>int</code> <p>The end time for the data range in UNIX ms timestamp format.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the historical candlestick data for the specified ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.cleanup","title":"<code>cleanup()</code>  <code>async</code>","text":"<p>Cleans up open sessions with HPL server</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.contract_specifications","title":"<code>contract_specifications(is_perpetuals=True, as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>Specifies whether to fetch perpetual contracts. Defaults to True.</p> <code>True</code> <code>as_canonical</code> <code>bool</code> <p>If True, returns the contract specifications using canonical names. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_accredited_name","title":"<code>get_accredited_name(canonical)</code>","text":"<p>Retrieves the accredited name for a given canonical name. For perpetuals, this is an identity mapping. For spot, (for instance) JEFF/USDC maps to @4.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The accredited name associated with the canonical name.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_all_mids","title":"<code>get_all_mids(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The symbol of the specific contract for which to retrieve the mid-price.                  If not provided, mid-prices for all contracts will be returned. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Decimal</code> <p>The mid-price of the specified ticker if <code>ticker</code> is provided.</p> <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_canonical_name","title":"<code>get_canonical_name(name, return_unmapped=False)</code>","text":"<p>Retrieves the canonical name for a given ticker. For perpetuals, this is an identity mapping. For spot, (for instance) @4 maps to JEFF/USDC.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ticker name.</p> required <code>return_unmapped</code> <code>bool</code> <p>If True, returns the name back to the caller if no mapping is found.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The canonical name associated with the ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_funding_rates","title":"<code>get_funding_rates(ticker, start, end, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve funding rates data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the funding rates data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_lot_precision","title":"<code>get_lot_precision(ticker, is_canonical=False)</code>","text":"<p>Get the lot precision for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places used for the asset's lot size precision.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_nonce","title":"<code>get_nonce()</code>","text":"<p>Get a unique nonce value using a nonce buffer to ensure no overlaps  between exchange requests.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>A unique nonce value.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_price_precision","title":"<code>get_price_precision(ticker, is_canonical=False)</code>","text":"<p>Get the price precision for a specified asset. Note that prices quoted  are less of price precision and 5 significant figures.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places used for the asset's price precision.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, kline_close=False, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve trade bars data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset.</p> required <code>start</code> <code>datetime</code> <p>Start datetime for the data retrieval.</p> required <code>end</code> <code>datetime</code> <p>End datetime for the data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>Granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>Multiplier for the granularity.</p> required <code>kline_close</code> <code>bool</code> <p>Timestamp candle by the candles' start or end timestamp. Defaults to <code>False</code>, which uses start time.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the trade bars data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the exchange client with important metadata for mapping tickers to asset ids,  contract precision and mapping. Should be called upon object initialization.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_get","title":"<code>l2_book_get(ticker, nsigfig=None, depth=None, depth_cum=True)</code>  <code>async</code>","text":"<p>Retrieve L2 snapshot for a given coin.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>nsigfig</code> <code>int</code> <p>Number of significant figures requested. Defaults to None.</p> <code>None</code> <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code>.</p> <code>None</code> <code>depth_cum</code> <code>bool</code> <p>Flag indicating whether to return cumulative depth or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the L2 snapshot information.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=100, buffer_size=100, as_dict=True, on_update=None, apply_shadow_depth=False, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation, if <code>as_dict</code> is <code>False</code>.</p> <code>100</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code>.</p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>is_canonical</code> <code>(bool, False)</code> <p>If the ticker passed in is a canonical name for the spot pairs.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, is_canonical=False, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>is_canonical</code> <code>(bool, False)</code> <p>If the ticker passed in is a canonical name for the spot pairs.</p> <code>False</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.l2_snapshot","title":"<code>l2_snapshot(ticker, nsigfig=None)</code>  <code>async</code>","text":"<p>Get a Level 2 snapshot for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>nsigfig</code> <code>int</code> <p>Number of significant figures for the data. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the L2 order book snapshot for the specified ticker.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.limit_order","title":"<code>limit_order(ticker, amount, price, tif='Gtc', reduce_only=False, cloid=None, tp=None, sl=None, trigger_market=True, round_price=False, round_size=False, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.market_order","title":"<code>market_order(ticker, amount, reduce_only=False, cloid=None, is_canonical=False, slippage_tolerance=0.05, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>slippage_tolerance</code> <code>float</code> <p>The maximum acceptable slippage, expressed as a percentage. Defaults to 0.05 (5%).</p> <code>0.05</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_cancel","title":"<code>order_cancel(ticker, oid, submit=True)</code>  <code>async</code>","text":"<p>Cancel a specific order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>oid</code> <code>int</code> <p>The order ID of the order to be canceled.</p> required <code>submit</code> <code>bool</code> <p>If True, the cancel action is submitted. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order cancellation request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_cancel_cloid","title":"<code>order_cancel_cloid(ticker, cloid, submit=True)</code>  <code>async</code>","text":"<p>Cancel an order using client order ID (Cloid).</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>cloid</code> <code>str</code> <p>The client order ID of the order to be canceled.</p> required <code>submit</code> <code>bool</code> <p>If True, the cancel action is submitted. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order cancellation request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_create","title":"<code>order_create(ticker, amount, price, tif='Gtc', reduce_only=False, cloid=None, tp=None, sl=None, trigger_market=True, grouping='na', round_price=False, round_size=False, submit=True, is_canonical=False)</code>  <code>async</code>","text":"<p>Create a new order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade. Positive for buy (long), negative for sell (short).</p> required <code>price</code> <code>float or Decimal</code> <p>The limit price for the order.</p> required <code>tif</code> <code>str</code> <p>Time in force for the order. Defaults to \"Gtc\" (Good 'til canceled).</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>If True, the order can only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for tracking. Defaults to None.</p> <code>None</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>grouping</code> <code>str</code> <p>Order grouping type. Defaults to \"na\".</p> <code>'na'</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>submit</code> <code>bool</code> <p>If True, the order is submitted immediately, otherwise the order schema is returned. Defaults to True.</p> <code>True</code> <code>is_canonical</code> <code>bool</code> <p>If True, the ticker is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order creation or the action object if <code>submit</code> is False.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_fills","title":"<code>order_fills()</code>  <code>async</code>","text":"<p>Get all filled orders.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all filled orders for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_fills_by_time","title":"<code>order_fills_by_time(start, end)</code>  <code>async</code>","text":"<p>Get filled orders within a specific time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The start time for the data range in UNIX timestamp format.</p> required <code>end</code> <code>int</code> <p>The end time for the data range in UNIX timestamp format.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all filled orders within the specified time range.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_market","title":"<code>order_market(ticker, amount, reduce_only=False, slippage_tolerance=0.05, cloid=None, is_canonical=False, round_size=False)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The quantity of the asset to trade. Positive for buy (long), negative for sell (short).</p> required <code>reduce_only</code> <code>bool</code> <p>If True, the order can only reduce an existing position. Defaults to False.</p> <code>False</code> <code>slippage_tolerance</code> <code>float</code> <p>The acceptable slippage percentage. Defaults to 0.05.</p> <code>0.05</code> <code>cloid</code> <code>str</code> <p>Client order ID for tracking. Defaults to None.</p> <code>None</code> <code>is_canonical</code> <code>bool</code> <p>If True, the ticker is treated as a canonical name. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the market order submission.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_modify","title":"<code>order_modify(ticker, amount, price, oid=None, cloid=None, tif='Gtc', reduce_only=False, tp=None, sl=None, trigger_market=True, round_price=False, round_size=False, submit=True)</code>  <code>async</code>","text":"<p>Modify an existing order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The positive or negative quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The new price for the order.</p> required <code>oid</code> <code>int</code> <p>The order ID of the order to modify. Defaults to None.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>The client order ID of the order to modify. Defaults to None.</p> <code>None</code> <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"Gtc\" (Good 'til canceled)                  - \"Alo\" (Add liquidity only)                  - \"Ioc\" (Immediate or cancel)</p> <code>'Gtc'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>tp</code> <code>float</code> <p>Take profit price. Defaults to None.</p> <code>None</code> <code>sl</code> <code>float</code> <p>Stop loss price. Defaults to None.</p> <code>None</code> <code>trigger_market</code> <code>bool</code> <p>Whether the tpsl trigger (if not None) is a market order. Defaults to True.</p> <code>True</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>submit</code> <code>bool</code> <p>If True, the modification is submitted immediately, otherwise the order schema is returned. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the order modification request if <code>submit</code> is True, otherwise the action dictionary.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_query","title":"<code>order_query(oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using order ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(str, int)</code> <p>Order ID in exchange</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_status","title":"<code>order_status(id)</code>  <code>async</code>","text":"<p>Get the status of a specific order.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or str</code> <p>Unique identifier as order ID or client order ID.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the status and details of the specified order.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_cancel","title":"<code>orders_cancel(order_actions)</code>  <code>async</code>","text":"<p>Cancel multiple orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be canceled.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders cancellation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_cancel_cloid","title":"<code>orders_cancel_cloid(order_actions)</code>  <code>async</code>","text":"<p>Cancel multiple orders using client order IDs (Cloids).</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be canceled using Cloids.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders cancellation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_create","title":"<code>orders_create(order_actions, grouping='na')</code>  <code>async</code>","text":"<p>Create new orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the actions for creating orders.</p> required <code>grouping</code> <code>str</code> <p>The grouping type for the orders. Defaults to \"na\".</p> <code>'na'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders creation request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_get","title":"<code>orders_get(as_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Get all open order details.</p> <p>Parameters:</p> Name Type Description Default <code>as_canonical</code> <code>bool</code> <p>If True, the method returns tickers in their canonical form. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of all open orders. Each key is the order ID (<code>oid</code>), with value dict: - markets.TICKER: The asset's ticker symbol, either in standard or canonical form. - markets.ORDER_ID: The unique identifier of the order. - markets.ORDER_CLOID: The client order ID. - markets.LIMIT_PRICE: The limit price of the order. - markets.ORDER_AMOUNT: The original size of the order. - markets.ORDER_FILLED_SIZE: The remaining size of the order yet to be filled. - markets.ORDER_STATUS: The status of the order. - markets.TIMESTAMP: The timestamp when the order was created.</p> Notes <p>See the Hyperliquid documentation for more details: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_mirror","title":"<code>orders_mirror(as_canonical=False, on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_canonical</code> <code>bool</code> <p>If True, the method returns tickers in their canonical form. Defaults to False.</p> <code>False</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_modify","title":"<code>orders_modify(order_actions)</code>  <code>async</code>","text":"<p>Modify multiple existing orders.</p> <p>Parameters:</p> Name Type Description Default <code>order_actions</code> <code>list</code> <p>A list of dictionaries representing the orders to be modified.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the orders modification request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_open","title":"<code>orders_open()</code>  <code>async</code>","text":"<p>Get all open orders.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all open orders for the user's account.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_open_frontend","title":"<code>orders_open_frontend()</code>  <code>async</code>","text":"<p>Get all open orders with additional frontend-specific information.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing details of all open orders for the user's account, with extra information for frontend use.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_account","title":"<code>perpetuals_account()</code>  <code>async</code>","text":"<p>Retrieve account information related to perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing information about the user's account in relation to perpetual contracts, including positions, balances, and other relevant data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_contexts","title":"<code>perpetuals_contexts()</code>  <code>async</code>","text":"<p>Retrieve context information for perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing context information for perpetual contracts, which may include details about market conditions and other relevant data.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_funding_historical","title":"<code>perpetuals_funding_historical(ticker, start=int(datetime.now(pytz.utc) - timedelta(days=14).timestamp() * 1000), end=None)</code>  <code>async</code>","text":"<p>Retrieve funding history for a given coin.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the coin.</p> required <code>start</code> <code>int</code> <p>The start time for the data range in milliseconds. Defaults to 14 days ago from the current time.</p> <code>int(timestamp() * 1000)</code> <code>end</code> <code>int</code> <p>The end time for the data range in milliseconds. Defaults to None.</p> <code>None</code> Notes <p>For more details, refer to the Hyperliquid API documentation: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-historical-funding-rates</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_metadata","title":"<code>perpetuals_metadata()</code>  <code>async</code>","text":"<p>Retrieve metadata for all perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing metadata for all perpetual contracts, including information about contract specifications and trading rules.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.perpetuals_user_funding","title":"<code>perpetuals_user_funding()</code>  <code>async</code>","text":"<p>Retrieve the user's funding payment history for perpetual contracts.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the user's funding payment history, detailing the amounts paid or received as funding fees over time.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_get","title":"<code>positions_get(is_perpetuals=True, as_usdc_pair=False, **kwargs)</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>If True, retrieves positions for perpetual contracts. If False, retrieves spot balances. Defaults to True.</p> <code>True</code> <code>as_usdc_pair</code> <code>bool</code> <p>If True, returns spot balances as USDC pairs, otherwise as token balances. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details of the open positions.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_mirror","title":"<code>positions_mirror(is_perpetuals=True, on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>is_perpetuals</code> <code>bool</code> <p>If True, retrieves positions for perpetual contracts. If False, retrieves spot balances. Defaults to True.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.rand_cloid","title":"<code>rand_cloid(start='', end='', include_prefix=True, **kwargs)</code>","text":"<p>Generate a random string (cloid) consisting of hexadecimal characters, optionally with a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <code>include_prefix</code> <code>bool</code> <p>If True, includes the '0x' prefix at the beginning of the string. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for future extensibility.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A random hexadecimal string with a total length of 32 characters,  including the optional 'start' and 'end' strings, and an optional '0x' prefix.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.referral","title":"<code>referral()</code>  <code>async</code>","text":"<p>Retrieve referral information for the user's account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing details related to the user's referral program, such as referral code, referral rewards, and the status of referred users.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.request_l1_action","title":"<code>request_l1_action(action, nonce, signature)</code>  <code>async</code>","text":"<p>Submit a Level 1 (L1) action to the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to be performed.</p> required <code>nonce</code> <code>int</code> <p>A unique nonce for the action to prevent replay attacks.</p> required <code>signature</code> <code>str</code> <p>The signature validating the action.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the action request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_balances","title":"<code>spot_balances()</code>  <code>async</code>","text":"<p>Retrieve the user's spot balances.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the user's spot balances for various assets, detailing the amount held and other relevant account information.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_contexts","title":"<code>spot_contexts()</code>  <code>async</code>","text":"<p>Retrieve context information for spot markets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing context information for spot markets.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_metadata","title":"<code>spot_metadata()</code>  <code>async</code>","text":"<p>Retrieve metadata for all spot markets.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing metadata for all spot markets, including information such as trading pairs, asset details, and other relevant market specifications.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.spot_perp_transfer","title":"<code>spot_perp_transfer(amount, spot_to_perp=True)</code>  <code>async</code>","text":"<p>Transfer funds between spot and perpetual accounts.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <code>spot_to_perp</code> <code>bool</code> <p>If True, transfer from spot to perpetual. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.subaccount_transfer","title":"<code>subaccount_transfer(subaccount, is_deposit, amount)</code>  <code>async</code>","text":"<p>Transfer funds to or from a subaccount.</p> <p>Parameters:</p> Name Type Description Default <code>subaccount</code> <code>str</code> <p>The identifier for the subaccount.</p> required <code>is_deposit</code> <code>bool</code> <p>If True, the transfer is a deposit. If False, it is a withdrawal.</p> required <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the subaccount transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to ticker trades.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset. If <code>is_canonical</code> is True, this should be the canonical name.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for processing the received trade messages.</p> required <code>standardize_schema</code> <code>bool</code> <p>If True, processes the incoming message to a standardized format. Defaults to True.</p> <code>True</code> <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, is_canonical=False, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from trade data.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the asset. If <code>is_canonical</code> is True, this should be the canonical name.</p> required <code>is_canonical</code> <code>bool</code> <p>If True, the <code>ticker</code> is treated as a canonical name and converted to the accredited name. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Coroutine</code> <p>A coroutine that can be awaited to complete the unsubscription process.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.transfer_l1","title":"<code>transfer_l1(amount, dest, asset='usdc')</code>  <code>async</code>","text":"<p>Transfer l1 funds.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <code>dest</code> <code>str</code> <p>The destination address.</p> required <code>asset</code> <code>str</code> <p>The asset to transfer (default is \"usdc\").</p> <code>'usdc'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.update_iso_margin","title":"<code>update_iso_margin(ticker, amount)</code>  <code>async</code>","text":"<p>Update the isolated margin for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>amount</code> <code>float</code> <p>The amount to adjust the isolated margin.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the isolated margin update request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.update_leverage","title":"<code>update_leverage(ticker, leverage, is_cross=True)</code>  <code>async</code>","text":"<p>Update the leverage for a specified asset.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol of the asset.</p> required <code>leverage</code> <code>float</code> <p>The leverage multiplier to set.</p> required <code>is_cross</code> <code>bool</code> <p>If True, sets cross-margin mode. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the leverage update request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.vault_transfer","title":"<code>vault_transfer(vault, is_deposit, amount)</code>  <code>async</code>","text":"<p>Transfer funds to or from a vault.</p> <p>Parameters:</p> Name Type Description Default <code>vault</code> <code>str</code> <p>The address of the vault.</p> required <code>is_deposit</code> <code>bool</code> <p>If True, the transfer is a deposit. If False, it is a withdrawal.</p> required <code>amount</code> <code>float</code> <p>The amount to transfer.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the vault transfer request.</p>"},{"location":"wrappers/hyperliquid/#quantpylib.wrappers.hyperliquid.Hyperliquid.withdrawal_request","title":"<code>withdrawal_request(amount, dest)</code>  <code>async</code>","text":"<p>Request a withdrawal from the bridge.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount to withdraw.</p> required <code>dest</code> <code>str</code> <p>The destination address.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The result of the withdrawal request.</p>"},{"location":"wrappers/oanda/","title":"quantpylib.wrappers.oanda","text":""},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda","title":"<code>Oanda</code>","text":"<p>A class for interacting with Oanda API for CFD data.    </p> Read <p>https://developer.oanda.com/rest-live-v20/introduction/</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.__init__","title":"<code>__init__(account_id, secret, env='practice', **kwargs)</code>","text":"<p>Initialize the Oanda instance with the account ID, API token secret, and environment.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>str</code> <p>Oanda account ID.</p> required <code>secret</code> <code>str</code> <p>Oanda API token secret.</p> required <code>env</code> <code>str</code> <p>Environment type, either \"practice\" or \"live\".</p> <code>'practice'</code>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_ticker_metadata","title":"<code>get_ticker_metadata(ticker, **kwargs)</code>","text":"<p>Retrieve metadata for the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata for the specified ticker.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_tickers_in_exchange","title":"<code>get_tickers_in_exchange(**kwargs)</code>","text":"<p>Retrieve the list of tickers available in the Oanda account.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of tickers available in the Oanda account.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve OHLCV trade bar data for the specified ticker and time range.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <code>start</code> <code>datetime</code> <p>The start date and time for data retrieval.</p> required <code>end</code> <code>datetime</code> <p>The end date and time for data retrieval.</p> required <code>granularity</code> <code>Period</code> <p>The period type for the OHLCV bars.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The granularity multiplier.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: The OHLCV trade bar data for the specified ticker and time range.</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.l1_book_subscribe","title":"<code>l1_book_subscribe(ticker, handler, **kwargs)</code>  <code>async</code>","text":"<p>Start streaming market data for the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Trading instrument ticker.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <p>Returns:     None</p>"},{"location":"wrappers/oanda/#quantpylib.wrappers.oanda.Oanda.l1_book_unsubscribe","title":"<code>l1_book_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Close the streaming for market data of the specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The trading instrument ticker.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"wrappers/paradex/","title":"quantpylib.wrappers.paradex","text":"<p><code>quantpylib.wrappers.paradex</code> module is our official Paradex wrapper SDK implementing the endpoints for perpetuals trading. The library supports a fully asynchronous endpoint for efficiency and lightweight  concurrency. The websocket manager handles reconnections and resubsriptions under network errors and upgrades.</p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions.</p>"},{"location":"wrappers/paradex/#examples","title":"Examples","text":"<p>We would demonstrate some endpoints. Refer to full documentation for details. <pre><code>import os \nimport pytz\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.wrappers.paradex import Paradex\n\nasync def print_handler(msg): \n    print(msg)\n\nasync def main():\n    '''using the SDK'''\n    pdx = Paradex(\n        key=os.getenv(\"ETH_KEY\"),\n        l2_secret=os.getenv(\"PARADEX_SECRET\"),\n    )\n    '''quantpylib.gateway endpoints'''\n    await pdx.init_client()\n    print(pdx.get_price_precision(\"BTC-USD-PERP\"))\n    print(pdx.get_lot_precision(\"BTC-USD-PERP\"))\n\n    '''ACCOUNT ENDPOINTS'''\n    pprint(await pdx.account_balance())\n    await pdx.account_fill_subscribe(handler=print_handler)\n\n    '''EXCHANGE ENDPOINTS'''\n    pprint(await pdx.contract_specifications())\n    pprint(await pdx.get_funding_info())\n\n    '''EXECUTOR ENDPOINTS'''\n    cloid = pdx.rand_cloid()\n    print(cloid)\n    pprint(await pdx.get_all_mids())\n    pprint(await pdx.get_all_marks())\n    pprint(await pdx.limit_order(ticker=\"SOL-USD-PERP\",amount=1,price=99.99,cloid=cloid))\n    pprint(await pdx.cancel_open_orders()) #or use ticker=\"SOL-USD-PERP\"\n    pprint(await pdx.cancel_order(ticker=\"SOL-USD-PERP\",cloid=cloid)) #or use oid\n    pprint(await pdx.market_order(ticker=\"SOL-USD-PERP\",amount=-0.5))\n    pprint(await pdx.l2_book_get(ticker=\"BTC-USD-PERP\"))\n    await pdx.l2_book_mirror(ticker=\"BTC-USD-PERP\",on_update=print_handler)\n    await pdx.l2_book_subscribe(ticker=\"BTC-USD-PERP\",handler=print_handler)\n    await pdx.trades_subscribe(ticker=\"BTC-USD-PERP\",handler=print_handler)\n    await pdx.all_mids_subscribe(handler=print_handler)\n    await pdx.oracle_subscribe(handler=print_handler) #get USDC/USD oracle\n\n    '''ORDERS ENDPOINTS'''\n    pprint(await pdx.order_query(ticker='SOL-USD-PERP',cloid='1234'))\n    pprint(await pdx.orders_get())\n    await pdx.orders_mirror(on_update=print_handler)\n    await pdx.order_updates_subscribe(handler=print_handler)\n\n    '''POSITIONS ENDPOINTS'''\n    pprint(await pdx.positions_get())\n    await pdx.positions_mirror(on_update=print_handler)\n\n    '''DATAPOLLER ENDPOINTS'''\n    # pprint(await pdx.get_trade_bars(\n    #     ticker='BTC-USD-PERP',\n    #     start=datetime(2021,1,1, tzinfo=pytz.utc),\n    #     end=datetime.now(pytz.utc),\n    #     granularity=Period.HOURLY,\n    #     granularity_multiplier=1,\n    # ))\n\n    '''raw exchange endpoints API - refer to docs for the other method implementations'''\n    pprint(await pdx.get_account())\n    pprint(await pdx.get_profile())\n    pprint(await pdx.get_balances())\n    pprint(await pdx.get_fills())\n    pprint(await pdx.get_tradebusts())\n    #&gt;... many more\n    await asyncio.sleep(1e9)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> </p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex","title":"<code>Paradex</code>","text":""},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.__init__","title":"<code>__init__(key=None, secret=None, l2_secret=None)</code>","text":"<p>Instantiates the Paradex wrapper class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Ethereum L1 public address.</p> <code>None</code> <code>secret</code> <code>str</code> <p>Ethereum L1 private key.</p> <code>None</code> <code>l2_secret</code> <code>str</code> <p>Starknet L2 private key.</p> <code>None</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to account fill updates.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>Coroutine handler receiving the account fill messages.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe to account fill updates.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid-price updates for all tickers.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid-price updates for all tickers.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.cancel_all_orders","title":"<code>cancel_all_orders(market=None)</code>  <code>async</code>","text":"<p>Cancel all orders.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol. Defaults to None (cancel all open orders).</p> <code>None</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for further customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request. Returns None if no open orders are found or no orders are canceled.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.cancel_order","title":"<code>cancel_order(oid=None, cloid=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>oid</code> <code>int</code> <p>Order ID to cancel.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID to cancel.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.cancel_order_by_cloid","title":"<code>cancel_order_by_cloid(client_id)</code>  <code>async</code>","text":"<p>Cancel order by client ID.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID for the order.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.cancel_order_by_oid","title":"<code>cancel_order_by_oid(order_id)</code>  <code>async</code>","text":"<p>Cancel order by order ID.</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>str</code> <p>The order ID.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.contract_specifications","title":"<code>contract_specifications(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_account","title":"<code>get_account()</code>  <code>async</code>","text":"<p>Get account details.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_all_marks","title":"<code>get_all_marks(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mark-price for all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mark-prices (Decimal) as values.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_all_mids","title":"<code>get_all_mids(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for all available tickers.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with contract symbols as keys and their corresponding mid-prices (Decimal) as values  if <code>ticker</code> is not provided.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_balances","title":"<code>get_balances()</code>  <code>async</code>","text":"<p>Get account balances.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_bbo","title":"<code>get_bbo(market)</code>  <code>async</code>","text":"<p>Get the best bid and offer for a specific market.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_fills","title":"<code>get_fills(**kwargs)</code>  <code>async</code>","text":"<p>Get account fills.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional params.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_funding_data","title":"<code>get_funding_data(market, **kwargs)</code>  <code>async</code>","text":"<p>Get funding data for a specific market.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_funding_info","title":"<code>get_funding_info(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve funding information from the exchange.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing information for each asset with key-values: - FUNDING_RATE. - NEXT_FUNDING. - MARK_PRICE. - FUNDING_INTERVAL.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_funding_payments","title":"<code>get_funding_payments(**kwargs)</code>  <code>async</code>","text":"<p>Get account funding payments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional params.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_insurance","title":"<code>get_insurance()</code>  <code>async</code>","text":"<p>Get insurance details.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_jwt_token","title":"<code>get_jwt_token()</code>","text":"<p>Get the current JWT token for the exchange private methods.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_liquidations","title":"<code>get_liquidations(**kwargs)</code>  <code>async</code>","text":"<p>Get liquidations.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_lot_precision","title":"<code>get_lot_precision(ticker)</code>","text":"<p>Retrieves the lot size precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for lot size precision.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_markets","title":"<code>get_markets()</code>  <code>async</code>","text":"<p>Get all available markets.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_markets_summary","title":"<code>get_markets_summary(market='ALL', **kwargs)</code>  <code>async</code>","text":"<p>Get the summary of all markets.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol. Defaults to 'ALL'.</p> <code>'ALL'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_ohlcv","title":"<code>get_ohlcv(end_at, resolution, start_at, symbol)</code>  <code>async</code>","text":"<p>Get OHLCV data for a specific market.</p> <p>Parameters:</p> Name Type Description Default <code>end_at</code> <code>str</code> <p>The end time.</p> required <code>resolution</code> <code>str</code> <p>The resolution of the candle.</p> required <code>start_at</code> <code>str</code> <p>The start time.</p> required <code>symbol</code> <code>str</code> <p>The market symbol.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_open_orders","title":"<code>get_open_orders(**kwargs)</code>  <code>async</code>","text":"<p>Get open orders.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_open_positions","title":"<code>get_open_positions()</code>  <code>async</code>","text":"<p>Get open positions.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_order_by_cloid","title":"<code>get_order_by_cloid(client_id)</code>  <code>async</code>","text":"<p>Get order by client ID.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID for the order.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_order_by_oid","title":"<code>get_order_by_oid(order_id)</code>  <code>async</code>","text":"<p>Get order by order ID.</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>str</code> <p>The order ID.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_orderbook","title":"<code>get_orderbook(market, **kwargs)</code>  <code>async</code>","text":"<p>Get the orderbook for a specific market.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_orders_history","title":"<code>get_orders_history(**kwargs)</code>  <code>async</code>","text":"<p>Get list of orders history.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_points","title":"<code>get_points(market, program)</code>  <code>async</code>","text":"<p>Get points data for a specific market and program.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required <code>program</code> <code>str</code> <p>The program.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_price_precision","title":"<code>get_price_precision(ticker)</code>","text":"<p>Retrieves the price precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for price precision.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_profile","title":"<code>get_profile()</code>  <code>async</code>","text":"<p>Get profile details.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_referral_config","title":"<code>get_referral_config()</code>  <code>async</code>","text":"<p>Get referral config.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_referral_summary","title":"<code>get_referral_summary()</code>  <code>async</code>","text":"<p>Get user referral summary.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_system_config","title":"<code>get_system_config()</code>  <code>async</code>","text":"<p>Get exchange system config.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_system_state","title":"<code>get_system_state()</code>  <code>async</code>","text":"<p>Get exchange system state.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_system_time","title":"<code>get_system_time()</code>  <code>async</code>","text":"<p>Get exchange system time.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_tradebusts","title":"<code>get_tradebusts()</code>  <code>async</code>","text":"<p>Get tradebusts.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_trades","title":"<code>get_trades(market, **kwargs)</code>  <code>async</code>","text":"<p>Get trades for a specific market.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_transactions","title":"<code>get_transactions(**kwargs)</code>  <code>async</code>","text":"<p>Get transactions.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional params.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_transfers","title":"<code>get_transfers(**kwargs)</code>  <code>async</code>","text":"<p>Get transfers.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vault_account_summary","title":"<code>get_vault_account_summary(**kwargs)</code>  <code>async</code>","text":"<p>Get user's vault account summary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vault_config","title":"<code>get_vault_config()</code>  <code>async</code>","text":"<p>Get vault config.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vault_history","title":"<code>get_vault_history(address, type, resolution)</code>  <code>async</code>","text":"<p>Get vault history.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address of the vault.</p> required <code>type</code> <code>str</code> <p>The type.</p> required <code>resolution</code> <code>str</code> <p>The resolution of history.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vault_positions","title":"<code>get_vault_positions(address)</code>  <code>async</code>","text":"<p>Get vault positions.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address of the vault.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vault_summary","title":"<code>get_vault_summary(**kwargs)</code>  <code>async</code>","text":"<p>Get exchange vault summary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.get_vaults","title":"<code>get_vaults(**kwargs)</code>  <code>async</code>","text":"<p>Get vault details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the exchange client.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_get","title":"<code>l2_book_get(ticker, depth=100, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the L2 Order Book for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order book. Defaults to 100.</p> <code>100</code> <code>standardize_schema</code> <code>bool</code> <p>If True, returns the order book in a standardized schema. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=15, stream_depth=15, buffer_size=100, as_dict=True, on_update=None, speed_ms=100, apply_shadow_depth=True, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation.</p> <code>15</code> <code>stream_depth</code> <code>int</code> <p>Depth of the order-book stream.</p> <code>15</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code>.</p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>speed_ms</code> <code>(int, 100)</code> <p>Speed of the order book updates in milliseconds.</p> <code>100</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, depth=15, speed_ms=100, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream updates. Defaults to 15 (snapshot). Other depths are delta updates.</p> <code>15</code> <code>speed_ms</code> <code>int</code> <p>Speed of the order book updates in milliseconds. Defaults to 100.</p> <code>100</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, depth=15, speed_ms=100, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the l2 stream update subscribed. Defaults to 15.</p> <code>15</code> <code>speed_ms</code> <code>int</code> <p>Speed of the order book updates in milliseconds. Defaults to 100.</p> <code>100</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.limit_order","title":"<code>limit_order(ticker, amount, price, tif='GTC', reduce_only=False, cloid=None, round_price=False, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"Gtc\".                  Allowed values are:                  - \"GTC\" (Good 'til canceled)                  - \"POST_ONLY\" (Add liquidity only)                  - \"IOC\" (Immediate or cancel)</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.market_order","title":"<code>market_order(ticker, amount, tif='GTC', reduce_only=False, cloid=None, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>tif</code> <code>str</code> <p>Time in force. Defaults to <code>GTC</code>. Valid values are <code>GTC</code>, <code>IOC</code>.</p> <code>'GTC'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>str</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement. This typically includes a confirmation of the placed order, or an error message if the order could not be placed.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.oracle_subscribe","title":"<code>oracle_subscribe(handler, ticker='USDC', **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to the USD/USDC price updates.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.order_query","title":"<code>order_query(ticker, oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using client order ID.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>str</code> <p>Order ID in exchange (not used for actual query, echoed back as result).</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID (used for actual query).</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.orders_get","title":"<code>orders_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open orders.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing order details.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.positions_get","title":"<code>positions_get()</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> required"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.post_auth","title":"<code>post_auth()</code>  <code>async</code>","text":"<p>Post on auth request for a valid JWT token.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.post_onboarding","title":"<code>post_onboarding()</code>  <code>async</code>","text":"<p>Post on onboarding request.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.post_order","title":"<code>post_order(market, instruction, side, size, type, price=Decimal('0'), client_id=None, reduce_only=False, recv_window=None, stp=None, trigger_price=None, **kwargs)</code>  <code>async</code>","text":"<p>Submit an order to the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market symbol.</p> required <code>instruction</code> <code>str</code> <p>The instruction for the order.</p> required <code>side</code> <code>str</code> <p>The side of the order.</p> required <code>size</code> <code>float or Decimal</code> <p>The size of the order.</p> required <code>type</code> <code>str</code> <p>The type of the order.</p> required <code>price</code> <code>float or Decimal</code> <p>The price of the order. Defaults to Decimal('0') for market order.</p> <code>Decimal('0')</code> <code>client_id</code> <code>str</code> <p>The client ID for the order. Defaults to None.</p> <code>None</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order is reduce only. Defaults to False.</p> <code>False</code> <code>recv_window</code> <code>int</code> <p>The receive window for the order. Defaults to None.</p> <code>None</code> <code>stp</code> <code>str</code> <p>The stop price for the order. Defaults to None.</p> <code>None</code> <code>trigger_price</code> <code>float or Decimal</code> <p>The trigger price for the order. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generate a random string (cloid) consisting of hexadecimal characters.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>A string to prepend to the generated random string. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>A string to append to the generated random string. Defaults to ''.</p> <code>''</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A random hexadecimal string with a total length of 36 characters,  including the optional 'start' and 'end' strings.</p>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to trade updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>(ts,price,sz,dir)</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/paradex/#quantpylib.wrappers.paradex.Paradex.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from trade updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/polymarket/","title":"quantpylib.wrappers.polymarket","text":"<p><code>quantpylib.wrappers.polymarket</code> module is our official Polymarket wrapper SDK implementing the endpoints for contract betting. The library supports a fully asynchronous endpoint for efficiency and lightweight concurrency. </p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions and officially undocumented endpoints!</p>"},{"location":"wrappers/polymarket/#examples","title":"Examples","text":"<p>Let's start with the imports and code initiation: <pre><code>import os \nimport asyncio \n\nfrom pprint import pprint \nfrom datetime import datetime \nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.wrappers.polymarket import Polymarket\n\nasync def main():\n    pass #&lt;&lt; code goes here\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>By far the biggest complaint with their SDK and their documentation is how ridiculously difficult it is to get the correct configurations to submit API orders. Here is the run down.</p> <p>You deposit money into Polymarket. This is in USDC. You need to permit USDC.E allowance - you can do this in the UI after you sending the funds. This is pretty clear from their user interface, and actually does not require automation.</p> <p>When you instantiate the SDK - you need to know which type of account you are using. This is actually detailed in their documentation with 3 kinds of instantiation - using the EOA address, Email login or Browser Wallet login.</p> <p>There are multiple keys involved. If you used a Browser wallet, there will be the Polygon address (KEY1) of that wallet. Then there is the secret key (KEY2) that is paired with the Polygon address. Then there is also the public and private key pair associated with the Polymarket account. This can be exported from their web trading platform under Deposit &gt; Desposit Address (public, KEY3) &gt; Balance.More &gt; Export Private Key (private, KEY4).</p> <p>With the email wallet login, your environment variables would be  <pre><code>polymarket_key = KEY1\nsecret = KEY4\nsig_type = 1\n</code></pre> and with the browser wallet login, your environment variables would be  <pre><code>polymarket_key = KEY1\nsecret = KEY2\nsig_type = 2\n</code></pre> I hope that is clear and saved you some time scouring through their 'Github issues' or 'Discord/dev' channel. </p> <p>With that in mind, let's write some code! The polymarket SDK wrapper is only partially gateway-compatible, obviously due to the unique nature of betting markets as opposed to perpetual or spot markets.</p> <p>We can start with this (self-explanatory): <pre><code>async def main():\n    '''using the SDK'''\n    poly = Polymarket(\n        polymarket_key=os.getenv(\"POLY_KEY\"),\n        secret=os.getenv(\"POLY_SECRET\"),\n        sig_type=1\n    )\n    await poly.init_client()\n\n    print(poly.get_polymarket_key())\n    print(poly.get_signer_address())\n    print(poly.get_contract_config())\n    print(poly.get_conditional_address())\n    print(poly.get_exchange_address())\n</code></pre></p> <p>You can get your account balances like this: <pre><code>'''GATEWAY ENDPOINTS'''\npprint(await poly.account_balance())\n</code></pre> which gives output like this: <pre><code>{'bets': Decimal('0.95'),\n 'cash': Decimal('504.192361'),\n 'equity_total': 505.142361}\n</code></pre> This is actually not an endpoint available in their API documentation or SDK, but are the figures shown in the top bar on your trader platform!</p> <p>We can ask for market summaries; <pre><code>pprint(await poly.contract_specifications())\n</code></pre> and this gets us (we have automatically iterated the cursors to poll full results): <pre><code>...\n{'accepting_order_timestamp': '2024-12-22T07:08:56Z',\n           'accepting_orders': True,\n           'active': True,\n           'archived': False,\n           'closed': False,\n           'condition_id': '0x9915bea232fa12b20058f9cea1187ea51366352bf833393676cd0db557a58249',\n           'description': 'In the upcoming NHL game, scheduled for blah blah blah',\n           'enable_order_book': True,\n           'end_date_iso': '2025-01-05T00:00:00Z',\n           'fpmm': '0x32a8d457aF8d063111303178689bdb91DAab0581',\n           'game_start_time': '2024-12-29T00:00:00Z',\n           'icon': 'https://polymarket-upload.s3.us-east-2.amazonaws.com/nhl.png',\n           'image': 'https://polymarket-upload.s3.us-east-2.amazonaws.com/nhl.png',\n           'is_50_50_outcome': False,\n           'maker_base_fee': 0,\n           'market_slug': 'nhl-wsh-tor-2024-12-28',\n           'minimum_order_size': 5,\n           'minimum_tick_size': 0.01,\n           'neg_risk': False,\n           'neg_risk_market_id': '',\n           'neg_risk_request_id': '',\n           'notifications_enabled': False,\n           'question': 'Capitals vs. Maple Leafs',\n           'question_id': '0xfefa98bc82182b8f385298de3842ea8f8c2beaaed87ef1812eeb787b34f7ab1c',\n           'rewards': {'max_spread': 0, 'min_size': 0, 'rates': None},\n           'seconds_delay': 3,\n           'tags': ['Sports', 'NHL', 'Games'],\n           'taker_base_fee': 0,\n           'tokens': [{'outcome': 'Capitals',\n                       'price': 0.5,\n                       'token_id': '60989902840126768738269456361150551078629202162302557022265426129538140181471',\n                       'winner': False},\n                      {'outcome': 'Maple Leafs',\n                       'price': 0.5,\n                       'token_id': '29299903966152818260760859271342991417079619740850848288273676438278713549119',\n                       'winner': False}]}],\n 'limit': 22551,\n 'next_cursor': 'LTE='\n</code></pre> as well as the current open orders and positions: <pre><code>pprint(await poly.orders_get())\npprint(await poly.positions_get())\n</code></pre> which gives  <pre><code>{'abcd': {'amount': Decimal('10'),\n        'filled_sz': Decimal('0'),\n        'market': '0x87d67272f0ce1bb0d80ba12a1ab79287b2a235a5f361f5bcbc06ea0ce34e61c5',\n        'oid': 'abcd',\n        'outcome': 'Yes',\n        'price': Decimal('0.77'),\n        'ticker': '25788984364015292223605977307142748201985724991469784186655292374059222006895',\n        'tif': 'GTC',\n        'timestamp': 1734885235}}\n ...\n</code></pre> for the resting orders and  <pre><code>{'efg': {'amount': Decimal('100'),\n        'entry': Decimal('0.012'),\n        'event_slug': 'us-government-shutdown-before-2025',\n        'market': '0x87d67272f0ce1bb0d80ba12a1ab79287b2a235a5f361f5bcbc06ea0ce34e61c5',\n        'opposite': '25788984364015292223605977307142748201985724991469784186655292374059222006895',\n        'outcome': 'No',\n        'slug': 'us-government-shutdown-before-2025',\n        'ticker': 'efg',\n        'value': Decimal('0.8999999999999999')}}\n</code></pre> for the positions. We have made it super easy to submit orders, almost as if it is a normal spot market - just put in the correct ticker (they are different for yes or no) <pre><code>print(\n    await poly.limit_order(\n        ticker=\"19045189272319329424023217822141741659150265216200539353252147725932663608488\",\n        amount=10,\n        price=0.1,\n    )\n)\n</code></pre> as well as market (taker) orders: <pre><code>print(\n    await poly.market_order(\n        ticker=\"19045189272319329424023217822141741659150265216200539353252147725932663608488\",\n        amount=10,\n    )\n)\n</code></pre> and order book snapshots: <pre><code>print(await poly.l2_book_get(ticker=\"19045189272319329424023217822141741659150265216200539353252147725932663608488\",))\n</code></pre></p> <p>That's it for the gateway endpoints - of course we have all of the exchange API documented endpoints directly available too: <pre><code>pprint(await poly.time())\npprint(await poly.get_collateral_allowance())\npprint(await poly.get_tick_size(token_id=\"19045189272319329424023217822141741659150265216200539353252147725932663608488\"))\npprint(await poly.create_api_key())\npprint(await poly.derive_api_key())\npprint(await poly.get_api_keys())\npprint(await poly.access_status())\n\nawait poly.post_order(order=None)\npprint(await poly.get_order(order_id=\"123\")) \npprint(await poly.get_orders())\npprint(await poly.cancel_order(order_id=\"123\"))\npprint(await poly.cancel_orders(order_ids=[]))\npprint(await poly.cancel_all_orders())\npprint(await poly.cancel_market_orders(market=\"123\"))\n</code></pre> and much more! Happy trading/speculating/arbitraging.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.OrderBuilder","title":"<code>OrderBuilder</code>","text":""},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.OrderBuilder.create_order","title":"<code>create_order(order_args, options)</code>","text":"<p>Creates and signs an order</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket","title":"<code>Polymarket</code>","text":""},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.__init__","title":"<code>__init__(polymarket_key, secret, chain_id=POLYGON, sig_type=2, funder=None)</code>","text":"<p>Instantiates the Polymarket wrapper class.</p> <p>Parameters:</p> Name Type Description Default <code>polymarket_key</code> <code>str</code> <p>The Polymarket account key. (Top RHS, copy address)</p> required <code>secret</code> <code>str</code> <p>The Polygon secret key (browser wallet) or Polymarket secret (email wallet - Deposit &gt; Expand ... &gt; Export private key).</p> required <code>chain_id</code> <code>int</code> <p>The Polygon chain ID. Defaults to 137.</p> <code>POLYGON</code> <code>sig_type</code> <code>int</code> <p>The signature type. Defaults to <code>2</code>. <code>1</code> if email wallet, <code>2</code> if Browser wallet.</p> <code>2</code> <code>funder</code> <code>str</code> <p>The funder address. Defaults to <code>polymarket_key</code>.</p> <code>None</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.access_status","title":"<code>access_status()</code>  <code>async</code>","text":"<p>Get the access status (if user has <code>cert_required=True</code>, one is required to provide proof of residence).</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Get the account balance. Includes total equity, cash, and bets.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_clob_markets","title":"<code>all_clob_markets(**kwargs)</code>  <code>async</code>","text":"<p>Get all clob markets with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_clob_markets_page","title":"<code>all_clob_markets_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all clob markets without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_sampling_markets","title":"<code>all_sampling_markets(**kwargs)</code>  <code>async</code>","text":"<p>Get all sampling markets with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_sampling_markets_page","title":"<code>all_sampling_markets_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all sampling markets without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_sampling_simplified_markets","title":"<code>all_sampling_simplified_markets(**kwargs)</code>  <code>async</code>","text":"<p>Get all sampling simplified markets with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_sampling_simplified_markets_page","title":"<code>all_sampling_simplified_markets_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all sampling simplified markets without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_simplified_markets","title":"<code>all_simplified_markets(**kwargs)</code>  <code>async</code>","text":"<p>Get all simplified markets with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.all_simplified_markets_page","title":"<code>all_simplified_markets_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all simplified markets without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.cancel_all_orders","title":"<code>cancel_all_orders(**kwargs)</code>  <code>async</code>","text":"<p>Cancel all orders.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.cancel_market_orders","title":"<code>cancel_market_orders(market=None, asset_id=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel all orders for a market.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>The market ID. Defaults to None.</p> <code>None</code> <code>asset_id</code> <code>str</code> <p>The asset ID. Defaults to None.</p> <code>None</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.cancel_order","title":"<code>cancel_order(order_id, **kwargs)</code>  <code>async</code>","text":"<p>Cancel an order by ID.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.cancel_orders","title":"<code>cancel_orders(order_ids, **kwargs)</code>  <code>async</code>","text":"<p>Cancel multiple orders by IDs.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.contract_specifications","title":"<code>contract_specifications(**kwargs)</code>  <code>async</code>","text":"<p>Get the contract specifications of all markets (expired and trading).</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.create_api_key","title":"<code>create_api_key(nonce=None)</code>  <code>async</code>","text":"<p>Create an API key.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.delete_api_key","title":"<code>delete_api_key(nonce=None)</code>  <code>async</code>","text":"<p>Delete the API key.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.derive_api_key","title":"<code>derive_api_key(nonce=None)</code>  <code>async</code>","text":"<p>Derive the API key.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.fetch_slug_market","title":"<code>fetch_slug_market(slug)</code>  <code>async</code>","text":"<p>Uses the Gamma API to fetch the market by slug.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.gamma_get_event","title":"<code>gamma_get_event(id, **kwargs)</code>  <code>async</code>","text":"<p>Get an event by ID from the Gamma API.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The event ID.</p> required <code>kwargs</code> <code>dict</code> <p>The query parameters.</p> <code>{}</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.gamma_get_events","title":"<code>gamma_get_events(**kwargs)</code>  <code>async</code>","text":"<p>Get all events from the Gamma API.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>The query parameters.</p> <code>{}</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.gamma_get_market","title":"<code>gamma_get_market(id, **kwargs)</code>  <code>async</code>","text":"<p>Get a market by ID from the Gamma API.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The market ID.</p> required <code>kwargs</code> <code>dict</code> <p>The query parameters.</p> <code>{}</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.gamma_get_markets","title":"<code>gamma_get_markets(**kwargs)</code>  <code>async</code>","text":"<p>Get all markets from the Gamma API.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>The query parameters.</p> <code>{}</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_api_keys","title":"<code>get_api_keys(nonce=None)</code>  <code>async</code>","text":"<p>Get all API keys.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_balance_allowance","title":"<code>get_balance_allowance(asset_type, token_id=None, signature_type=-1, **kwargs)</code>  <code>async</code>","text":"<p>The correct token allowances must be set before orders can be placed.  The following mainnet (Polygon) allowances should be set by the funding (maker) address. See: https://github.com/Polymarket/py-clob-client?tab=readme-ov-file#allowances</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_bet_value","title":"<code>get_bet_value(**kwargs)</code>  <code>async</code>","text":"<p>Get the value of the user's bets (officially undocumented endpoint).</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_book","title":"<code>get_book(token_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the book for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token_id</code> <code>str</code> <p>The token ID.</p> required"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_books","title":"<code>get_books(token_ids=[], **kwargs)</code>  <code>async</code>","text":"<p>Get the books for multiple tokens.</p> <p>Parameters:</p> Name Type Description Default <code>token_ids</code> <code>list</code> <p>The token IDs. Defaults to [].</p> <code>[]</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_collateral_allowance","title":"<code>get_collateral_allowance(signature_type=-1)</code>  <code>async</code>","text":"<p>Get the collateral allowance amount.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_conditional_allowance","title":"<code>get_conditional_allowance(token_id, signature_type=-1)</code>  <code>async</code>","text":"<p>Get the conditional allowance amount.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_market","title":"<code>get_market(condition_id, **kwargs)</code>  <code>async</code>","text":"<p>Get a market by condition ID.</p> <p>Parameters:</p> Name Type Description Default <code>condition_id</code> <code>str</code> <p>The condition ID.</p> required"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_midpoint","title":"<code>get_midpoint(token_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the midpoint for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token_id</code> <code>str</code> <p>The token ID.</p> required"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_midpoints","title":"<code>get_midpoints(token_ids=[], **kwargs)</code>  <code>async</code>","text":"<p>Get the midpoints for multiple tokens.</p> <p>Parameters:</p> Name Type Description Default <code>token_ids</code> <code>list</code> <p>The token IDs. Defaults to [].</p> <code>[]</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_neg_risk","title":"<code>get_neg_risk(token_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the negative risk of the token.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_order","title":"<code>get_order(order_id, **kwargs)</code>  <code>async</code>","text":"<p>Get an order by ID.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_orders","title":"<code>get_orders(**kwargs)</code>  <code>async</code>","text":"<p>Get all orders with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_orders_page","title":"<code>get_orders_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all orders without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_positions","title":"<code>get_positions(limit=100, **kwargs)</code>  <code>async</code>","text":"<p>Get positions of the user (officially undocumented endpoint).</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_price","title":"<code>get_price(token_id, side, **kwargs)</code>  <code>async</code>","text":"<p>Get the price for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token_id</code> <code>str</code> <p>The token ID.</p> required <code>side</code> <code>str</code> <p>The side <code>BUY</code> or <code>SELL</code>.</p> required"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_prices","title":"<code>get_prices(token_ids=[], sides=[], **kwargs)</code>  <code>async</code>","text":"<p>Get the prices for multiple tokens.</p> <p>Parameters:</p> Name Type Description Default <code>token_ids</code> <code>list</code> <p>The token IDs. Defaults to [].</p> <code>[]</code> <code>sides</code> <code>list</code> <p>The sides <code>BUY</code> or <code>SELL</code>. Defaults to [].</p> <code>[]</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_spread","title":"<code>get_spread(token_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the spread for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token_id</code> <code>str</code> <p>The token ID.</p> required"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_spreads","title":"<code>get_spreads(token_ids=[], **kwargs)</code>  <code>async</code>","text":"<p>Get the spreads for multiple tokens.</p> <p>Parameters:</p> Name Type Description Default <code>token_ids</code> <code>list</code> <p>The token IDs. Defaults to [].</p> <code>[]</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_tick_size","title":"<code>get_tick_size(token_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the tick size of the token.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_trades","title":"<code>get_trades(**kwargs)</code>  <code>async</code>","text":"<p>Get all trades with iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.get_trades_page","title":"<code>get_trades_page(**kwargs)</code>  <code>async</code>","text":"<p>Get all trades without iterated pagination.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initialize the Polymarket client.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.l2_book_get","title":"<code>l2_book_get(ticker, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get the level 2 book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The token ID for <code>yes</code> or <code>no</code> of relevant market.</p> required <code>as_dict</code> <code>bool</code> <p>Whether to return the book as a dictionary. Defaults to True.</p> <code>True</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.limit_order","title":"<code>limit_order(ticker, amount, price, tif='GTC', round_price=True, tick_size=None, **kwargs)</code>  <code>async</code>","text":"<p>Place a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The token ID for <code>yes</code> or <code>no</code> of relevant market. Also known as <code>token_id</code> or <code>asset_id</code>.</p> required <code>amount</code> <code>float</code> <p>The signed amount of the token.</p> required <code>price</code> <code>float</code> <p>The price of the limit order.</p> required <code>tif</code> <code>str</code> <p>The time in force. Defaults to 'GTC'.</p> <code>'GTC'</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price. Defaults to True.</p> <code>True</code> <code>tick_size</code> <code>str</code> <p>The tick size. Defaults to None.</p> <code>None</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.market_order","title":"<code>market_order(ticker, amount, tif='GTC', **kwargs)</code>  <code>async</code>","text":"<p>Place a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The token ID for <code>yes</code> or <code>no</code> of relevant market.</p> required <code>amount</code> <code>float</code> <p>The signed amount of the token.</p> required <code>tif</code> <code>str</code> <p>The time in force. Defaults to 'GTC'.</p> <code>'GTC'</code>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.orders_get","title":"<code>orders_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open orders.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.positions_get","title":"<code>positions_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open positions.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.post_order","title":"<code>post_order(order, order_type='GTC', **kwargs)</code>  <code>async</code>","text":"<p>Post an order.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.time","title":"<code>time()</code>  <code>async</code>","text":"<p>Get the exchange server time.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.Polymarket.update_balance_allowance","title":"<code>update_balance_allowance(asset_type, token_id=None, signature_type=-1, **kwargs)</code>  <code>async</code>","text":"<p>Update the balance allowance amount. If asset type is <code>CONDITIONAL</code>, the token ID is required.</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.build_hmac_signature","title":"<code>build_hmac_signature(secret, timestamp, method, endpoint, body=None)</code>","text":"<p>Creates an HMAC signature by signing a payload with the secret</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.create_level_1_headers","title":"<code>create_level_1_headers(signer, nonce=None, **kwargs)</code>","text":"<p>Creates Level 1 Poly headers for a request</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.create_level_2_headers","title":"<code>create_level_2_headers(signer, method, endpoint, api_key, api_secret, api_passphrase, json=None, **kwargs)</code>","text":"<p>Creates Level 2 Poly headers for a request</p>"},{"location":"wrappers/polymarket/#quantpylib.wrappers.polymarket.get_contract_config","title":"<code>get_contract_config(chainID, neg_risk=False)</code>","text":"<p>Get the contract configuration for the chain</p>"},{"location":"wrappers/woox/","title":"quantpylib.wrappers.woox","text":"<p><code>quantpylib.wrappers.woox</code> module is our official WooX wrapper SDK implementing the endpoints for trading. The library supports a fully asynchronous endpoint for efficiency and lightweight  concurrency. The websocket manager handles reconnections and resubsriptions under network errors and upgrades.</p> <p>We will demonstrate usage of the library. On top of the endpoints exposed by the exchange, we have added a variety of utility functions.</p>"},{"location":"wrappers/woox/#examples","title":"Examples","text":"<p>We would demonstrate some endpoints. Refer to full documentation for details. <pre><code>import os\nimport pytz\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nload_dotenv()\n\nfrom quantpylib.wrappers.woox import Woox\n\nasync def print_handler(msg):\n    print(msg)\n\nasync def main():\n    \"\"\"using the SDK\"\"\"\n    woox = Woox(\n        key=os.getenv(\"WOO_KEY\"),\n        secret=os.getenv(\"WOO_SECRET\"),\n        app_id=os.getenv(\"WOO_APP\"),\n    )\n    \"\"\"quantpylib.gateway endpoints\"\"\"\n    await woox.init_client()\n    print(woox.get_price_precision(\"PERP_BTC_USDT\"))\n    print(woox.get_lot_precision(\"PERP_BTC_USDT\"))\n\n    '''ACCOUNT ENDPOINTS'''\n    pprint(await woox.account_balance())\n    await woox.account_fill_subscribe(handler=print_handler)\n\n    '''EXCHANGE ENDPOINTS'''\n    pprint(await woox.contract_specifications())\n    pprint(await woox.get_funding_info())\n\n    '''EXECUTOR ENDPOINTS'''\n    cloid = woox.rand_cloid()\n    print(cloid)\n    pprint(await woox.get_all_mids())\n    pprint(await woox.get_all_marks())\n    pprint(await woox.limit_order(ticker=\"PERP_SOL_USDT\",amount=1,price=99.99,cloid=cloid))\n    pprint(await woox.cancel_open_orders()) #or use ticker=\"PERP_SOL_USDT\"\n    pprint(await woox.cancel_order(ticker=\"PERP_SOL_USDT\",cloid=cloid)) #or use oid\n    pprint(await woox.market_order(ticker=\"PERP_SOL_USDT\",amount=-0.5))\n    pprint(await woox.l2_book_get(ticker=\"PERP_SOL_USDT\"))\n    await woox.l2_book_mirror(ticker=\"PERP_BTC_USDT\",on_update=print_handler)\n    await woox.l2_book_subscribe(ticker=\"PERP_BTC_USDT\",handler=print_handler)\n    await woox.trades_subscribe(ticker=\"PERP_BTC_USDT\",handler=print_handler)\n    await woox.all_mids_subscribe(handler=print_handler)\n\n    '''ORDERS ENDPOINTS'''\n    pprint(await woox.order_query(ticker='PERP_SOL_USDT',cloid='1234'))\n    pprint(await woox.orders_get())\n    await woox.orders_mirror(on_update=print_handler)\n    await woox.order_updates_subscribe(handler=print_handler)\n\n    '''POSITIONS ENDPOINTS'''\n    pprint(await woox.positions_get())\n    await woox.positions_mirror(on_update=print_handler)\n\n    '''DATAPOLLER ENDPOINTS'''\n    # pprint(await woox.get_trade_bars(\n    #     ticker='PERP_BTC_USDT',\n    #     start=datetime(2021,1,1, tzinfo=pytz.utc),\n    #     end=datetime.now(pytz.utc),\n    #     granularity=Period.HOURLY,\n    #     granularity_multiplier=1,\n    # ))\n\n    '''raw exchange endpoints API - refer to docs for the other method implementations'''\n    pprint(await woox.system_maintenance_status())\n    pprint(await woox.exchange_info())\n    pprint(await woox.market_trades(symbol=\"PERP_BTC_USDT\"))\n    #&gt;... many more\n    await asyncio.sleep(1e9)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> </p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox","title":"<code>Woox</code>","text":""},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.__init__","title":"<code>__init__(key=None, secret=None, app_id=None, environment=Environment.PROD)</code>","text":"<p>Initializes the WooX instance.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>API key for authentication. </p> <code>None</code> <code>secret</code> <code>str</code> <p>API secret for authentication.</p> <code>None</code> <code>app_id</code> <code>str</code> <p>Application ID for authentication.</p> <code>None</code> <code>environment</code> <code>int</code> <p>The environment to connect to. 1 for production, 2 for staging. Defaults to 1.</p> <code>PROD</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.account_balance","title":"<code>account_balance(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve balance details of the user, such as equity, margin (total, maintenance) and pnl.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Balance details.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.account_fill_subscribe","title":"<code>account_fill_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to order fill events.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.account_fill_unsubscribe","title":"<code>account_fill_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order fill events.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.all_mids_subscribe","title":"<code>all_mids_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to mid-price updates for all tickers.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.all_mids_unsubscribe","title":"<code>all_mids_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from mid-price updates for all tickers.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.cancel_all_pending_orders","title":"<code>cancel_all_pending_orders()</code>  <code>async</code>","text":"<p>Cancel all pending orders.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.cancel_open_orders","title":"<code>cancel_open_orders(ticker=None, **kwargs)</code>  <code>async</code>","text":"<p>Cancel open orders on the exchange.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol. Defaults to None, which means cancel all open orders.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the cancellation request.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.cancel_order","title":"<code>cancel_order(order_id, symbol)</code>  <code>async</code>","text":"<p>Cancel an order.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.cancel_order_by_client_id","title":"<code>cancel_order_by_client_id(client_order_id, symbol)</code>  <code>async</code>","text":"<p>Cancel an order by client order ID.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.cancel_orders","title":"<code>cancel_orders(symbol)</code>  <code>async</code>","text":"<p>Cancel all orders for a specific ticker.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.contract_specifications","title":"<code>contract_specifications(contract_type='PERP', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the contract's trading rules from the exchange.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing contract specifications for each asset with key-values: - SYMBOL_PRICE_PRECISION. - SYMBOL_QUANTITY_PRECISION. - SYMBOL_MIN_NOTIONAL - SYMBOL_BASE_ASSET - SYMBOL_QUOTE_ASSET</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.exchange_info","title":"<code>exchange_info(symbol=None)</code>  <code>async</code>","text":"<p>Retrieve the exchange information.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.funding_rate_history","title":"<code>funding_rate_history(symbol, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the funding rate history for a specific contract.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.futures_info","title":"<code>futures_info(symbol=None)</code>  <code>async</code>","text":"<p>Retrieve the futures information.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_account_information","title":"<code>get_account_information()</code>  <code>async</code>","text":"<p>Retrieve the account information.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_all_marks","title":"<code>get_all_marks(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mark-price for all available tickers.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_all_mids","title":"<code>get_all_mids(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the mid-price for a specific ticker or all available tickers. NOTE: this endpoint is  not available in WooX - it calls the <code>get_all_marks</code> endpoint instead.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_current_holding","title":"<code>get_current_holding(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the current holding.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_funding_info","title":"<code>get_funding_info(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the funding rate and interval for all contracts.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_futures_leverage_setting","title":"<code>get_futures_leverage_setting(symbol, margin_mode, position_mode)</code>  <code>async</code>","text":"<p>Retrieve the futures leverage setting.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_lot_precision","title":"<code>get_lot_precision(ticker)</code>","text":"<p>Retrieves the lot size precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for lot size precision.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_order","title":"<code>get_order(order_id)</code>  <code>async</code>","text":"<p>Retrieve an order by order ID.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_order_by_client_id","title":"<code>get_order_by_client_id(client_order_id)</code>  <code>async</code>","text":"<p>Retrieve an order by client order ID.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_orders","title":"<code>get_orders(status='INCOMPLETE', **kwargs)</code>  <code>async</code>","text":"<p>Retrieve all orders.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_position_info","title":"<code>get_position_info(symbol)</code>  <code>async</code>","text":"<p>Retrieve the position information for a specific ticker.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_positions_info","title":"<code>get_positions_info()</code>  <code>async</code>","text":"<p>Retrieve the position information for all tickers.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_price_precision","title":"<code>get_price_precision(ticker)</code>","text":"<p>Retrieves the price precision for a specified ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of decimal places for price precision.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_trade","title":"<code>get_trade(trade_id)</code>  <code>async</code>","text":"<p>Retrieve a trade by trade ID.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_trade_history","title":"<code>get_trade_history(**kwargs)</code>  <code>async</code>","text":"<p>Retrieve the trade history.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.get_trades","title":"<code>get_trades(order_id)</code>  <code>async</code>","text":"<p>Retrieve all trades for an order.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.init_client","title":"<code>init_client()</code>  <code>async</code>","text":"<p>Initializes the client by fetching contract specifications and setting up precision mappings.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_get","title":"<code>l2_book_get(ticker, depth=100, standardize_schema=True, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the L2 Order Book for a specific ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order book. Defaults to 100.</p> <code>100</code> <code>standardize_schema</code> <code>bool</code> <p>If True, returns the order book in a standardized schema. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_mirror","title":"<code>l2_book_mirror(ticker, depth=50, buffer_size=100, as_dict=True, on_update=None, apply_shadow_depth=False, **kwargs)</code>  <code>async</code>","text":"<p>Keep a live, internal L2 Order Book representation using a l2-book subscription.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>depth</code> <code>int</code> <p>Depth of the order-book representation. Defaults to 50.</p> <code>50</code> <code>buffer_size</code> <code>int</code> <p>Size of the order-book buffer, if <code>as_dict</code> is <code>False</code>.</p> <code>100</code> <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, pass state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object into handlers.</p> <code>True</code> <code>on_update</code> <code>coroutine</code> <p>A coroutine handler when order book state is updated.</p> <code>None</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_peek","title":"<code>l2_book_peek(ticker, as_dict=True, **kwargs)</code>","text":"<p>Retrieve the mirrored, local internal L2 Order Book representation.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>as_dict</code> <code>(bool, True)</code> <p>If <code>True</code>, return state as dictionary, otherwise as a <code>quantpylib.hft.lob.LOB</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_subscribe","title":"<code>l2_book_subscribe(ticker, handler, standardize_schema=True, speed_ms=200, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to L2 Order Book stream.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>speed_ms</code> <code>int</code> <p>Speed of the order book updates in milliseconds. Defaults to 200, which use orderbook delta subscriptions. Otherwise, subscriptions are to snapshots.</p> <code>200</code> <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>{ts,b,a}</code></p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_subscriptions","title":"<code>l2_book_subscriptions(**kwargs)</code>","text":"<p>Retrieve the list of open l2 book subscriptions.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.l2_book_unsubscribe","title":"<code>l2_book_unsubscribe(ticker, speed_ms=200, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from L2 Order Book.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>speed_ms</code> <code>int</code> <p>Speed of the order book updates in milliseconds. Defaults to 200.</p> <code>200</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.limit_order","title":"<code>limit_order(ticker, amount, price, tif='LIMIT', reduce_only=False, cloid=None, round_price=False, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a limit order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The coin symbol.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>price</code> <code>float</code> <p>The price at which to execute the order.</p> required <code>tif</code> <code>str</code> <p>The time in force for the order. Defaults to \"LIMIT\".                  Allowed values are:                  - \"LIMIT\"                  - \"POST_ONLY\"                   - \"IOC\"                  - \"FOK\" </p> <code>'LIMIT'</code> <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>int</code> <p>Client order ID for order tracking. Defaults to None.</p> <code>None</code> <code>round_price</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for order customization.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.market_order","title":"<code>market_order(ticker, amount, reduce_only=False, cloid=None, round_size=False, **kwargs)</code>  <code>async</code>","text":"<p>Submit a market order.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol for the asset.</p> required <code>amount</code> <code>float or Decimal</code> <p>The signed quantity of contracts to long or short.</p> required <code>reduce_only</code> <code>bool</code> <p>Whether the order should only reduce an existing position. Defaults to False.</p> <code>False</code> <code>cloid</code> <code>int</code> <p>Client order ID for custom tracking. Defaults to None.</p> <code>None</code> <code>round_size</code> <code>bool</code> <p>Whether to round the price to a valid order specification. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments specific to the exchange wrapper.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the order placement. This typically includes a confirmation of the placed order, or an error message if the order could not be placed.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.market_trades","title":"<code>market_trades(symbol, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the trades for a specific ticker.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.order_query","title":"<code>order_query(oid=None, cloid=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Get order details using client order ID.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>str</code> <p>Order ID in exchange.</p> <code>None</code> <code>cloid</code> <code>str</code> <p>Client Order ID (used for actual query).</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, return the order details as a dictionary. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.order_updates_subscribe","title":"<code>order_updates_subscribe(handler, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to creation, updation and deletion of account's orders.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.order_updates_unsubscribe","title":"<code>order_updates_unsubscribe(**kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from order events.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.orderbook_snapshot","title":"<code>orderbook_snapshot(symbol, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the order book snapshot for a specific ticker.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.orders_get","title":"<code>orders_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open orders. Automatically iterates the cursor if required to retrieve all orders.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing order details.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.orders_mirror","title":"<code>orders_mirror(on_update=None, as_list=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for orders dictionary on order event.</p> <code>None</code> <code>as_list</code> <code>bool</code> <p>If <code>True</code>, pass state as list, otherwise as <code>quantpylib.standards.Orders</code> object into handlers.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.orders_peek","title":"<code>orders_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If <code>True</code>, pass state as dictionary, otherwise as <code>quantpylib.standards.Orders</code> object.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.positions_get","title":"<code>positions_get(**kwargs)</code>  <code>async</code>","text":"<p>Get all open position details.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.positions_mirror","title":"<code>positions_mirror(on_update=None, as_dict=True, **kwargs)</code>  <code>async</code>","text":"<p>Keeps a local mirror copy of the account open orders.</p> <p>Parameters:</p> Name Type Description Default <code>on_update</code> <code>coroutine</code> <p>A coroutine handler for positions dictionary on fill.</p> <code>None</code> <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.positions_peek","title":"<code>positions_peek(as_dict=True, **kwargs)</code>","text":"<p>Retrieves the local mirror copy of the account open positions.</p> <p>Parameters:</p> Name Type Description Default <code>as_dict</code> <code>bool</code> <p>If True, the method returns positions as a dictionary, otherwise as a <code>quantpylib.standards.Positions</code> object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.predicted_funding_rate","title":"<code>predicted_funding_rate(symbol)</code>  <code>async</code>","text":"<p>Retrieve the predicted funding rate for a specific contract.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.predicted_funding_rate_all","title":"<code>predicted_funding_rate_all()</code>  <code>async</code>","text":"<p>Retrieve the predicted funding rate for all contracts.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.rand_cloid","title":"<code>rand_cloid(start='', end='', **kwargs)</code>","text":"<p>Generate a random client order ID.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>String representation of an integer between 0 and 9223372036854775807. Defaults to ''.</p> <code>''</code> <code>end</code> <code>str</code> <p>String representation of an integer between 0 and 9223372036854775807. Defaults to ''.</p> <code>''</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.send_order","title":"<code>send_order(symbol, order_type, side, reduce_only=False, **kwargs)</code>  <code>async</code>","text":"<p>Send an order to the exchange.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.system_maintenance_status","title":"<code>system_maintenance_status()</code>  <code>async</code>","text":"<p>Retrieve the system maintenance status.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.trades_subscribe","title":"<code>trades_subscribe(ticker, handler, standardize_schema=True, woo_only=True, **kwargs)</code>  <code>async</code>","text":"<p>Subscribe to trade updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>handler</code> <code>coroutine</code> <p>A coroutine handler for the message received.</p> required <code>standardize_schema</code> <code>(bool, True)</code> <p>Processes the incoming message to <code>(ts,price,sz,dir)</code></p> <code>True</code> <code>woo_only</code> <code>(bool, True)</code> <p>If <code>True</code>, only subscribe to trades executed on WooX.</p> <code>True</code> <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.trades_unsubscribe","title":"<code>trades_unsubscribe(ticker, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from trade updates.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol.</p> required <code>**kwargs</code> <p>Exchange wrapper specific keyword arguments.</p> <code>{}</code>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.update_futures_leverage_setting","title":"<code>update_futures_leverage_setting(symbol, margin_mode, position_side, leverage)</code>  <code>async</code>","text":"<p>Update the futures leverage setting.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.update_isolated_margin","title":"<code>update_isolated_margin(**kwargs)</code>  <code>async</code>","text":"<p>Update the isolated margin.</p>"},{"location":"wrappers/woox/#quantpylib.wrappers.woox.Woox.update_leverage_setting","title":"<code>update_leverage_setting(leverage)</code>  <code>async</code>","text":"<p>Update the leverage setting.</p>"},{"location":"wrappers/wrappers/","title":"quantpylib.wrappers","text":"<p><code>quantpylib.wrappers</code> contain our SDKs for data vendors and exchange integrations. They may be used in silo, or as clients to <code>quantpylib.datapoller.master.Datapoller</code> and <code>quantpylib.gateway.master.Gateway</code> objects, which are further used in both OMS and data feeds used for live trading, backtesting and account management.</p>"},{"location":"wrappers/yfinance/","title":"quantpylib.wrappers.yfinance","text":""},{"location":"wrappers/yfinance/#quantpylib.wrappers.yfinance.YFinance","title":"<code>YFinance</code>","text":""},{"location":"wrappers/yfinance/#quantpylib.wrappers.yfinance.YFinance.get_trade_bars","title":"<code>get_trade_bars(ticker, start, end, granularity, granularity_multiplier, **kwargs)</code>  <code>async</code>","text":"<p>Fetches trade bars data for the specified ticker and time period.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>The ticker symbol.</p> required <code>start</code> <code>datetime</code> <p>The start date of the data to be fetched.</p> required <code>end</code> <code>datetime</code> <p>The end date of the data to be fetched.</p> required <code>granularity</code> <code>Period</code> <p>The granularity of the data.</p> required <code>granularity_multiplier</code> <code>int</code> <p>The multiplier for the granularity.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The DataFrame containing the trade bars data.</p>"}]}